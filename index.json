[{"content":"指南中能源管理  对主要能源介质数据进行自动采集、统计分析，对高能耗设备进行动态耗能监测与能耗分析， 建立具有能源计划、评价、平衡与预测模型的能源系统，实现能源动态监控和精细化管理。 鼓励企业基于采集和存储能源数据信息， 建立能源优化模型，对耗能和产能调度提供优化策略和优化方案。 鼓励企业建立融合实时能源数据的三维数字化管网，为工厂能源管线检修、改造升级提供支撑。  株冶智锌__能源  1 现状或不足  能源计划和能源统计由人工统计和核对； 能源消耗大量手工抄表及人工统计； 能源考核指标与生产实际消耗的能源需要人工关联； 计量器具不完备。   2 关键点或改进点  能源计划和生产计划自动关联，能源计划随生产计划及时改变。 实际能源消耗与能源计划实时对比； 重点能耗设备能效监控，提供节能降耗的依据； 能源管网实时监控，通过能源平衡计算，利于发现能源损耗异常点；   3 需求说明\n通过能源计划，能源监控，能源统计分析，能源对标管理等多种手段，使企业管理者对企业的能源成本比重，发展趋势有准确的掌握，并将企业的能源消费计划任务分解到各个生产部门车间，使节能工作责任明确，促进企业健康稳定发展。  (一)部门与分工  能源有两级管理机构。 公司级：有生产机动部设备动力室管理，含一个主任和5个员工，分区分专业对能源（电、能源、管网等）进行管理，主要工作是公司级能源计划、分厂级能源计划、公司能源采购、公司/分厂能源消耗统计、三级能源平衡。 分厂级：包括功能单位、用能单位，由分厂技术室专人管理，主要工作：各工段能源供应计划、各工段用源计划、工段临时用能管理、工段能源消耗统计。能源管理的范围为水、电、蒸汽、压缩风、焦煤、天然气、燃料油、氧气、汽油、柴油等。  (二)主要业务   能源平衡：目前已实现三级能源平衡，公司级（湖南有色）、分厂级（各分厂eg.焙烧、浸入、净化、电解、熔铸）、工段级（锌粉制造、银浮选、铟回收等）。每月计量中心上报各工段能源消耗数据，供能部门上报能源供应数据，生产机动部能源平衡工程师对供耗数据进行比对，结合当月生产实际情况和能源具体损耗情况，按照能源消耗经验值，手工进行平衡。能源统计每月一次。\n  能源数据采集：煤焦等采购能源供应量数据由采购部提供、电力供应量数据由电力控制室提供、蒸汽/压缩风/水供应量数据由动力厂提供；能源消耗数据统一由计量中心负责抄录，每天一次从仪表抄录，主要是远端仪表抄录、分厂级仪表数据抄录、工段级仪表抄录；各工段每日形成各介质能源记录台账，每月进行各能源统计，并将统计结果上报公司机动部设备动力管理室，如果统计结果存在明显错误，数据由计量中心修正后再上报给设备管理室\n  (三)管理需求  主要通过OPC接口从工业过程数据库中取得各种能源采样点的信号，实现水、电、燃料、蒸汽等能源介质的供应、分配、消耗的全过程监控； 实现对主要能耗工艺节点、能耗设备重点管控，提高能源利用率； 实现能源平衡及分析，提供从能源管理、能源分析到能源优化的一体化节能技术解决方案。\n主要功能需求包括：     序号 业务需求 功能需求     1 能源监控 构建出水、电、汽、风、燃气全厂能流总貌图，跟踪介质实时负荷变化； 构建主要工序的能耗监控图，监控其能源介质的发生量和消耗量，对重点能耗监控点进行限位报警； 统计各车间历史用能情况曲线，对重点能耗监控点进行报警，并产生能耗台账。   2 能源计划管理 根据生产运行数据、设备检修计划、同期历史消耗能源等数据，制定月度、季度的水、电、汽、风、燃气供需计划,并实现能源跟踪。   3 能源平衡 实现水、电、汽、风的厂级、车间级和关键工序的能源平衡；分析主要耗能设备的消耗情况，分析耗能漏洞。   4 能源分析及统计 运用先进的数据分析技术，提供多维度能源分析和报表工具，实现按工段、区域、时段、设备、用能类型等生成各种组合统计报表； 实现单耗计算和分析； 支持多种图表展现手段，如饼状图、柱状图、投影图等； 采用直观的图表方式进行能源实绩与能源计划的对比分析。    (四) 方案设计 能源消耗是企业生产成本中重要的可控部分，降低能源消耗是企业降低生产成本的重要途径。随着社会的不断进步和科学技术的不断发展，节能技术和装备已广泛应用于企业生产工序的各个环节。能源管理系统能够实现对各种能源介质（风、水、电、汽、燃气等）和各类供能用能系统（供配电、供水系统、供气系统等）进行集中监控、统一调度。如果在企业中建立能源监管体系，通过计算机等辅助手段将能耗分类计量，就可发现高能耗点和不必要的能耗消耗量，更能确保能源调度的科学性、及时性和合理性，从而提高能源利用水平，实现提高整体能源利用效率的目的。可以帮助工业生产企业在扩大生产的同时，合理计划和利用能源，降低单位产品能源消耗，提高经济效益。\n通过能源计划，能源监控，能源统计分析，能源对标管理等多种手段，使企业管理者对企业的能源成本比重，发展趋势有准确的掌握，并将企业的能源消费计划任务分解到各个生产部门车间，使节能工作责任明确，促进企业健康稳定发展。\n能源管理系统采用分层分布式系统体系结构，对电力、燃气、水等各分类能耗数据进行采集、处理，并分析能耗状况，实现节能应用等。\n1.能源数据采集 生产数据集成系统主要采集以下几方面数据：\n 从现场控制系统以在线方式采集获取的能源、生产数据，并为MES系统提供其所需的实时数据。在线采集数据主要包括：（在设计阶段根据实际情况进行增减）\n* 电力系统开关状态、电度量、电压、电流、有功功率、无功功率、功率因数等；\n* 天然气、蒸汽、氧气、压缩空气等的流量、压力、温度等；\n* 给水泵站送出流量、压力、循环水补水的流量等；\n* 燃气流量、压力等；\n* 重点能源设备的运行参数；\n* 主体工艺设备相关数据，如生产工艺的重点设备参数变化、生产状态、主要工艺指标、主要设备耗能数据等；\n* 公司一级、二级的计量设备和部分三级的重要用能设备，如干燥炉、焙烧炉、挥发炉、多膛炉、电解槽、空压机、空气风机、二氧化硫风机等的能源计量数据采集。  通过离线方式输入能源管理系统的数据，如定额、价格、资源量、生产数据等； 从其它信息系统(LIMS、ERP系统)获得的信息，如生产计划、产量实绩等。（系统也提供人工录入方式）。    2.能源实时监控 能源管理的综合监控实现在安全、可靠前提下对生产安全、能源动力装置进行监视和控制，达到如下目标：\n以最小数据采集量实现对现场设备及系统的全方位的监视和控制。为确保实现这一目标，必须评估相关现场站点的仪表是否满足、确认已有现场控制系统的安全和技术措施是否适合满足远程控制的要求、核实仪表计量是否满足能源管理的要求等；\n采用主流、成熟、品牌知名度高的独立软件厂商的监控平台软件，确保对现场装置（PLC/RTU等）直接驱动采集的技术可行性，从而保证系统的整体性能；\n能源监控平台主要是对水、电、风、气、燃气等各种能源监管，达到客户实时了解各种能源的使用情况、各种终端的运行情况。根据月、季度和年度的同比和环比功能，给出各种能源的改进建议。改造实施以后，分析改造前、改造中和改造后的能耗情况对比，总结改造以后节能的成果。另外通过能耗公示功能，让各部门具有节能意识。能源监控管理系统通过一系列的功能措施，展现能源的实时消耗情况，并通过能耗分析，让用户直观的了解企业能耗情况，并使用分析手段分析当前能耗，使用户达到节能减排的效果。\n3.能源平衡 能源平衡模型以企业生产消耗的能源介质为基点，构建相应的能源管网，在能源管网内根据各用能和产能单位的消耗或生产节点的分布，构建能源节点，实现按节点的数据采集，按管网的生产/消耗平衡，按用能单位的能耗结算。\n主要功能包括：实时的能源平衡和结算的平衡计算，主要设备的耗能情况统计与耗能漏洞分析。\n企业能源平衡通常是指在某一特定的地区或系统内在一定时期的能源投人与产出之间的平衡。按照能源平衡范围大小可分为国家能源平衡、地区能源平衡、部门能源平衡、企业能源平衡、工序能源平衡和设备能源平衡等;\n能源平衡问题涉及到各种能源的开发、加工、转换、输送、分配、储存和利用等能源系统各环节的技术、经济和管理问题，因此影响能源平衡的因素是复杂的。一般地说，影响能源平衡的主要因素是:国民经济发展水平及其结构;能源系统效率;能源资源条件及其利用程度;能源的进出口以及其他社会因素等。\n能源平衡表的作用有：\n 全面反映各种能源的生产、消费、分配与进出口的平衡关系，了解各种能源的自给程度和对经济发展与提高人民生活的保证程度，为编制能源规划提供依据； 考察能源系统加工转换过程，投入与产出的数量平衡关系，为分析能源加工转换效率提供基础数据； 反映能源消费结构；如一次能源与二次能源消费结构；分部门和分地区的能源消费结构：各种能源分部门分行业的消费结构；用作燃料同用作原材料的比例等，为研究改善能源流向、产业结构、行业结构和产品结构提供依据； 反映能源与经济发展的关系，分析节能潜力，为进一步开展节能工作和进行能源供需预测提供基础数据。  企业能源平衡表是以一个企业或公司为平衡范围，根据企业对能源管理的需要和本企业的实际情况，在产品生产、销售与库存，能源收、支与库存，能源消耗、能源加工转换，能源计量器具运行等一系列报表的基础上编制的综合平衡表，它反映了企业各种能源的来踪去迹以及各种能源的消费构成、加工转换的投入和产出，体现出企业能量的平衡关系。\n各个企业的具体情况不同，企业能源平衡表的形式也不可能完全一样，但都应根据能量流动过程进行编制。这样，一般企业能源平衡表可根据能量流动过程划分为能源购入贮存、加工转换、输送分配和最终使用四个环节，以下是其系统简图，每一个环节中可分为若干用能单元。\n具体功能实现主要就是生成能源平衡表和能源消耗分析。能源平衡表通过能源计量采集过来的数据通过报表生成相应的能源平衡表。\n4.能源统计分析 按照数据采集、计算、监控、统计、分析的方向完成功能设计，满足企业对统计分析的需求，降低企业因数据的统计、表单维护以及报表、数据处理而产生的时间成本。为企业制定节能措施和进行技术改进提供依据，为企业达到节能减排、资源优化和提高企业竞争力服务。\n  主要成本项分为物料、设备、人工、能源四项；\n  以装置或设备为监测对象；\n  统计则对在一定周期内进行消耗统计和数据归档；\n  分析则以对象为核心，进行耗量核算，进而分析用能效率；\n主要包括：系统配置、计量网络配置、计量分析。\n  系统配置:\n系统配置主要功能包括：参数模板配置。参数模板配置是把各类计量仪表进行分类，并对计量仪表提供模板支持功能，在参数模板配置中，可以对不同仪表模板的子对象位号、报警、归档进行统一配置。\n  计量网络配置\n计量网络配置是通过对企业现场计量仪表进行统一配置，建立仪表间层级关系。\n  计量分析\n计量分析为企业用户通过计量网络角度去提供数据查询、数据分析、极差分析等功能，并支持对现场仪表进行抄表记录查询。\n为一组状态和行为相似的对象定义的属性和方法称之为模板，可以认为一个型号的仪表公用一个模板。计量模板内容获取来源于现场IO点表，实施人员将IO点表依据设备类型、种类归纳成不同模板。\n  针对分配给各车间（装置）的生产任务，利用数据分析技术，对历史数据进行分析，并根据生产与设备运行计划，进行能源供需、能耗实绩与计划的比较，用以指导能源管理工作，提高能源管理水平和能源管理效率。主要的分析方法包括能源指标分析、能源供需计划分析、能源供需实绩分析、峰谷电分析、设备能效分析、参数回归分析等。具体包括如下几方面内容：\n （1）运用先进的数据分析技术，提供多维度能源分析和报表工具，实现按工段、区域、时段、设备、用能类型等生成各种组合统计报表； （2）实现单耗计算和分析； （3）支持多种图表展现手段，如饼状图、柱状图、投影图等； （4）采用直观的图表方式进行能源实绩与能源计划的对比分析。  5.能源计划 能源计划管理主要功能是根据公司生产计划、检修计划、能源消耗历史值和实际供能状况编制能源年季月供需计划，指导企业按照需求进行能源购进及售出并指导能源系统按照供需计划组织生产，向主生产线提供所需的能源介质。\n6.能源实绩 主要对各种能源介质实际生产量、使用量、放散量等数据进行采集、抽取和整理，取得能源生产运行的实绩数据，实现日能源实绩报表、月能源实绩报表等。能源管理部门编制的能源供需实绩报表为唯一能源消耗数据来源，所有部门均以此数据为基准编制各类其他报表。\n具体功能：计量点录入、产品日产量查询、产品月产量查询、能源日实绩查询、能源月实绩查询、能源年实绩查询、实绩原始报表、数据状态报警、数据修改跟踪、画面监控、报警；\n7.指标体系 针对能源采购、能源存储、能源转换、能源使用4个环节，建立科学的能源计量指标体系，分别从公司、分厂、车间（装置）、单体设备等4个层面建立对应的企业能耗指标体系（源头指标、关联指标、末端指标）和能耗计算模型，准确计算各项能耗指标（实际量、折合量），为能耗计量、能效分析以及节能决策提供准确有效的基础。根据计量体系的要求，针对目前企业内还不具备计量仪表的测点，能源管理系统提供手动录入的方式。\n  1.分析体系\n1)对标分析\n内部对标：以企业同期历史数据为基准，开展能效指标纵向对比，分析企业在能流、物流方面的变化趋势，并指出企业与历史同期对比在能流、物流方面的节能潜力。\n外部对标：构建标杆企业能流、物流指标体系及海力化工的能流、物流指标体系，以标杆企业为标准，通过对能流指标、物流指标的对标分析，查找出在能流、物流方面的节能潜力。\n2)能效分析\n根据对企业历史数据的分析及对比，查找对能效产生重要影响的关键因素，如工序能效、折合比情况，分析关键能效因子对企业综合能效的影响，为企业节能改造计划提供准确的参考依据。\n绘制主工序及整个企业的物流图、能流图，给出关键节能环节。\n关键节能环节覆盖能源采购、能源存储、能源运输、能源转换、能源使用等五方面，以设备、工序/车间、分厂、公司等多个角度进行能耗分析。\n  2.计量系统的设计\n为了提高能源系统的管理水平，达到精细化管理的要求，需要配备信息化、智能化的能源计量仪表，设计原则如下：\n 为设备安装具备上传信号能力的信息化仪表(最好支持tcp/ip通讯协议)； 为设备安装具备数据定制化传输能力的智能化操作单元； 在设备数据支持无线传输的基础上增加有线传输方式进行数据采集； 对机械式仪表进行改造，改为能上传信号的仪表； 考虑采取必要的措施隔离现有计量网络与现场各单元网络；    以上改造的具体方案及数量由中国恩菲工程技术有限公司和投标方在设计阶段确定。\n对于暂不满足数据采集条件的检测点，能源管理系统仍提供受权限控制的手工录入方式实现数据的采集，并对手工录入的数据进行日志管理，记录数据录入的时间、人员、修改值。\n","description":"","id":0,"section":"sf","tags":null,"title":"能源管理","uri":"http://austinzgx.github.io/sf/ems/"},{"content":"现状分析 近年来，全球各主要经济体都在大力推进制造业的复兴。在工业4.0、工业互联网、物联网、云计算等热潮下，全球众多优秀制造企业都开展了智能工厂建设实践。例如，西门子安贝格电子工厂实现了多品种工控机的混线生产；FANUC公司实现了机器人和伺服电机生产过程的高度自动化和智能化，并利用自动化立体仓库在车间内的各个智能制造单元之间传递物料，实现了最高720小时无人值守；施耐德电气实现了电气开关制造和包装过程的全自动化；美国哈雷戴维森公司广泛利用以加工中心和机器人构成的智能制造单元，实现大批量定制；三菱电机名古屋制作所采用人机结合的新型机器人装配产线，实现从自动化到智能化的转变，显著提高了单位生产面积的产量；全球重卡巨头MAN公司搭建了完备的厂内物流体系，利用AGV装载进行装配的部件和整车，便于灵活调整装配线，并建立了物料超市，取得明显成效。\n当前，我国制造企业面临着巨大的转型压力。一方面，劳动力成本迅速攀升、产能过剩、竞争激烈、客户个性化需求日益增长等因素，迫使制造企业从低成本竞争策略转向建立差异化竞争优势。在工厂层面，制造企业面临着招工难，以及缺乏专业技师的巨大压力，必须实现减员增效，迫切需要推进智能工厂建设。另一方面，物联网、协作机器人、增材制造、预测性维护、机器视觉等新兴技术迅速兴起，为制造企业推进智能工厂建设提供了良好的技术支撑。再加上国家和地方政府的大力扶持，使各行业越来越多的大中型企业开启了智能工厂建设的征程。\n我国汽车、家电、轨道交通、食品饮料、制药、装备制造、家居等行业的企业对生产和装配线进行自动化、智能化改造，以及建立全新的智能工厂的需求十分旺盛，涌现出海尔、美的、东莞劲胜、尚品宅配等智能工厂建设的样板。例如，海尔佛山滚筒洗衣机工厂可以实现按订单配置、生产和装配，采用高柔性的自动无人生产线，广泛应用精密装配机器人，采用MES系统全程订单执行管理系统，通过RFID进行全程追溯，实现了机机互联、机物互联和人机互联；尚品宅配实现了从款式设计到构造尺寸的全方位个性定制，建立了高度智能化的生产加工控制系统，能够满足消费者个性化定制所产生的特殊尺寸与构造板材的切削加工需求；东莞劲胜全面采用国产加工中心、国产数控系统和国产工业软件，实现了设备数据的自动采集和车间联网，建立了工厂的数字映射模型（Digital Twin），构建了手机壳加工的智能工厂。\n但是，我国制造企业在推进智能工厂建设方面，还存在诸多问题与误区：\n 盲目购买自动化设备和自动化产线。很多制造企业仍然认为推进智能工厂就是自动化和机器人化，盲目追求“黑灯工厂”，推进单工位的机器人改造，推行机器换人，上马只能加工或装配单一产品的刚性自动化生产线。只注重购买高端数控设备，但却没有配备相应的软件系统。 尚未实现设备数据的自动采集和车间联网。企业在购买设备时没有要求开放数据接口，大部分设备还不能自动采集数据，没有实现车间联网。目前，各大自动化厂商都有自己的工业总线和通信协议，OPC UA标准的应用还不普及。 工厂运营层还是黑箱。在工厂运营方面还缺乏信息系统支撑，车间仍然是一个黑箱，生产过程还难以实现全程追溯，与生产管理息息相关的制造BOM数据、工时数据也不准确。 设备绩效不高。生产设备没有得到充分利用，设备的健康状态未进行有效管理，常常由于设备故障造成非计划性停机，影响生产。 依然存在大量信息化孤岛和自动化孤岛。智能工厂建设涉及到智能装备、自动化控制、传感器、工业软件等领域的供应商，集成难度很大。很多企业不仅存在诸多信息孤岛，也存在很多自动化孤岛，自动化生产线没有进行统一规划，生产线之间还需要中转库转运。  究其原因，是智能制造和智能工厂涵盖领域很多，系统极其复杂，企业还缺乏深刻理解。在这种状况下，制造企业不能贸然推进，搞“大跃进”，以免造成企业的投资打水漂。应当依托有实战经验的咨询服务机构，结合企业内部的IT、自动化和精益团队，高层积极参与，根据企业的产品和生产工艺，做好需求分析和整体规划，在此基础上稳妥推进，才能取得实效。\n智能工厂概念初探 究竟何谓智能工厂？智能工厂具有以下六个显著特征：\n   设备互联。能够实现设备与设备互联（M2M），通过与设备控制系统集成，以及外接传感器等方式，由SCADA（数据采集与监控系统）实时采集设备的状态，生产完工的信息、质量信息，并通过应用RFID（无线射频技术）、条码（一维和二维）等技术，实现生产过程的可追溯。    广泛应用工业软件。广泛应用MES（制造执行系统）、APS（先进生产排程）、能源管理、质量管理等工业软件，实现生产现场的可视化和透明化。在新建工厂时，可以通过数字化工厂仿真软件，进行设备和产线布局、工厂物流、人机工程等仿真，确保工厂结构合理。在推进数字化转型的过程中，必须确保工厂的数据安全和设备和自动化系统安全。在通过专业检测设备检出次品时，不仅要能够自动与合格品分流，而且能够通过SPC（统计过程控制）等软件，分析出现质量问题的原因。    充分结合精益生产理念。充分体现工业工程和精益生产的理念，能够实现按订单驱动，拉动式生产，尽量减少在制品库存，消除浪费。推进智能工厂建设要充分结合企业产品和工艺特点。在研发阶段也需要大力推进标准化、模块化和系列化，奠定推进精益生产的基础。    实现柔性自动化。结合企业的产品和生产特点，持续提升生产、检测和工厂物流的自动化程度。产品品种少、生产批量大的企业可以实现高度自动化，乃至建立黑灯工厂；小批量、多品种的企业则应当注重少人化、人机结合，不要盲目推进自动化，应当特别注重建立智能制造单元。工厂的自动化生产线和装配线应当适当考虑冗余，避免由于关键设备故障而停线；同时，应当充分考虑如何快速换模，能够适应多品种的混线生产。物流自动化对于实现智能工厂至关重要，企业可以通过AGV、行架式机械手、悬挂式输送链等物流设备实现工序之间的物料传递，并配置物料超市，尽量将物料配送到线边。质量检测的自动化也非常重要，机器视觉在智能工厂的应用将会越来越广泛。此外，还需要仔细考虑如何使用助力设备，减轻工人劳动强度。    注重环境友好，实现绿色制造。能够及时采集设备和产线的能源消耗，实现能源高效利用。在危险和存在污染的环节，优先用机器人替代人工，能够实现废料的回收和再利用。    可以实现实时洞察。从生产排产指令的下达到完工信息的反馈，实现闭环。通过建立生产指挥系统，实时洞察工厂的生产、质量、能耗和设备状态信息，避免非计划性停机。通过建立工厂的Digital Twin（数字映射），方便地洞察生产现场的状态，辅助各级管理人员做出正确决策。    仅有自动化生产线和工业机器人的工厂，还不能称为智能工厂。智能工厂不仅生产过程应实现自动化、透明化、可视化、精益化，而且，在产品检测、质量检验和分析、生产物流等环节也应当与生产过程实现闭环集成。一个工厂的多个车间之间也要实现信息共享、准时配送和协同作业。智能工厂的建设充分融合了信息技术、先进制造技术、自动化技术、通信技术和人工智能技术。每个企业在建设智能工厂时，都应该考虑如何能够有效融合这五大领域的新兴技术，与企业的产品特点和制造工艺紧密结合，确定自身的智能工厂推进方案。\n冶金行业调研分析 历时2个多月，对首钢京唐集团、安阳钢铁集团、江铜集团贵溪冶炼厂等生产企业进行实地考察，并与首钢技术研究院、清华大学工业4.0研究所等科研单位进行会议交流。重点了解了与冶金行业相关的智能化研究与应用的现状与成果。就目前来看，没有完全实现冶炼智能工厂，均在围绕冶炼生产核心进行开发和研究应用，在局部生产流程实现了智能冶炼。\n首钢京唐联合首钢自动化公司自主开发应用了“一键式”炼钢技术是一种先进的转炉冶炼控制技术，该技术集理论计算、专家经验和先进的在线监测手段与一体，采用计算机L1模型和PLC/DCS控制转炉吹炼操作，可显著提高转炉终点碳、温度双命中率，缩短冶炼周期，提高生产效率，降低原材料消耗和生产成本，实现可观的经济效益。其他较大规模的钢铁企业基本上都配置有“一键式”炼钢系统。可理解为在炼钢工序实现了智能化冶炼，均没有实现智能工厂，没有与上层MES及ERP层系统产生交互。但各大企业均已意识到未来智能工厂的方向和价值，正在组织力量进行攻关。\n查阅文献资料目前有色行业开发并应用的案列有：\n   西安交通大学万维汉等利用自适应模糊神经网络的方法建立了闪速炉模型，以较为准确地反应闪速炉的运行过程。      汪金良、曾青云应用神经网络技术，并依据工业实践操作数据，建立了铜闪速熔炼过程的温度模型。其文献在分析铜闪速熔炼控制策略和贵溪冶炼厂闪速炼铜生产实践数据的基础上，基于神经网络技术分别建立了冰铜品位模型、冰铜温度模型和渣中铁趕比模型，并采用了遗传算法GA与前向神经网络算法BP相结合的网络训练方法对其进行了仿真计算。将GA算法与BP算法有机地结合，形成了遗传BP算法，建立了冰铜品位神经网络模型。    中南大学王吉林建立了铜闪速熔炼过程三大参数的神经网络软测量模型。    Outotec公司闪速熔炼技术有专门和工艺控制配套的在线控制系统以及用于炉体安全保障的“哨兵系统”，对稳定生产、提高作业率和设备安全性等方面都有显著效果；    澳大利亚Ausmelt公司（现并入Outotec公司）的浸没顶吹熔池熔炼技术也有专门的“工艺控制系统”（Prcoess Control System）用以顶吹炉的工艺智能控制；    日本三菱公司也采用过“连续炼铜技术专家辅助系统”对连续炼铜技术技术的4个冶金炉进行优化和智能控制。    贵溪冶炼厂闪速炉生产优化控制系统作为国内首套引用日本东予模型的专家系统，并联合太极集团经过多年的开发与应用，已成为现场操作人员所依赖的系统，大幅度提高了冶炼稳定性，从而为贵溪带来可观的经济效益。同时，贵溪冶炼厂作为江铜集团二级生产单位，ERP及OA系统均接入集团。目前贵溪冶炼厂正在联合用友软件、太极集团开发核心关键MES层相关系统（如能源管控系统、生产实时监视系统、设备管理系统等），致力于打造铜冶炼智能工厂，已作为工信部立项示范基地。    有色冶炼生产自动化控制现状 目前，大部分有色企业生产自动化控制系统均使用集散控制系统（DCS），该系统仪表、电动设备监控一体化。电动设备运行状态显示、过程控制相关的工艺参数显示及电动设备启停控制等都在系统的操作站上集中完成。 DCS特点：\n 控制功能分散，从而危险分散，提高了系统的可靠性。 系统构成采用模块化结构，易于扩充，提高了使用的灵活性。 高速数据通讯网络的使用，使整个系统信息共享，提高了信息的流通性。 控制功能齐全控制算法丰富，新型控制规律的引用，提高了系统的可靠性。 方便的人机对话，丰富的显示画面。 系统功能性强,可方便地通过组态实现各种不同的控制方案。 具有图形显示，历史趋势曲线显示功能，报警功能等。 具有事故报警，手操单元后备措施，冗余化措施，提高了系统的安全性。 具有完善的软硬件自诊断措施，故障的自动检测技术。 信息集中管理，提高了控制管理的综合能力和管理水平。  采用DCS控制系统可以实现生产操作的自动化，而有色冶炼通常是高温、多相、多组分的连续反应过程，由于冶炼过程内在工艺的复杂性，对于实际工艺过程的控制和决策常常需要依靠个人经验,操作流程大致如下：\n 凭借经验或公式简单估算出工艺控制的理论操作参数 进入DCS系统，打开组态控制体输入框，手动输入工艺控制参数 DCS接受新的操作参数，下发给仪表执行机构的终端,完成实体操作  这种单纯依靠DCS系统进行工艺过程控制方式解决了“手”的问题，没有能够解决“脑”的问题，面对智能冶炼生产操作而言其存在的主要问题有：\n 粗放调整，生产波动大\n由于采用经验或估算的方式，理论操作参数的计算误差大，导致输入DCS系统的工艺控制值与实际需要值偏差大，不仅引起本工序较大的生产波动，而且对后续工序的波动造成持续性影响。 生产控制反应滞后\n由于冶炼生产过程需要处理各种成分不同的原料，同时关键目标控制参数也是会经常出现偏离，为了匹配原料的变化和修正偏离的目标参数，工艺控制参数需要及时调整，而依靠人工进行调整往往无法准确及时匹配工况的变化，生产控制经常滞后。 受限于人的经验和操作\n由于工艺控制参数的决策和输入都需要人为设置，受限于个人经验水平的高低和人为操作的误差，给冶炼生产过程的控制带来不可控因素。 连续操作，多炉协同困难\n例如对于连续炼铜工艺，势必对工艺控制系统瞬时性和连续性提出更高的要求。如吹炼炉连续地处理从侧吹炉排放的热态铜锍，但热态铜锍流量无法计量，因此无法确定需要供给吹炼炉的氧气量、熔剂量等重要工艺控制参数。  综上所述，单纯依靠DCS控制系统组织生产操作，在控制的准确性、稳定性、及时性都不能达到现代智能化的水平，给企业可能带来风险和经济损失。同时系统不具备生产预测、自我调节的功能。\n    　有色国内领先水平(贵溪) 有色国内普遍水平 钢铁水平(首钢京唐）     生产规模 103万t/a阴极铜 20万t/a阴极铜 1500万t/a钢材   来料复杂度 较稳定，具有精矿入炉调度系统 波动大，成分多变 稳定，大批次进料，具有调度系统   生产工艺特点 半流程半离散 半流程半离散 离散   一次仪表水平 核心进口，部分国产 基本国产 大部分进口   设备控制层 DCS/PLC DCS/PLC + 手动 DCS/PLC   过程控制层 日本东予模型基础上，联合太极集团自主开发优化控制系统，在两套闪速熔炼系统上均在线使用，其他工序均无 除太极推广的闪速炉控制系统(山东阳谷、中原黄金）和中国恩菲开发烟台国润（侧吹+顶吹）优化控制系统外均无使用 二级控制系统在转炉炼钢上应用，实现“一键式”炼钢，作业周期短，40-60分钟/炉次。高炉及其他生产均无   MES层 目前只实现数据采集及信息化展示，没有实现控制管理功能，正在联合开发示范工程 基本没有 个别企业应用，能源管理系统、生产信息监视系统、设备管理系统，但没有系统建设，均为独立开发应用   ERP层 江铜集团集中建设ERP及办公OA，部署在南昌总部，二级单位均已接入。缺少中间MES层支持，没有发挥作用。 基本没有 较大规模钢铁厂应用，但限于办公OA。目前了解只有鞍钢集团开发应用了ERP系统。    先进过程控制系统  系统简述\n中国恩菲先进过程控制系统(ENFI Advanced Process Control，简称EAPC)是一套部署生产企业生产DCS系统之上，用于稳定生产操作、优化工艺控制条件的智能化平台，该系统基于冶炼工艺的基本原理，依靠内置强大的冶金热力学数据库，将冶炼企业的生产工艺控制过程进行数学建模，并采用先进的在线控制算法，无需人工干预即可在不同的工况条件下自动计算出需要控制的主要工艺操作参数，自适应消除系统偏差，从而为冶炼生产作业的稳定连续作业和进一步的工艺优化提供重要技术保障。 其主要目标和作用有：   彻底解决原料成分和工况条件等波动引起的生产不稳定问题，为冶炼生产作业的稳定、安全运营提供重要技术保障。 大幅减少人为因素对冶炼生产过程产生的影响。系统自动获取数据，冶金模型计算数据可自动下发DCS执行，减少操作人员非正常操作引起的生产影响。 实现冶炼生产过程的智能、快速和最优的生产调整。联立生产系统中采集的各类数据，在对冶炼的生产过程进行实时监测的同时，采用智能反馈控制算法动态运算调整修正量。 为冶炼生产的进一步工艺优化创造条件。通过数据库查询分析模块，对生产大数据进行挖掘分析，为生产企业不断地对工艺优化创造具体条件。   功能介绍\n数据通讯    与DCS系统通讯:\n采用OPC等多种通讯协议，实时采集DCS系统数据，并将EAPC系统下发执行的数据写入DCS系统中。\n  与化验中心通讯:\n采用TCP\\IP通讯协议，单独开发化验中心数据通讯终端，将化验分析中心的数据传送至EAPC系统中。\n  与MES系统通讯:\n系统开放访问数据库接口，上层MES系统可访问该系统数据库存储管理的所有实时和历史数据。\n  配料策略\n  原料配料策略:\n冶炼厂的原料来源复杂多变，系统依据生产目标，采用寻优计算后提供满足生产技术要求的原料配料方案。\n  杂质控制策略:\n基于生产经验及冶金工艺要求，对于原料中的某些有害杂质建立杂质控制策略，避免杂质含量过高对生产系统造成不利。\n  生产辅料策略:\n通过工艺数模系统实时计算出辅料（如熔剂、煤）的配料参数，自动通过DCS系统下发辅料料仓量，准确及时地进行生产调整。\n  生产操作控制\n依据冶炼企业的生产工艺控制过程进行数学建模，并采用先进的在线控制算法，无需人工干预即可在不同的工况条件下自动计算出冶炼生产控制的工艺操作参数。\n以铜熔炼为例，控制三大核心目标参数为：铜锍品位(Cu%) 铜熔炼渣Fe/SiO2 铜熔炼渣温\n以铅熔炼为例，控制五大核心目标参数为： 渣含铅(Pb%) 铅熔炼渣Fe/SiO2 铅熔炼渣CaO/SiO2 一次粗铅品位(Pb%) 铅熔炼渣温\n  工艺计算：\n根据所采集测点的数据（如配料仓中铜精矿量、渣精矿量及成分和其他辅料成分等等）,围绕三大核心目标参数，通过冶金工艺模型中进行实时元素平衡、热平衡及相平衡计算，从而得出 熔剂、煤等下料量、工艺氧量、工艺风量等操作参数，并将计算结果发送到DCS系统执行。根据投入物料量、工艺参数，计算出周期(t/h)产出冰铜量、氧料比等主要工艺指标参数。\n  反馈修正：\n对比化验分析数据与设定目标参数，计算出偏差量，下次调用计算时自动调整偏差量进行修正，相比人为手动调节反应敏捷快速，调整策略综合全面。同时，将仪表及设备的系统误差并入，大幅提高了参数准确性，\n  工况管理:\n建立工艺流程实体三维模型，并实现动态实时数据展示，实时监控系统中各流程的的运行情况， 当系统中某一进程异常时，系统可自动识别，并进行提示报警。如炉底温度超出经验设定值上限、给料机下料量的瞬时值与设定值偏差超出设置范围，对应炉体、定量给料机将闪烁报警。\n  生产实时监控\n(Realtime Produce and Supervisory Control System，简称RPC)，主要实现将企业各生产单元的DCS控制系统等实时集中监控， 并且制作报表以及对实时数据进行应用分析。包括数据采集接口、实时数据库服务器（PI、IP21等）、实时数据发布以及制作报表等。 RPC实现底层生产过程实时信息的采集，通过信息集成形成优化控制、优化调度和优化决策等的判断或指令。 使生产过程数据和企业管理数据的在实时数据平台中融合与贯通。\n 数据查询与分析   系统服务器端采用MySql数据库存储并维护所采集的化验数据、DCS数据及EAPC系统计算数据，用户可根据需要查看任意时段的历史数据。 系统提供丰富的数据查询功能，用户可以很快捷方便地完成生产考核、生产报表生成等日常管理任务。 系统提供强大的数学分析工具，用户可以自由选择研究内容在线进行数据分析，挖掘数据之间的隐形关系，反哺生产参数的优化。  线下生产预演   离线状态下，系统可作为虚拟生产线，进行生产预演。验证工艺参数可行性，准备生产辅料等。 离线状态下，系统可模拟工艺实景，作为企业工艺人员培训及业务考核系统。  发展方向 在过去三年中,关于工业4.0的定义和对世界各国战略的解读已有很多,也有许多专家学者和政府机构提出了一系列的实施路径和方案,我们看到政府相继提出了机器换人、智慧工厂、大数据、互联网+和工匠精神等一系列改革举措。然而,有 不少人都表达过这样一种感受:我们越深入分析各个国家的政 策,越是去尝试不同的转型路径,反而愈发地感觉迷茫和浮躁。 我认为之所以会有这样的感受,是因为大家把智能制造当成了 个技术问题来看待,因此在分析其他国家行动的时候也只是 停留在表面的方法和技术上,却忽略了这些行动背后的思维和 逻辑。于是当德国有“工业4.0″,我们就有了“中国制造2025”; 美国提出“工业互联网”,我们也提出了“互联网+”;日本精益 制造做得好,我们就要大力提倡工匠精神。事实上,智能制造并 不仅仅是一个技术体系或文化,更重要的是背后对智慧的理解、解决问题的逻辑和重新定义制造的思维。\n研发课题 先进感知 针对有色冶炼企业生产中部分参数信息难以获取或数据不精准等问题，采用新型检测技术，融合高温热管、图像识别、声音识别等关键技术，提升设备数据、产品标识数据、工厂环境数据等生产现场数据采集能力，实时感知生产过程和关键装备运行数据和状态，实现对生产工况和设备运行的实时监控，为数据采集、故障检测与分析以及自动控制奠定基础。如溶液成分在线分析、管道结疤厚度判断、炉体熔池高度检测、炉窑热场比色识别、电解槽短路识别、阴阳极电流在线检测等。\n智能装备 针对有色冶炼企业生产中部分劳动作业强度大、作业环境恶劣（高温、多粉尘、强腐蚀等）、人员安全风险大等问题，鼓励企业应用具有通讯接口，具备自我检测、自我诊断、自我调节、互联互通等功能的智能装备（包括工业机器人），降低人员劳动强度，提高生产安全性、质量稳定性和生产效率。实现最大程度地机械化替人、自动化减人，提高生产作业效率，降低作业风险。如智能天车、数字电解槽、自动开堵口机、自动换枪装置、转炉自动捅风眼机、极板自动转运仓储、自动剥板机等。\n先进过程控制 先进过程控制系统(Advanced Process Control，简称APC)基于冶炼工艺的基本原理，依靠冶金热力学数据库，将实时采集的生产数据作为模型的输入条件及反馈修正的依据。通过冶炼企业的生产工艺控制过程的数学建模，采用先进的在线控制算法，无需人工干预即可在不 同的工况条件下自动实时计算，将不断自修正的模型计算输出，由自动化控制系统执行生产操作指令。实现生产操作调整的有理有据，按需敏捷，为冶炼生产作业的稳定连续作业和工艺优化提供重要技术保障，成为集约化生产的重要手段。\n管控一体化平台 基于先进装备、智能感知的硬件采用，智能设备、工业物联网、大数据分析、移动应用等新一代IT技术的集成应用，逐步完成办公自动化、经营管理信息化、生产制造过程信息化、工艺优化控制、大数据分析与应用、智能辅助决策等各类企业业务场景需求的建设，实现生产过程的精细化管理，工艺控制的可持续改进以及生产经营的智能化辅助决策，使得企业的生产运营达到了以数字资源驱动的人机协同优化运行，提高企业运营效率和产品质量，实现以人为本的运营。\n厂商分析 集成商   Honeywell\n  Emerson\n  赛迪\n  京诚\n  恩菲\n  瑞林\n  有色行业：瑞太、中铝视拓、北矿信息科技、江铜集团\n  钢铁行业：中冶赛迪、中冶京诚、宝信软件\n  技术公司：用友、金蝶、力控、浙大中控、和利时、艾默生、科远、AVEVA\n  互联网公司：华为、阿里、腾讯\n  软件商 IAAS\n天津超算中心、阿里云、腾讯云、华为云、浪潮、亚马逊AWS、微软Azure、紫光、中科曙光、戴尔、联想、新华三、深信服、东土科技、烽火通信、华云、罗克韦尔、EASY STACK、VMware、罗克韦尔、中国电信、金山、和力时、航天云网、Rackspace、Red Hat、百度、西门子、美卓、海康威视、瑞斯康达、大华、赫斯曼。\nPAAS\nSCADA软件和分析软件，AVEVA公司Ampla数据分析系统，PTC公司ThingWorx 数据平台管理系统，深度学习、机器学习等通用大数据分析的模型算法库，Metsim冶金计算软件，财务（金蝶、用友）、人力（白金、宏景），工业实时数据库、工业采集软件、三维可视化工具、权限管理、行情动态消息推送\n（1）国内外领先公司：\n互联网公司：华为、阿里、腾讯、百度、通用、西门子、微软、亚马逊、海尔、ABB、罗克韦尔、丹东测控、谷歌、航天云网、长沙迪迈、用友软件、宝信软件、施耐德、艾默生\n智能矿山公司：山特维克、北矿智云、\n智能工厂公司： AVEVA、奥图泰、瑞林、首钢速力、瑞太、中铝视拓、中铝智能、PTC、OSI、易控、浙江大学、德国马丁、芬兰科尼、重庆水务、北控水务、中冶赛迪、中冶京城、光大、深能源、科远、中节能、北排集团、首创水务、太极、中广核、江铜、龙软科技、广联达。\n（2）（潜在）竞争关系公司：北矿院、长沙迪迈、东方测控、华为、阿里、腾讯、通用、西门子、微软、亚马逊、ABB、罗克韦尔、美卓奥图泰、丹东测控、石化盈科、宝信软件、中冶赛迪、东方国信、瑞太、中铝智能、长沙有色院、首钢速力、东方测控、瑞泰科技、宝武集团、用友软件、航天云网、太极、中广核、中铝视拓。\n数据库  实时数据库  宝信软件 iHyperDB 紫金桥 RealHistorian   时序数据库  施耐德机会 个人认为有色行业智能化发展的未来两类公司可以有较大的市场，第一类是平台型公司，不关注垂直行业的，重点开发通用型技术。第二类是独角兽公司，做垂直行业的深根，重点开发杀手锏应用技术。基于施耐德的外企背景考虑，我们要做第二类，即有色行业独角兽应用的提供商。正在围绕生产和管理两条主线把企业运营真正落地，做到用户心坎里。施耐德及AVEVA也是具备这方面的一些技术沉淀和资源优势，以下几方面可以成为杀手锏应用：\n   为pi实时数据库为抓手，pi绝对在实时数据库这个智能化核心基础部分占有绝对的技术优势和行业口碑，进一步集成融合网络、数据中心等相关技术，打造有色行业的数据中心的整体解决方案与软硬件产品体系。    以aveva三维设计、可视化软件体系为抓手，联合设计院做数字化交付平台，同时从设计院获得项目信息与市场支持。    推广应用apc、能管等施耐德成熟度较高的专业软件，在行业场景里寻找落地实施点。    围绕生产核心工艺，研发应用冶金数模优化控制系统（也即我搞的apc，为了区别以后改为这个名字），正在疏通管理决策与生产执行。    有色行业的装备与仪器仪表存在大量提升空间，施耐德可以联合外单位结合项目来研发应用，带动施耐德硬件产品（变频器等）的应用，嵌入集成到整体装备当中。    企业运营管理中重点业务是物流、设备、能源、质计、安环五大方面。除能管外，施耐德需要投入人力和时间，在项目深化逐渐形成特色杀手锏应用。    分类分析   咨询\n  EMS\n  MOM\n  机理模型 + APC\n  数据中心\n  三维数字化\n  IAC行业宣讲稿 各位领导各位同事大家上午好，我汇报的题目是有色金属冶炼行业介绍及智能化思考。\n由于本人于今年1月14刚刚加入施耐德，大部分领导同事还不是很熟悉我。所以开始正式内容之前，做个简短自我介绍，我叫张官祥，从北科大毕业后就进入中国恩菲工作了10年，从事有色冶炼工程咨询设计，主导冶金数模在线优化控制系统开发和智能工厂的架构规划和项目管理，值得一提的事是本人作为执笔主编，全程参与了工信部《有色金属行业智能冶炼工厂建设指南》。\n好的，下面开始正式内容的汇报，分为两个方面内容第一是介绍一下有色冶金这个可能大家比较陌生的行业，其次就是分享一下目前智能制造的热潮中，结合施耐德的业务机会和技术能力，对有色行业如何智能化升级的一些个人思考。\n第一部分，行业介绍\n首先，有色金属的定义是指除黑色金属（铁、铬、锰）以外的所有64种金属。按照生产性质分为重金属、轻金属、贵金属及稀有金属。其中行业也包括了采矿、选矿、冶炼和加工。受时间因素和个人专业所限，本次汇报主要围绕冶炼展开。\n我国十种有色金属产量规模“十三五”期间，年均增长3.6%。这张表列出2019年的数据，十种有色金属产量达到了5842万吨，同比大部分金属产量都是增长。\n2020年全年的数据，我整理材料时候协会还没公布数据，所以列出了1-11月的汇总数据，可以看到11个月的产量达到了5632万吨，同期是4.58%的增长。同时可以发现更多的金属产量实在正增长。\n1月29日中国有色金属工业协会召开2020年有色工业运行情况新闻发布会，从中了解到：\n我国十种有色金属产量首次突破6000万吨大关，达到6168.0万吨，同比增长5.5%。\n国内现货市场铜、铝年均价格回升至高于上年价格水平。( 铜价格达到\u0026gt;6万/t)\n有色金属工业企业主要财务指标明显好于预期。营业收入58266.5亿元(5万八千多亿)，同比增长3.8%；利润总额1833.2亿元,同比增长19.2%。\n同时也预测了今年有色金属生产继续维持3%左右增长和较好的市场价格。\n这张表给出了中国有色金属集团的在世界的排名和比重，可以看到中国占了半壁江山，中国是名副其实的有色金属生产大国，但原料对外依存度很大，中国没有十分丰富的有色矿产资源，但除了稀土。可以看到其他入围的都是矿产资源集团，利润也是明显可观的多。\n国内有色金属企业慢慢也类似钢铁行业一样，趋于大集团化资本化。主要是三个集团和一些重点企业瓜分了整个有色行业。第一是五矿……\n下面按照铝、铜、铅、锌、镍五大类大宗金属类别，梳理了产量规模、市场价格、中国国内主要的有色金属生产企业、主要设计方。快速过一下，不一一念了，有感兴趣需要的同事，会后可以找我。\n看完了企业情况，来看一下这些金属主要的流程工艺是什么？又是满满一屏幕，也不细念了，可以看到每种金属里不同的方法都存在不同的流程，这还没算完，\n以火法炼铜来说，主要流程是熔炼、吹炼、火法精炼，但是可以看到这个每个主流程里又存在好多的工艺和炉窑。这和钢铁和水泥都有很大的不同。至少炼铁基本不变的是高炉。\n借此我们来看一下有色冶炼行业的特点，总体上来说它是典型流程制造行业，上下游两端在外，也就是采选与加工是分离的，利润在加工成本，关键是稳定连续生产。首先，通过上述的内容，很明显的一个特点是金属种类繁多，原料复杂多样……\n嗯，行业的基本情况就介绍完了，下面是杨总特意嘱咐要讲的行业小故事，可能大家也比较有兴致。建国后国家成立了冶金工业部，1983年。。。。。\n有色行业KA业务其中设计院是非常重量级的一环，下面从我的老东家恩菲的视角再梳理一遍。。。。\n这张表梳理了有色冶炼的四家设计研究院,竞争也是日趋残酷，……\n下面是第二部分，有色冶炼行业智能化发展的思考\n首先总结一下目前行业的智能化现状………，工信部原材料司司长讲话，我们有色行业是29个行业里信息化水平排倒数二的，倒数第一的是农业，但是对我们来说那就是提升空间大、业务机会多，大有可为！\n首先来说，企业生产管理组织层级太多，部门到分厂到工区到班组。管理部门事务性的工作太多，管理效率和效果都不佳。\n导致生产管理能力老旧低下，如这张片子展示的，存在很多不足之处，生产计划靠人工、生产实况靠问询、生产决策靠经验等等。\n最核心的生产控制的现状又怎么样呢？大家都知道APC这种先进控制在石化、水泥慢慢普遍应用了，但是有色行业基本都还是单纯的基础自动化，就是PLC/DCS。它的参数往往是靠人来输入。导致。。。。无法实现精细化生产控制。\n最后看一下信息化现状，纸质流程单为主，冗长繁琐低效，微信成了第一生产力工具，就单项解决某个问题上了很多离散小系统，形成了一堆的数据孤岛，少部分企业随着一股热潮上了一部分重型应用如ERP,无法贴合实际，无人维护，形成应用烟囱。导致了人力及沟通成本大、人为失误或主观造数、无法最大化数据价值。\n针对这样一个落后的现状，工信部组织相关单位，承接落实中国制造2025、两化融合到行业，将有色行业作为第一的指南编写行业。2020年4月，三部委联合发布正式稿。本人也是非常有幸参与了全过程，学习成长了很多。\n从国家层面来说，指南要与整体的两化融合、智能制造、新基建的战略意志相统一，其核心就是两件事，5G和工业互联网的应用。5G就是为工业场景而生，工业互联网指出的是新一代信息与工业系统全方位深度融合，是一种产业和应用生态。\n从企业层面来说，指南明确了建设目标和要点。\n实现设备、物料、能源等制造资源要素的数字化汇聚、网络化共享和平台化协同\n具备在工厂层面全要素数据可视化在线监控、实时自主联动平衡和优化的能力\n建成集全流程自动化产线、综合集成信息管控平台、实时协同优化的智能生产体系、精细化能效管控于一体的清洁环保、优质低耗、安全高效的有色金属智能冶炼工厂\n促进企业转型升级、高质量发展，提升企业的综合竞争力和可持续发展能力\n建设要点是四个方面。。。。。\n下面回顾还原一下指南编制组的编程思路，我们有色行业属于典型的流程制造行业，殷院士帮我总结了，生产工艺流程有序稳定、协同连续运行是流程制造业的追求方向。这是我们思考用户需求和我们产品方向的一个核心原则。同时，如前面的讲的，我们有色冶炼具备本身的行业特点。基于此，桂院士帮我们接地气的总结了我们智能化冶炼工程的三个关键词作为总体目标，绿色、安全、高效。对于我们指南中提出的三个关键内涵， 清洁环保、优质低耗以及安全高效。\n架构内容方面，从这个目标出发，我们先归为四类，装备+感知构成的设备层级，过程控制+生产管理和经营决策，。。。。由此基础上才可以谈及扁平组织以及管理变革。\n基于上述思路，指南提出了参考架构，从传统的架构多层级演化为云边端这种工业互联网架构，也是工信部多次多场合宣贯的，对比而言，。。。。。。\n这个应该是我的主要岗位职责哈，梳理清楚施耐德包括AVEVA\\PI的成熟产品在有色行业的应用场景落地，，由于我刚刚入职，对咱们的产品线还不是十分熟悉，就我现在的理解，我梳理了一下施耐德包括AVEVA的一些软件应用机会，可能会有一点偏差和遗漏。。。。，当然可以看到我们还可以就其他一些应用场景和功能需要未来合作或者重点研发的，这也是杨航总交给我的一个任务，我还在积极学习思考当中。也希望大家能够积极寻找一起交流沟通。\n下面对未来有色冶炼企业智能化的市场预估，注意这里还只是冶炼企业的。……\n其中就大冶新建阳新项目做个详细的案例的分享，我当时也是这个项目的项目副经理，项目已经完成了基本设计。\n我的汇报就是这些了，由于时间关系和准备不对，难免有疏漏和错误之处。请大家指正，有任何问题，欢迎会后交流，这是我的微信。\n最后再次感谢施耐德的信任，感谢各位领导同事给予的支持帮助，非常很荣幸加入了施耐德这个更大的平台。期待与大家共同学习与努力，在有色行业开创新数字化未来。谢谢！\n","description":"","id":1,"section":"sf","tags":null,"title":"有色行业数字化业务竞争分析","uri":"http://austinzgx.github.io/sf/analysis/"},{"content":" Name: 张官祥 Phone: +8618519299525 or +8613811772347 Email: austinzgx@hotmail.com or guanxiang.zhang@se.com Blog: austinzgx.github.io Company: 施耐德电气(中国)有限公司  ","description":"who am i","id":2,"section":"","tags":null,"title":"About","uri":"http://austinzgx.github.io/about/"},{"content":"终端市场——建筑、数据中心、工业和基础设施。\nEcoStruxure Power便成为一个面向未来、基于物联网的平台，助力中低电压电力系统的数字化，优化人员和资产安全，提高电力可靠性，改善运营与能源效率，并且两年内便可收获投资回报。\nEcoStruxure Power旨在为三个不同的细分市场创造价值：\n 单个小型建筑，例如餐馆 中型商业和工业建筑（多场所），例如小镇的公共建筑或有多家店址的快餐集团 大型建筑和重要设施，例如医院和数据中心\n这样的市场细分使施耐德电气能够根据客户需求调整其技术解决方案。  本地控制必须有可能实现自主工作，以期令操作人员可以接管运营过程。在物联网的边缘实施设备控制是必须的。\n分析和服务层不涉及硬件。我们知道客户使用各式硬件和系统。我们的应用程序、软件和分析能够与任何硬件、系统和控制完成协作。\n专家使用分析引擎，可使客户享受基于云端的服务。\n对电力行业而言，网络安全是普遍存在的全球性威胁。我们的系统在这三个层级上都实现了完全的网络安全。\n我们的客户对他们想要分别存储在云端和本地的数据极为敏感，并具有选择性。\n我们的系统也可向客户提供这两种选择。\n  互联的产品层级包括中低压智能配电系统、UPS、电能质量测量仪、问题缓解设备等。\n  在边缘控制层级，我们提供信息可视化功能，包括内部分析。\n  在分析和服务层级，我们组织的云端服务由专家组提供。\n  互联的产品常出现在3个细分市场。\n在边缘控制层以及分析和服务层，我们有专门对应3个细分市场提供的服务。\n记住，“Advisor”的命名用于分析和服务层级。边缘控制层级使用“Expert”和“Operation”。\nEcoStruxure Power 能够为单个小型建筑带来哪些益处？ EcoStruxure Facility Expert SB是施耐德电气为独立小型企业业主提供的互联解决方案，\n  可以减少重要设备出故障的风险，缩短反应时间\n  在任何时候，业主都可以即时远程访问关键数据，从而带来平和的心态和更快的问题解决方案。\n  业主还可以在不影响业务效率的情况下实施能效行动。\n  就投资回收期而言，还不到两年。例如，如果您不能为您的顾客提供服务，您就应当考虑冷藏室里损失的食物和收入损失。\n小企业主的需求与运营相关，并且他们几乎都要确保业务能正常运作 。\n效率是目前关注度最高的问题，其次是能耗成本。\n此外，由于资源有限，小型企业业主即使不在现场，也会特别注重并确保他们的设备运行良好。\n尤为关键的是，检查运行设备是否正常，并对即将发生的问题实时报警。\nEcoStruxure Power如何能够为多场所的中型商业及工业建筑物带来价值？ 中型建筑中能在现场的员工有限。EcoStruxure Power借助云平台向客户提供简易工具，使现场管理更易操作、更高效。\nEcoStruxure Power提高能源效率，简化数据跟踪，并降低能源成本。\n它还能帮助提高维护效率、增加维护自动化，从而实现更可靠的运营，并在断电时能快速作出正确反应。\n说到投资回收期，不妨来看个例子。像在法国，有一座小城市它坐落了45栋彼此不同的公共建筑。前期投资费用为9万欧元，每年的费用为2万欧元。由于提高了维护效率和能源效率，预计每年可节省十万欧元。这就使得投资在两年内便可回本 。\nEcoStruxure Power 能够为大型建筑和重要设施带来哪些益处？ 在大型及重要建筑物中，正常运行时间至关重要，EcoStruxure Power能够：\n提高电力可靠性\n确保人员安全\n并提供运营效率\n那么问题的症结何在？\n30%到40%的计划外服务中断时间与电能质量有关！\n无论是确保可靠电力以防停电（例如在医院），亦或是提高效率帮助降低运维成本，满足法律法规，分析电能、简化运维和全面监测建筑中的能耗是至关重要的。\n考虑到投资回报率，一个典型的例子是在捷克布拉格一家拥有500个床位的医院。升级并应用了EcoStruxure Power 后, 该医院通过自动执行合规履行文档，每年节省5万欧元。这也将年度维护成本和能源费用减少了近10%， 另外带来每年20万欧元的节省。盈亏总额：EcoStruxure Power 不到两年便可收回投资。\n完整生命周期中为客户和合作伙伴提供数字化、智能化支持。 在设计和建造阶段，我们拥有设计方、工程师、盘厂、系统集成商、OEM、承包商和电气专家。\n在经营和维护阶段，我们有设备经理、操作员、技术维修人员和总经理。\n对于CAPEX部分，智能化的设计可减少工程和集成成本以及交付周期，确保资本投资的最大化。\n施耐德电气向合作伙伴提供设计参考图（可从PRM下载得到），因而能在设计和工程阶段节约时间和金钱，节省多达 15%的资金投入。\n我们使用经过验证的有效被记录的架构，降低风险，确保设计面向未来。\n遵守标准和最佳实践，包括合乎网络安全 IEC 62 44 3 SL1标准。\n简化安装和调试过程，为客户提供高效工具，如EcoReach，以调试Smart Panel。\n这一切都是为了变得更迅速、更简单、更合规！\n对于OPEX部分，智能化的设计确保对电力负载有更深的了解，以提高运营性能。\n避免电气火灾，确保热监测持续保护或电弧保护。\n通过Power monitoring Expert提供的电力事件分析，防止停电，避免故障停机。\n使用MTZ电力恢复助手，安全修复断电并恢复供电。\n通过电能质量监控，提高电力系统和资产的可靠性。\n降低能源消耗，并接受由PME提供的能源性能分析和维护服务或由Asset Advisor提供的“基于条件的维护”服务，能节省开支。\nPME的数据分析能助力可持续的电力使用，并遵守法规。\n这一切都是为了更安全、可靠和高效！\nEcoStruxure助力施耐德电气的合作伙伴和终端客户开发可扩展的、汇聚IT和OT的解决方案，连接底层到顶层的所有产品，利用互联性和数据，挖掘可实际操作的商业远见。\n从传感器到云端的每个级别收集数据、分析数据，并将其转换为有意义的分析，使客户能根据实时信息和业务逻辑采取行动。\n您是否知道 25%的电力管理系统存在配置过时和数据质量问题使网络处于危险之中？\n在典型的电力管理系统中有 10-15%的设备接近其支持的生命周期的终点？\n15%的设施在有问题的电能质量状况下运行并可能导致设备损坏和计划外停机？\nEcoStruxure Power Advisor为电气设备的安装做安全检查，特别是对电能质量的检查。\nPower Advisor帮助设备运营团队及时诊断问题，以保障其电源管理系统的正常运行和安全，防止电力系统故障停机、机器出现故障或损坏。\nPower Advisor电力顾问为场所提供系统评分的基准，确定电网问题以提高您的电力可靠性，并给出详细的建议以帮助您优化系统。\n此外，通过先进的分析和专家服务，它提供了优化的系统性能和电力可靠性。\n","description":"","id":3,"section":"sf","tags":null,"title":"EcoStruxure","uri":"http://austinzgx.github.io/sf/ecostruxure/"},{"content":"中南大学郭校长会议-2020-10-27 国家技术标准（有色冶炼）创新基地  标准化课程(8h/1分=\u0026gt;32h/课=\u0026gt;研究生32场讲座/学术活动) 郭学益(副校长) 田庆华(人事处处长) 有色冶金学术委员会副主任 王亲猛  重有色冶金学术委员会  秘书长 李兵 副秘书长 扩充成员 顾问委员会 老专家 大型企业 科研院所 高校 国家平台 自主推荐 纯学术会议 一年一次  底吹炼铜国家科技进步一等奖   今年报奖，公司党委会已上报\n  颜杰准备材料，还未评审\n  7、8个省部级奖项（恒邦1项、方圆2项）\n  2009年国家863课题，尉克俭总负责人\n  项目支撑足够\n  自主创新 推广应用\n  报奖时机把握好\n  30年努力成果 易门铜业\n  尊重历史\n  蒋大师 尉克俭 李东波（加料方式 + 吹炼枪寿命）颜杰 李锋 李兵 梁帅表\n  企业大胆工业应用、自主创新工作要承认\n  中南大学 理论方面的研究 工程问题创新\n  矿铜产量30% 总铜量20%\n  奖项300-\u0026gt;200项，评奖严格\n  网评+会评+答辩\n  贾会长沟通过 组合力量报奖 陆董事长、张书记沟通过\n  郭校长主张学校来牵头，人力投入，细节把握, 发挥自身影响力，不参与会支持，参加就得牵头\n  集团关注,公司汇报后再议\n  ","description":"","id":4,"section":"metal","tags":["Metal"],"title":"note","uri":"http://austinzgx.github.io/metal/temp/"},{"content":"金属期货交易所  伦敦金属交易所（LME） 纽约商品交易所（NYMEX-COMEX） 上海期货交易所（SHFE）  ","description":"","id":5,"section":"metal","tags":["Metal"],"title":"Other","uri":"http://austinzgx.github.io/metal/other/"},{"content":"中国恩菲\u0026amp;中国移动5G+有色金属行业会议纪要 时间：2020-07-24 09:30—12:00 地点：中国恩菲会议中心203\n参加人员：\n中国恩菲：魏甲明、祝建荣、朱瑞军、李兵、葛启发、张维国、张海鑫、张官祥、朱光辉、李永生；\n中国移动：王君庭、赵鹏、龙占勇、云剑、朱峰、李洪城、宋健宇、\n佘国林、张婷婷\n会议内容：\n一、恩菲网络通信及5G+应用需求与合作  1.中国恩菲海外项目与北京总部数据通信，目前采用互联网连接，延时较严重，联合中国移动排查资源与故障瓶颈，给出升级方案措施。 2.恩菲办公区域在国内存在多地办公场所的情形，目前专线实现的远程协作办公不稳定，同时支撑实现恩菲办公区域5G网络覆盖无线办公的需求，请中国移动结合恩菲场景提出解决方案。 3.因恩菲承接国家应急管理厅的数据支撑中心，存在5G专有网络需求实现矿山和冶炼工厂数据的安全经济跨城市通信接入。 4.基于恩菲洛阳偃师基地与北京总部，探讨建立联合开发实验室，共同研制定制化5G通信模组等设备，实验5G工业场景的应用，为有色行业提供5G相关技术及软硬件。  二、OneNET工业物联网平台技术合作  1.利用平台的设备物联、多协议接入能力，结合工程项目实施，打通设备层与数据层的通信交互通道， 支撑工业应用的开发与运行。 2.利用平台的5G+边缘计算能力，针对需求低时延的工业应用场景，为生产企业搭建私有化的切片5G专网，保障数据安全的同时，将低时延的特性得以工业应用。 3.利用平台集成的视觉AI能力，结合有色冶炼、矿山的需求，针对设备监控、人员行为、车辆调度等方面深入合作，切实减人增效、赋能生产。  三、后续需沟通事项  1.中国恩菲进一步整理矿山、冶炼在上述两个合作方向的具体需求，落实明晰5G、OneNet平台与恩菲及智能化业务的合作技术点。 2.中国移动准备5G通信能力的详细介绍材料，5G网络部署方案，5G网络及应用建设成本，结合落地的5G+工业案例。 3.中国恩菲与中国移动组织进一步的深入交流，探讨合作模式与合作点，成立5G联合实验室相关事宜。  第一届重庆智博会 2018-08-29 　8月23－25日，首届中国国际智能产业博览会（简称“智博会”）在重庆举办。国家常委韩正、互联网大佬马云、马化腾出席发布会，参展厂商包含了阿里巴巴、腾讯、京东、百度等众多知名互联网企业，涉及到工业、市政、交通、电力、教育、医疗等各行各业，人工智能等先进技术正在逐步地影响并改变着我们的工作和生活。发展是如此之快，17年初很多还只是慨念的宣讲，到今天各个参展商可以拿出实际的产品。未来技术的变更周期只会越来越短，越来越具备革新意义。\n公司副总经理、总工程师刘诚带队共11人一行参加本次智博会，并与中冶赛迪信息进行交流，以下是本次参观学习的心得体会。\n一、 赛迪信息的启发  赛迪善于把握市场及技术动向，针对新型IT业务成立了赛迪信息化公司，目前已有700多名正式职工，在智慧市政、智慧农业、智慧钢铁及智慧管理四个方面开展了系列研究，也取得了可观的业绩及成果。此次展会上参观了赛迪主导的智慧小镇展览馆，了解到智能垃圾桶、智能井盖、智能路灯等智能硬件设备，试用了其自主开发的\u0026quot;轻\u0026quot;系列软件（轻推、轻筑等)。 赛迪信息采用以战养战的商业模式，项目收入投入技术研发，人才培养及招聘。其技术架构采用产品开发与技术研发分离，技术部门负责通用、核心、基础功能面向服务端的技术研发，产品开发部分负责面向市场用户、关注前端的具体产品的开发。前后端通过API接口进行交互,类似与淘宝网与阿里云的关系。这种分离式开发方式是目前较为通用的开发模式，团队成员的业务各自独立，产品负责人进行最终模块化组装成完整系统，大幅提升开发代码的安全性，大幅缩短开发时间成本。 赛迪信息同时积极与外界合作，从0开始慢慢渗入，逐渐从其传统的钢铁业务向外扩展。两天的参观学习，重点围绕了工业互联网系统的展商，通过沟通了解，他们都具备很强的技术实例，清晰明白与恩菲的合作点和分工。我认为恩菲可以大胆地走出去，这些基础业务不是恩菲的强项，应该找专业的公司去做，恩菲需要把握的是工艺技术的核心，是企业数据的分析和应用。  二、 恩菲智能冶炼系统规划 在开发并市场应用的侧吹+顶吹连续炼铜在线数模优化控制系统后，智能冶炼团队自主开发了网站应用\u0026quot;中国恩菲先进过程控制系统（EAPC）\u0026quot;，立足于实现传统有色冶炼过程控制从DCS转向在线数模控制的智能化升级。目前已完成基础框架及网站建设，可访问http://39.155.246.44:8088。需要继续投入人力、时间进行细化深入开发及市场宣传。系统发展方向初步规划如下：\n 完善系统功能、交互界面友好、离线单元测试，对外发布网址及APP应用、开展市场宣传推广。 应用企业个性化建设、系统部署、测试、上线。(前期部署在生产企业局域网服务器，为企业私有云。实现全企业pc端、手机端信息互通。) 商业谈判及市场开放后，将各应用企业生产数据连接，建设中国恩菲冶金云平台，平台提供大数据分析及行业动态新闻等有价值服务，成为可信赖的冶金生产服务商和企业交互中间商。 通过市场应用推广可加强项目建设完成后恩菲与生成企业的长久联系，互惠互利，生产数据经专业分析可以用来反哺生产过程控制，同时可优化恩菲后续项目的设计。  三、把握数据，引进人才 中国恩菲作为有色行业设计研究的国家队，应该充分认识人工智能强大作用与未来市场，相信有色行业的智能化升级的这一必然趋势，而此项业务在未来完全有可能成为恩菲业务的一项重要分支，恩菲应尽早行动，把握市场先机。\n   系统推广阶段，获取数据最重要，谁把握数据谁把握先机。建议恩菲推广项目时候，尽量前期建设不收费，以数据保密共享为条件，逐步建设恩菲冶金云服务平台。平台切实为企业带来效益、树立了良好的数据信用后，其他企业会要逐步主动加入云平台。类似微信，投放初期没有流量，市场运还需要营支出费用，占领市场个体客户后，依靠数据开发小程序、网游、微信公众号等等都是必然成功，同时市场上其他同类只能望其项背。    恩菲作为非互联网企业，IT方面缺乏技术人才，需要高薪聘请1-2名架构师及数名前后端开发工程师、运维工程师。保持在工艺技术方面关注的同时，IT技术部门建设和人才的引进需要更多的关注和投入。    华为恩菲交流2020-06-12 万 王 张 宋\n行业解决方案\n数据驱动\n中石化 PaaS服务\n云平台租赁 SaaS服务\n私有云与公有云的版本维护、安全管理\n统一设备接入标准（Roma平台产品)\n设计院的数字化交付（产权、使用权限等）\n供应链协同\n数字化集成平台\n全连接工鞋协同数字化座舱 WeLink\n华为去A\n智慧园区\nAtlas人工智能训练算法，嵌入设备\n合作分工：华为云端资源提供，边缘计算服务\n","description":"","id":6,"section":"sf","tags":null,"title":"交流体会","uri":"http://austinzgx.github.io/sf/huawei/"},{"content":" neovim\n- 1.2 Remapped Cursor Movement\n- 1.3 Remapped Insert Mode Keys\n- 1.4 Remapped Text Manipulating Commands in Normal Mode\n- 1.5 Other Useful Normal Mode Remappings\n- 1.6 Remapped Commands in Visual Mode  2 Window Management  2.1 Creating Window Through Split Screen 2.2 Moving the Cursor Between Different Windos 2.3 Resizing Different Windows 2.4 Closing Windows   3 Tab Management 4 Terminal Keyboard Shortcuts   Plugins Keybindings (Screenshots/GIF provided!)  AutoCompletion  COC (AutoCompletion) Ultisnips   Debugger  vimspector (debugger-plugin)   File Navigation  coc-explorer (file browser) Ranger.vim - file browser FZF - the fuzzy file finder xtabline (the fancy tab line)   Text Editing Plugins  vim-table-mode vim-multiple-cursors vim-surround vim-easy-align AutoFormat vim-markdown-toc (generate table of contents for markdown files)   Navigation Within Buffer  vim-easy-motion Vista.vim vim-signiture - Bookmarks   Find and Replace  Far.vim - find and replace   Git Related  vim-gitgutter fzf-gitignore   Others  vim-calendar Goyo - Work without distraction suda.vim coc-translator     Custom Snippets  Markdown   Some Weird Stuff nvim Markdown + nvim tim  neovim 1.2 Remapped Cursor Movement    Shortcut Action Equivalent     K Cursor up 5 terminal lines 5k   J Cursor down 5 terminal lines 5j   H Cursor to the start of the line 0   L Cursor to the end of the line $   W Move cursor five words forward 5w   B Move cursor five words forward 5b    1.3 Remapped Insert Mode Keys    Shortcut Action     Ctrl a Move cursor to the end of the line   jj change to Normal Mode    1.4 Remapped Text Manipulating Commands in Normal Mode    Shortcut Action     U J   \u0026lt; Un-indent   \u0026gt; Indent   SPACE SPACE Goto the next placeholder (\u0026lt;++\u0026gt;)    1.5 Other Useful Normal Mode Remappings    Shortcut Action     r Compile/Run the current file   SPACE s c Toggle spell suggestion a   SPACE d w Find adjacent duplicated word   SPACE t t Convert every 4 Spaces to a tab   SPACE o Fold   SPACE - Previous quick-fix position   SPACE + Next quick-fix position   \\ p Show the path of the current file   SPACE / Create a new terminal below the current window    1.6 Remapped Commands in Visual Mode    Shortcut Action     Y Copy selected text to system clipboard    2 Window Management 2.1 Creating Window Through Split Screen    Shortcut Action     s j Create a new horizontal split screen and place it above the current window   s k Create a new horizontal split screen and place it below the current window   s h Create a new vertical split screen and place it left to the current window   s l Create a new vertical split screen and place it right to the current window   s p v Set the two splits to be vertical   s p h Set the two splits to be horizontal   s r v Rotate splits and arrange splits vertically   s r h Rotate splits and arrange splits horizontally    2.2 Moving the Cursor Between Different Windos    Shortcut Action     SPACE + w Move cursor to the next window   SPACE + h Move cursor one window left   SPACE + l Move cursor one window right   SPACE + k Move cursor one window up   SPACE + j Move cursor one window down    2.3 Resizing Different Windows Use the arrow keys to resize the current window.\n2.4 Closing Windows    Shortcut Action     SPACE q Close the window below the current window. (The current window will be closed if there is no window below)    3 Tab Management    Shortcut Action     t n Create a new tab   t h Go one tab left   t l Go One tab right   t m h Move tab left   t m l Move tab right    4 Terminal Keyboard Shortcuts    Shortcut Action     Ctrl n Escape from terminal input mode    Plugins Keybindings (Screenshots/GIF provided!) AutoCompletion COC (AutoCompletion)    Shortcut Action     Space y Get yank history list   gd Go to definition   gr List references   gi List implementation   gy Go to type definition   Space r n Rename a variable    Ultisnips    Shortcut Action     Ctrl e Expand a snippet   Ctrl n (in snippet) Previous Cursor position in snippet   Ctrl e (in snippet) Next Cursor position in snippet    Debugger vimspector (debugger-plugin)    Key Function     F5 When debugging, continue. Otherwise start debugging.   F3 Stop debugging.   F4 Restart debugging with the same configuration.   F6 Pause debugee.   F9 Toggle line breakpoint on the current line.   F8 Add a function breakpoint for the expression under cursor   F10 Step Over   F11 Step Into   F12 Step out of current function scope    File Navigation coc-explorer (file browser)    Shortcut Action     tt Open file browser   ? show help (in explorer)    Ranger.vim - file browser  Make sure you have ranger installed\nPress R to open Ranger (file selector)  FZF - the fuzzy file finder    Shortcut Action     Ctrl p FZF Files   Ctrl u Move up 1 item   Ctrl e Move down 1 item   Ctrl w FZF Buffers   Ctrl f FZF Files' Content   Ctrl h FZF Recent Files   Ctrl t FZF Tags    xtabline (the fancy tab line)    Shortcut What it creates     to Cycle tab mode   \\p Show current path    Text Editing Plugins vim-table-mode    Shortcut Action     SPACE t m Toggle table mode   SPACE t r Realign table    See :help table-mode.txt for more.\nvim-multiple-cursors    Shortcut Action     Ctrl+k Select next key (multiple cursors)   Alt+k Select all keys (multiple cursors)   Ctrl+p Select previous key   Ctrl+s Skip key   Esc Quit mutiple cursors    vim-surround To add surround (string -\u0026gt; \u0026quot;string\u0026quot;):\nstring press: yskw':\n'string' To change surround\n'string' press: cs'\u0026quot;:\n\u0026quot;string\u0026quot; vim-easy-align Press ga + symbol in normal or visual mode to align text based on symbol\nAutoFormat Press \\ f to format code\nvim-markdown-toc (generate table of contents for markdown files) In markdown files, type :Gen then tab, you\u0026rsquo;ll see your options.\nNavigation Within Buffer vim-easy-motion Press ' and a character jump to character (similar to Emacs' AceJump)\nVista.vim Press T to toggle function and variable list\nvim-signiture - Bookmarks    Shortcut Action     m\u0026lt;letter\u0026gt; Add/remove mark at current line   m/ List all marks   mSPACE Jump to the next mark in buffer   mt Add/remove mark at current line   ma Add annotation at current line   ml Show all bookmarks   mi Next bookmark   mn Previous bookmark   mC Clear bookmarks   mX Clear all bookmarks   mu Move bookmark up a line   me Move bookmark down a line   SPC g Move bookmark to line\u0026hellip;    Find and Replace Far.vim - find and replace Press SPACE f r to search in cwd.\nGit Related vim-gitgutter    Shortcut Action     H Show git hunk at current line   SPACE g - Go to previous git hunk   SPACE g + Go to next git hunk   SPACE g f Fold everything except hunks    fzf-gitignore Press Space g i to create a .gitignore file\nOthers vim-calendar    Shortcut Action     \\ \\ Show clock   \\ c Show calendar    Goyo - Work without distraction Press g y to toggle Goyo\nsuda.vim Forgot to sudo vim ...? Just do :sudowrite or :sw\ncoc-translator Press ts to translate word under cursor.\nCustom Snippets Markdown    Shortcut What it creates     ,n \u0026mdash;   ,b Bold text   ,s sliced text   ,i italic text   ,d code block   ,c big block of code   ,m - [ ] check mark   ,p picture   ,a link   ,1 # H1   ,2 ## H2   ,3 ### H3   ,4 #### H4   ,l \u0026mdash;\u0026mdash;\u0026ndash;    ,f to go to the next \u0026lt;++\u0026gt; (placeholder)\n,w to go to the next \u0026lt;++\u0026gt; (placeholder) and then press Enter for you\nSome Weird Stuff  Press tx and enter your text\ntx Hello\u0026lt;Enter\u0026gt;\n  _ _ _ _ | | | | ___| | | ___ | |_| |/ _ \\ | |/ _ \\ | _ | __/ | | (_) | |_| |_|\\___|_|_|\\___/ nvim    code Action     :w !sudo tee % save file with root       Shortcut Action     \u0026lt;C+i\u0026gt; next postion   \u0026lt;C+o\u0026gt; per postion    yark\u0026amp;paste:\n   keys action     \u0026quot;+y =\u0026gt; Y(visual mode) copy to system clipboard   crtl+shift+v paste system clipboard   \u0026quot;ayy copy line to a   \u0026quot;ap paste a context   \u0026quot;Ayy add context to a    占位符号：\u0026lt;++\u0026gt;\n twice  go to the postion and insert mode actived!\n Markdown + nvim   sheetkeys:\n ,1 H1 r markdown preview ,b bold ,i italic ,m todolist  flask Danjgo   ,a Baidu ,p picture\n    code block: ,c\n  1  print(\u0026#34;Hello Markdown\u0026#34;)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  public static Student(){ name = this.name } ## tim 高见龙 VIM 系统：Mac OS 推荐软件： Alfred VIM \u0026lt;F2\u0026gt;树状结构 \u0026lt;F5\u0026gt;运行程序语言 学习别人的vinrc 从空白文档开始编辑自己的vimrc 使用;h xxx 命令查看帮助 learning vim from the begining (1) 进入可视块操作模式 mac 中可以使用shell终端和VIM切换，ctrl+z 和fg命令 shell中 用ctrl+w 删除一个单词 ctrl+l 清除画面 ctrl+u 删除一整行 ctrl+r 搜寻history / 查找 ，使用n、N切换 {} 段落跳转 [] 首未跳转 ？？ x 删除字符 dd 删除整行 可以在命令前加数字来表示执行次数 3dd 4x yy 复制 p 粘贴 . 重复上一步操作 A 跳至行尾并进入插入模式 :w 保存 :q 退出 :e 打开 :tabe 新table打开文件 T、t 切换table （在windows中不可以） 坚持使用才可以学会 learning vim from the begining (2) Chrome firefox插件可以支持vim操作模式 键盘响应设置为最快 没有文件时可以先输入后保存 r 替换单个字符 R 一直替换 ~ 切换字母大小写 c 删除并进入Insert模式 可视化操作 按住shift选择块（连续） 或按ctrl+q 进入可视块 23 dibd dfas 23 dibd dfas 23 dibd dfas 23 dibd dfas 23 dibd dfas 23 dibd dfas 选中之后可以使用I进入批量插入模式或c进入批量替换模式，离开之后自动补齐。 :ls 查看vim打开的文档列表 :b数字 跳到第n个文档 :vnew 打开新水平视窗 :new 打开新竖直视窗 ctrl+w后再按w顺时针切换视窗 可以再接合hjkl跳转， :sp 对当前文档进行水平切割 :vsp 对当前文档进行竖直切割 :vs 新视窗打开同一个文档，同步比较用： learning vim from the begining (3) Plugins vin=pathogen 套件管理工具 NERD_tree 树状目录 快捷键,tt autohotkey + vim   ","description":"","id":7,"section":"it","tags":null,"title":"vim","uri":"http://austinzgx.github.io/it/vim/"},{"content":" Python Cookbook Python Web 入坑指南 《Python in Practice》 Python面试题 《writing idiomatic python ebook》 《Python 3 Patterns, Recipes and Idioms》 《30个有关Python的小技巧》 《Hidden features of Python》 《Python程序员的10个常见错误》 《Python高级编程slide》 《Effective Python》 《编写高质量代码：改善Python程序的91个建议》 《Code Like a Pythonista: Idiomatic Python》 《The Little Book of Python Anti-Patterns》  None 空类型是对象 != 空字符串、空列表、0、False(值和类型都不相同)\n判空：\n1 2 3 4  if a: pass if not a: pass   对象存在不一定为真！\n1 2 3 4 5  class obj(): def __bool__(self): pass def __len__(self): pass   常量全大写 ACCOUNT\nnew 和 init 的区别\n new 是一个静态方法，init 是一个实例方法 new 方法会返回一个创建的实例，而 init 什么都不返回 只有 new 返回一个 cls 实例时，后面的 init 才会被调用 当创建一个新实例时调用 new，初始化实例时用 init  Write Idiom Python 1 2 3  # 链式比较  if 1 \u0026lt; a \u0026lt; b: pass   1 2 3 4  #交换变量 x = 10 y = 5 x, y = y, x   1 2  # 三目运算 c = a if a ) b else b   1 2  # 拼接字符列表时，用join方法去实现 \u0026#34;.\u0026#34;.join(string_list)   1 2  # 格式化字符时多使用format函数 str = \u0026#34;myname: {} myage:{}\u0026#34;.format(name,age)   1 2 3  # 迭代式 odd_list = [e for e in mylist if e % 2 == 1] {user[\u0026#39;name\u0026#39;]:user[\u0026#39;email\u0026#39;] for user in user_list if \u0026#39;email\u0026#39; in user}   1 2 3 4 5  # 条件判断时，避免直接和True, False, None进行比较(==) if var: pass if somethin is None: pass   1 2 3  # 使用enumerate代替for循环中的index变量访问 for index, element in enumerate(my_container): print \u0026#39;%d%s\u0026#39; % (index, element)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # 避免使用可变(mutable)变量作为函数参数的默认初始化值 # bad def function(l = []): l.append(1) return l print function() print function() print function() # print [1] [1, 1] [1, 1, 1] # good 使用None作为可变对象占位符 def function(l=None): if l is None: l = [] l.append(1) return l   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # 用dict对象完成switch...case...的功能 # bad def apply_operation(left_operand, right_operand, operator): if operator == \u0026#39;+\u0026#39;: return left_operand + right_operand elif operator == \u0026#39;-\u0026#39;: return left_operand - right_operand elif operator == \u0026#39;*\u0026#39;: return left_operand * right_operand elif operator == \u0026#39;/\u0026#39;: return left_operand / right_operand # good def apply_operation(left_operand, right_operand, operator): import operator as op operator_mapper = {\u0026#39;+\u0026#39;: op.add, \u0026#39;-\u0026#39;: op.sub, \u0026#39;*\u0026#39;: op.mul, \u0026#39;/\u0026#39;: op.truediv} return operator_mapper[operator](left_operand, right_operand)   1 2 3 4 5 6 7 8 9 10 11 12  # 访问tuple的数据项时，可以用namedtuple代替index的方式访问 # bad rows = [(\u0026#39;lily\u0026#39;, 20, 2000), (\u0026#39;lucy\u0026#39;, 19, 2500)] for row in rows: print \u0026#39;{}`age is {}, salary is {} \u0026#39;.format(row[0], row[1], row[2]) # good from collections import namedtuple Employee = namedtuple(\u0026#39;Employee\u0026#39;, \u0026#39;name, age, salary\u0026#39;) for row in rows: employee = Employee._make(row) print \u0026#39;{}`age is {}, salary is {} \u0026#39;.format(employee.name, employee.age, employee.salary)   1 2 3  # 用isinstance来判断对象的类型 if isinstance(some_object, (list, dict, str, tuple)): return len(some_object)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  # 用with管理操作资源的上下文环境 #在一个比较典型的场景里，如数据库操作，我们操作connection时一般要正常关闭连接，而不管是正常退出还是异常退出。如下： # bad class Connection(object): def execute(self, sql): raise Exception(\u0026#39;ohoh, exception!\u0026#39;) def close(self): print \u0026#39;closed the Connection\u0026#39; try: conn = Connection() conn.execute(\u0026#39;select * from t_users\u0026#39;) finally: conn.close() # good class Connection(object): def execute(self, sql): raise Exception(\u0026#39;ohoh, exception!\u0026#39;) def close(self): print \u0026#39;closed the Connection\u0026#39; def __enter__(self): return self def __exit__(self, errorType, errorValue, error): self.close() with Connection() as conn: conn.execute(\u0026#39;select * from t_users\u0026#39;)   Python 服务端  Python语言基础考察点 Python算法与数据结构考察点 编程范式考察点 操作系统考察点 网络编程考察点 数据库考察点 Python Web 框架考察点 系统设计考察  一切皆对象 python 面向对象更彻底\n函数和类也是对象，属于一等公民\n 复制给一个变量  1 2 3 4  def ask(name=\u0026#39;zgx\u0026#39;): print(name) my_func = ask my_func(\u0026#34;zgx\u0026#34;)   1 2 3 4 5  class Person: def __init__(self): print(\u0026#34;zgx\u0026#34;) my_class = Person Person()    添加到集合对象中  1 2 3 4  obj_list =[] obj_list.append(Person) for item_class in obj_list: print(item_class())    作为参数传递给函数  1 2  def print_type(item): print(type(item))    作为函数的返回值  1 2 3 4 5 6  def decorator_func(): print(\u0026#34;dec start\u0026#34;) retun ask my_ask = decorator_func() my_ask(\u0026#34;ENFI\u0026#34;)   type、object、class关系 type=\u0026gt;class=\u0026gt;obj\ntype类用来生产类，类来生成实例\nobject是最顶层基类，默认继承\ntype是一个类，也是对象,是自己的对象\npython中常见的内置类型   对象的三个特征:\n 身份(对象在内存中的地址，id()) 类型(int,double\u0026hellip;) 值    None 全局唯一\n  数值类型\n int float complex bool    迭代类型\n for    序列类型\n list bytes\\bytearray\\memoryview(二进制序列) range tuple str array    映射类型\n dict    集合\n set frozenset    上下文管理器\n with    其他\n 模块类型 class与实例obj 函数类型 方法类型 代码类型 object对象 type类型 elipsis类型（省略号） notimplemented类对象    魔法函数 双下划线开头结尾,一般不需要显式调用，python会自动调用。使用后会影响类本身的数据模型\n__getitem__ 实现可迭代\n深入理解类和对象 鸭子模型 实现多态，类实现同一个函数名，具体函数体不同\n1 2 3 4 5 6 7 8 9 10 11 12  class cat: def say(self): print(\u0026#34;i am a cat\u0026#34;) class Dog: def say(self): print(\u0026#34;i am a dog\u0026#34;) class Duck: def say(self): print(\u0026#34;i am a duck\u0026#34;) animal = Cat #Dog #Duck animal().say()   ","description":"","id":8,"section":"code","tags":null,"title":"Base Python","uri":"http://austinzgx.github.io/code/python/base/"},{"content":"简介 Go语言开发实现，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其他的隔离的进程，因此称其为容器 。\n基本概念  镜像Image   相当于一个root文件系统，提供容器运行时所需的程序、库、资源、配置等文件外，还包含了为运行时准备的一些配置参数（匿名卷、环境变量、用户等）。但不包含任何动态数据，其内容在构建之后不会被改变\n 容器Container   类比oop中的类与实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n 安装  CE 社区版 EE 企业版  使用镜像 docker pull [opt] [Docker Registry address]library[:tag]\ndocker run -it --rm xxx bash\n* -it 启动交互界面\r* --rm 容器退出后随之删除\r docker images ls 列出镜像\nphpmyadmin   docker pull phpmyadmin/phpmyadmin\n  docker run --name myadmin -d --link vue-questionnaire-api_database_1:db --net vue-questionnaire-api_default -p 7000:80 phpmyadmin/phpmyadmin\n  kafka  知名的三方镜像wurstmeister/kafka\n  docker-compose.yml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  version:\u0026#39;2.1\u0026#39;services:zookeeper:image:wurstmeister/zookeeperports:- \u0026#34;2181\u0026#34;kafka:image:wurstmeister/kafkaports:- \u0026#34;9092\u0026#34;environmenKAFKA_ADVERTISED_HOST_NAME:192.168.5.139KAFKA_ZOOKEEPER_CONNECT:zookeeper:2181volumes:- /var/run/docker.sock:/var/run/docker.sock    docker-compose up -d\n  docker-compose scale kafka=3\n  docker exec -it kafka_kafka_1 /bin/bash\n   $KAFKA_HOME/bin/kafka-topics.sh --create --topic test --zookeeper kafka_zookeeper_1:2181 --replication-factor 1 --partitions 1\n  $KAFKA_HOME/bin/kafka-topics.sh --list --zookeeper kafka_zookeeper_1:2181\n  $KAFKA_HOME/bin/kafka-console-producer.sh --topic=test --broker-list kafka_kafka_1:9092 \n  $KAFKA_HOME/bin/kafka-console-consumer.sh --bootstrap-server kafka_kafka_1:9092 --from-beginning --topic test \n  redis docker pull redis\n 创建redis容器，启动redis-server  docker run -d --name myredis -p 6379:6379 -v /c:/Workspace/redis redis --appendonly yes\ndockers中开启磁盘共享\n​\n2. 启动redis cli\n docker exec -it py-redis redis-cli\n python\npip install redis\n  test\nfrom redis import Redis\nr = Redis(host=\u0026lsquo;127.0.0.1\u0026rsquo;, port=6379, db=0)\n  mysql docker pull mysql\nmkdir docker_v/mysql/conf\ntouch my.conf\ndocker run -p 3306:3306 --name mysql -v /opt/docker_v/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -d mysql\n docker run -p 3306:3306 \u0026ndash;name mysql \\ -v /mydata/mysql/log:/var/log/mysql \\ -v /mydata/mysql/data:/var/lib/mysql \\ -v /mydata/mysql/conf:/etc/mysql \\ -e MYSQL_ROOT_PASSWORD=root \\ -d mysql:5.7\n mongodb 1  docker run -itd --name mongo -p 27017:27017 mongo --auth   容器原理  虚拟机  OS OS OS OS \u0026hellip; VM VM VM VM \u0026hellip; HyperVisor CPU 内存 硬盘 网络   容器  容器 容器 容器 \u0026hellip; Docker引擎 PID 网络 存储 文件系统 OS 服务器   比较   VM, 对物理硬件资源进行虚拟化，然后建立出虚拟机，运行OS； Docker, 对OS进行虚拟化，将虚拟出来的OS放到容器内，用来运行程序  命令 docker version\ndocker info\n拉取镜像 docker pull image-name\n拉取镜像并运行 docker run iamge-name\n查看镜像 docker image ls\n删除镜像 docker rmi image-name|image-id\ndocker ps\n查看容器 docker container ls\n启动容器 docker start c-name|c-id\n暂停容器 docker stop c-name|c-id\n删除容器 docker rm c-name|c-id\ndocker run -it --rm -p 8000:80 -v $PWD/db:/data/db --name mycontainer mysql\n mysql 镜像名 \u0026ndash;name 容器自定义名称 -v $PWD/db挂载为容器的data/db，作为mongo数据存储目录 -p 映射端口 80内部对应8000外部端口 \u0026ndash;rm 容器停止后直接删除 -it 启动交互bash | -d 后台运行分离模式  ctrl+C同时停止容器和终端\nctrl+p ctrl+q 只会停止终端\ndocker exec -it c-id|c-name /bin/bash 进入容器终端，exit退出\n","description":"","id":9,"section":"it","tags":null,"title":"Docker","uri":"http://austinzgx.github.io/it/docker/"},{"content":"用Pythonic方式来思考 确认python版本  python2 python3 CPython Jython IronPython PyPy  1  python --version   1 2 3  import sys print(sys.version) print(sys.version_info)   遵循PEP8风格指南 python Enhancement Proposal #8\nPylint 源码静态分析工具\n空白  使用space表示缩进，不要使用tab 4个空格 每行字符数不应超过79 函数与类之间两个空行隔开 同一个类中个方法之间用一个空行隔开 使用下标来获取列表元素、调用函数或给关键字参数赋值的时候，不要在两旁添加空格 赋值=前后加空格  命名  函数、变量及属性小写，下划线连接 lowercase_underscore 受保护的实例属性，单下划线开头 _leading_underscore 私有的实例属性，双下划线开头 __double_leading_underscore 类与异常，首字符大写 CapitalizWord 模块级别的变量，应全部大写，下划线连接 ALL_CAPS 类中的实例方法（instance method),首个参数命名为self 类方法（class method),首个参数命名为cls  表达式和语句  采用内联形式的否定词。 if a is not b \u0026gt; if not a is b 不要通过检查长度的方法来判断list是否为[]或'\u0026lsquo;等空值。 if not somelist\u0026gt;if len(somelist)==0 不要编写单行的for、if 、while、except符合语句 import语句应该总是放在文件开头 引入模块时，总是使用绝对名称，而不应该根据当前模块的路径来使用相对名称。引入bar包中的foo模块时，应该完整地写出from bar import foo 》 import foo,或者采用明确写法 from . import foo  bytes|str|unicode区别 python3字符序列类型\n bytes （实例包含原始8个字节） str （实例包含Unicode字符）  Unicode=\u0026gt;二进制 encode 编码 UTF-8\n二进制=》Unicode decode 解码\n解码与编码操作放在界面最外围来做，程序核心部分使用Unicode字符类型，而且不要对字符编码做任何假设。\npython3中，内置open函数获取了文件句柄，默认采用UTF-8编码格式来操作文件。open函数添加了encoding新参数，默认值为\u0026rsquo;utf-8\u0026rsquo;,必须传入包含Unicode字符的str实例，而不接受包含二进制的bytes实例。\u0026lsquo;wb\u0026rsquo; \u0026lsquo;rb\u0026rsquo;来开启可以解决上述问题\n用辅助函数来取代复杂的表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  red = int(my_values.get(\u0026#39;red\u0026#39;,[\u0026#39;\u0026#39;])[0] or 0) red = my_values.get(\u0026#39;red\u0026#39;,[\u0026#39;\u0026#39;]) red = int(red[0]) if red[0] else 0 red = my_values.get(\u0026#39;red\u0026#39;,[\u0026#39;\u0026#39;]) if red[0]: red = int(green[0]) else: red = 0 ## 辅助函数封装 def get_first_int(values,key,default=0): found = values.get(key,[\u0026#39;\u0026#39;]) if found[0]: found = int(found[0]) else: found = default return found red = get_first_int(my_values,\u0026#39;red\u0026#39;)   了解切割序列的方法 somelist[start🔚stride]\n start 起始索引，涵盖 end 结束索引，不涵盖 stride 步进，不要同时使用，先范围切割，再步进切割，而且不要设定负值 start=0或者end=len(list),应该省略 切片操作不会计较start与end是否越界  列表推导式来取代map|filter 1 2 3 4 5 6  a = [1,2,3,4,5,6] squares = [ x**2 for x in a] squares = map(lambda x:x**2,a) even_squares = [x**2 for x in a if x%2 == 0] alt = map(lambda x:x**2,filter(lambda x:x%2 ==0，a))   1 2 3 4 5  chile_ranks={\u0026#39;ghost\u0026#39;:1,\u0026#39;habanero\u0026#39;:2,\u0026#39;cayenne\u0026#39;:3} rank_dict={rank:name for name,rank in chile_ranks.items()} #{ 1:\u0026#39;ghost\u0026#39;,2:\u0026#39;habanero\u0026#39;,3,\u0026#39;cayenne\u0026#39;} chile_len_set={len(name) for name in rank_dict.values()} ## {8,5,7}   列表推导式支持多级循环，每一级循环也支持多项条件，超过两个表达式的列表推导不建议使用\n用生成器表达式来改写数据量较大的列表推导 1 2  value = [len(x) for x in open(\u0026#39;test.txt\u0026#39;)] ## 文件较大时 会出问题，适合少量的输入值   生成器表达式generator expression对列表推导和生成器的一种泛化\n生成器表达式在运行的时候，并不会把整个输出序列都呈现出来，而是会估值为迭代器（iterator)。每次可以根据生成器表达式产生一项数据。\n把实现列表推导所用的写法放在（）中，就构成了生成器表达式。他会立即返回一个迭代器，而不会深入处理文件中的内容。\n1 2 3 4  it = (len(x) for x in open(\u0026#39;test.txt\u0026#39;)) ## \u0026lt;generator object ....\u0026gt; next(it) ## 1000   尽量使用enumerate取代range enumerate可以把各种迭代器包装为生成器，每次产出一对输出值，前者表示循环下标，后者表示迭代器中渠道的下一个序列元素\n1 2 3 4 5  for i, flavor in enumerate(flavor_list): print(\u0026#39;%d:%s\u0026#39; %(i+1,flavor)) ## 可以指定enumerate函数开始计数所用值 for i, flavor in enumerate(flavor_list,1): print(\u0026#39;%d:%s\u0026#39; %(i,flavor))   用zip函数同时遍历两个迭代器 1 2 3 4 5 6 7 8  names=[\u0026#39;James\u0026#39;,\u0026#39;Kobe\u0026#39;,\u0026#39;Zgx\u0026#39;] letters=[len(n) for n in names] longest_name=None max_letters =0 for name, count in zip(names,letters): if count\u0026gt;max_letters: longest_name = name max_letters = count   合理利用try/except/else/finally   finally\n若既要将异常向上传播，又要在异常发生时执行清理工作\n  1 2 3 4 5 6 7 8 9  handle = open(\u0026#39;test.txt\u0026#39;) try: data = handle.read() finally: handle.close() ## 注意open 方法必须放在try块外面，如果打开文件时发生异常，那么程序应该跳过finally块。 ## 使用上下文更简便 with open(\u0026#39;test.txt\u0026#39;) as f: data = f.read()    else\ntry/except/else结果可以清晰描述出那些异常由自己的代码处理，那些异常会传播到上一级。如果try块没有发生异常，那么执行else;如果try块发生了异常，那么执行except块。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  def load_json_key(data,key): try: result_dict = json.loads(data) #may raise ValueError except ValueError as e: raise KeyError from e else: return result_dict[key] ## may raise KeyError 3. 混合使用 ```python def divide_json(path): handle = open(path,\u0026#39;r+\u0026#39;) ## may raise IOError try: data = handle.read() ## may raise UnicodeDecodeError op = json.loads(data) ## may raise ValueError value = (op[\u0026#39;numerator\u0026#39;]/op[\u0026#39;denominator\u0026#39;]) ## may raise ZeroDivisionError except ZeroDivisionError as e: return UNDEFINED else: op[\u0026#39;result\u0026#39;]= value result = json.dumps(op) handle.write(result) #may raise IOError return value finally: handle.close() ## Always runs   ","description":"","id":10,"section":"code","tags":null,"title":"effective python","uri":"http://austinzgx.github.io/code/python/effective-python/"},{"content":"分布式版本控制系统（Distributed Version Control System，简称 DVCS）\n客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像\n下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。\nLinux 的缔造者 Linus Torvalds\nGit记录快照而不是数据差异\n理论 三种状态\n 已修改modified:表示修改了文件，但还没保存到数据库中。 已暂存staged:表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 已提交committed:表示数据已经安全地保存在本地数据库中。  三个阶段\n 工作区working direactory 暂存区staging area Git 目录 .git direactory (Repository)  Working Direactoy-\u0026gt;Staging Area: Stage Fixes\rStaging Area-\u0026gt;Repository:commit\rRepository-\u0026gt;Working Direactoy: Checkout the project\r配置   用户名和邮件\n1 2 3  git config --global user.name \u0026#34;zhanggx\u0026#34; git config --global user.email enfizgx@163.com   \r  设置别名\n sudo git config \u0026ndash;system alias.st status sudo git config \u0026ndash;system alias.ci commit sudo git config \u0026ndash;system alias.co checkout sudo git config \u0026ndash;system alias.br branch    开启颜色提示\n git config \u0026ndash;global color.ui true    git及gitlab学习   Git global setup\n git config --global user.name \u0026quot;zhanggx\u0026quot; git config --global user.email \u0026quot;457327972@qq.com\u0026quot;    Create a new repository\n git clone http://171.26.17.2:7777/zgx/ss.git cd ss touch README.md git add README.md git commit -m \u0026ldquo;add README\u0026rdquo; git push -u origin master    Existing folder\n cd existing_folder git init git remote add origin http://171.26.17.2:7777/zgx/ss.git git add . git commit -m \u0026ldquo;Initial commit\u0026rdquo; git push -u origin master    Existing Git repository\n cd existing_repo git remote rename origin old-origin git remote add origin http://171.26.17.2:7777/zgx/ss.git git push -u origin \u0026ndash;all git push -u origin \u0026ndash;tags    lazygit https://github.com/jesseduffield/lazygit 伏地魔\n","description":"","id":11,"section":"it","tags":null,"title":"git","uri":"http://austinzgx.github.io/it/git/"},{"content":"文档输出： document.write(\u0026quot;xxx\u0026quot;)\n数据类型：  字符串string 数字Num 布尔Boolean 数组Array 对象Object 空Null 未定义Undefined  运算符: 条件语句：  if\u0026hellip;else\u0026hellip;. switch for while  函数： function 函数名(参数){\n函数体；\nreturn 返回值；\n}\n函数的调用：\n函数名();\n异常： try{\n可能出现异常的代码；\n}catch(err){\n错误信息的处理；\n}\n事件： onClick=\u0026ldquo;函数名()\u0026rdquo;\nonMouseOver\nonMouseOut\nonChange\nonSelect\nonFocus\nonBlur\nonLoad\nonUnload\nDOM对象： Document Object Model 文档对象模型\n元素、属性、样式、事件\n","description":"","id":12,"section":"code","tags":null,"title":"javascript","uri":"http://austinzgx.github.io/code/frontend/javascript/"},{"content":"ArchLinux x86_64 GNU/Linux\n Keep It Simple, Stupid\n  package manager system Pacman AUR (Arch User Repository)  dwm    key action     super+k hiddle current window tab   super+h/l change current window size   super+e change current window   super+Retrun open termial   super+c open chrome   super+t show split window   super+m show current window max   super+f show current window fullscreen   super+shift+2 move current window to x   super+ctrl+2 add x to current window    st ranger    key action     du show size   yp yank path   [] change parent file   r select open file way   zh show hidden file   oc order file by modifyed time   os order file by size   on order file by name   / search file and use n or N   f only show matched file   S open st in this file path   V open or create new file in nvim way   M create new folder   yy\u0026amp;pp copy file   dd\u0026amp;pp cut file   dD delete file or folder   cw rename file or use vim a i I A   w open ra list   c zip select files   yy\u0026amp;X unzip zipfile    ","description":"","id":13,"section":"it","tags":null,"title":"linux","uri":"http://austinzgx.github.io/it/linux/"},{"content":"电影  肖申克的救赎 霸王别姬 这个杀手不太冷 千与千寻 泰坦尼克号 阿甘正传 盗梦空间 海上钢琴师 三傻大闹宝莱坞 忠犬八公的故事 大话西游之大圣娶亲/仙履奇缘 大话西游之月光宝盒 龙猫 教父1/2/3 搏击俱乐部 无间道 天空之城 少年派的奇幻漂流 鬼子来了 活着 两杆大烟枪 哈尔的移动城堡 七宗罪 饮食男女 入殓师 素媛 黑客帝国 蝴蝶效应 拯救大兵瑞恩 幽灵公主 让子弹飞 阳光灿烂的日子 重庆森林 射雕英雄传之东成西就 上帝之城 禁闭岛 致命ID 一一 末代皇帝 摩登时代 风之谷 萤火虫之墓 幸福终点站 菊次郎的夏天 倩女幽魂 电锯惊魂 谍影重重 雨人 东邪西毒 杀人回忆 喜宴 喜剧之王 英雄本色 花样年华 冰川时代 唐伯虎点秋香 秒速五厘米 阿飞正传 爆裂鼓手 牯岭街少年杀人事件 魔女宅急便 新龙门客栈 国王的演讲 遗愿清单 疯狂的石头 天注定 颐和园 摔跤吧！爸爸 驴得水 剑雨 一个陌生女人的来信 太阳照常升起  电视剧  走向共和 天道 康熙王朝 绝命毒师 生活大爆炸 越狱 毛骗 大宅门 亮剑 外乡人 武林外传 潜伏 三国演义 白鹿原 士兵突击 茶馆 我爱我家  ","description":"","id":14,"section":"life","tags":null,"title":"Movie","uri":"http://austinzgx.github.io/life/movie/"},{"content":"安装  初始化 mysqld -- initialize 在Data文件夹中生成初始化文件，其中zhanggx.err中有初始root密码 安装workbench，并且建立连接  配置  windows文件配置 my.ini  1 2 3 4 5 6 7  [mysqld] innodb_flush_method=normal basedir=\u0026#39;C:\\MySQL\\Engine\u0026#39; datadir=\u0026#39;C:\\MySQL\\Data\u0026#39; character-set-server=utf8 [client] default-character-set=utf8    我的安装目录 cd c:\\MySQL\\Engine\\bin 启动服务 mysqld --console  常用命令  字段设置支持中文 alter table tableName CONVERT TO CHARACTER SET utf8 Bit字段问题  SqlServer 常用命令  获取所有用户名:  1 2 3 4 5  Select name From Sysusers where status=\u0026#39;2\u0026#39; and islogin=\u0026#39;1\u0026#39; islogin=\u0026#39;1\u0026#39; :表示帐户 islogin=\u0026#39;0\u0026#39; :表示角色 status=\u0026#39;2\u0026#39; :表示用户帐户 status=\u0026#39;0\u0026#39; :表示糸统帐户    获取所有数据库名:  1  Select Name From Master..SysDatabases order By Name    获取所有表名:  1 2 3  Select Name From DatabaseName..SysObjects Where XType=\u0026#39;U\u0026#39; order BY Name XType=\u0026#39;U\u0026#39; :表示所有用户表; XType=\u0026#39;S\u0026#39; :表示所有系统表;    获取所有字段名:  1  Select Name From SysColumns Where id=Object_Id(\u0026#39;表名\u0026#39;)    获取数据库所有类型:  1  select name From systypes    获取主键字段:  1  Select name From SysColumns Where id=Object_Id(\u0026#39;表名\u0026#39;) and colid=(select top 1 keyno From sysindexkeys where id=Object_Id(\u0026#39;表名\u0026#39;))   ","description":"","id":15,"section":"code","tags":null,"title":"mysql","uri":"http://austinzgx.github.io/code/sql/sql/"},{"content":" python data structures and algorithms\n  problem-solving-with-algorithms-and-data-structure-using-python  程序 = 算法 + 数据结构\n算法（Algorithm）：是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。\n数据结构（Data Structures）：是计算机存储和组织数据的一种方式，可以用来高效地处理数据。\n举个例子：二分查找就是一个非常经典的算法，而二分查找经常需要作用在一个有序数组上。这里二分就是一种折半的算法思想，\n而数组是我们最常用的一种数据结构，支持根据下标快速访问。很多算法需要特定的数据结构来实现，所以经常把它们放到一块讲。\n实际上，在真正的项目开发中，大部分时间都是 从数据库取数据 -\u0026gt; 数据操作和结构化 -\u0026gt; 返回给前端，在数据操作过程中需要合理地抽象，\n组织、处理数据，如果选用了错误的数据结构，就会造成代码运行低效。这也是我们需要学习算法和数据结构的原因。\n抽象数据类型和面向对象编程 内置常用算法和数据结构  常用内置数据类型：list, tuple, dict, set, frozenset, collections, heapq, bisect     数据结构/算法 语言内置 内置库     线性结构 list(列表)/tuple(元祖) array(数组，不常用)/collections.namedtuple   链式结构  collections.deque(双端队列)   字典结构 dict(字典) collections.Counter(计数器)/OrderedDict(有序字典)/defaultdict   集合结构 set(集合)/frozenset(不可变集合)    排序算法 sorted    二分算法  bisect模块   堆算法  heapq模块   缓存算法  functools.lru_cache(Least Recent Used, python3)    链表 队列 栈 算法分析 哈希表 字典 集合 递归 线性查找与二分查找 基本排序算法 高级排序算法  高级排序算法 分治法与归并排序 快速排序  树与二叉树 堆和堆排序 优先级队列 二叉查找树 图与图的遍历 ","description":"","id":16,"section":"code","tags":null,"title":"Python数据结构与算法","uri":"http://austinzgx.github.io/code/python/aads/"},{"content":"set key value\nget key\nmset mget 一次设置读取多个值\nexists 判断key是否存在\ndel 删除key\ntype 检查value类型\nexpire 设置key的有效值 expire key 时长(s)\nex : set key value ex 时长(s)\nttl: 查看key剩余时间\n","description":"","id":17,"section":"it","tags":null,"title":"redis","uri":"http://austinzgx.github.io/it/redis/"},{"content":"风之谷 1984年：风之谷（风の谷のナウシカ)\n天空之城 1986年：天空之城(天空の城ラピュタ)\n龙猫 1988年：龙猫(となりのトトロ)\n魔女宅急便 1989年：魔女宅急便(魔女の宅急便)\n红猪 1992年：红猪(红の豚)\n幽灵公主 1997年：幽灵公主(もののけ姫)\n千与千寻 2001年：千与千寻(千と千寻の神隠し)\n哈尔的移动城堡 2004年：哈尔的移动城堡（ハウルの动く城)\n悬崖上的金鱼姬 2008年：悬崖上的金鱼姬（崖の上のポニョ)\n起风了 2013年：起风了（风立ちぬ)\n","description":"","id":18,"section":"life","tags":null,"title":"宫崎骏","uri":"http://austinzgx.github.io/life/gqj/"},{"content":"似水流年 2003年9月\n 绽放 似水流年 远 一辈子的十分钟 今生今世 遥不可及 什刹海 八月照相馆 温暖 传奇 紫罗兰  为你而来 2005年1月\n 为你而来 不知不觉 在海上 明天还会在路上 父亲 向往 恋人 云上的日子 纵身一跳 你像从前一样  什刹海 2006年10月\n 不知不觉 什刹海 一辈子的十分钟 八月照相馆 远 似水流年 为你而来 父亲 绽放 向往  想念你 2007年4月\n  抚仙湖\n  风吹麦浪\n  童年\n  超越\n  松花江\n  天狐\n  异乡人\n   词：李健\n曲：李健\n披星戴月地奔波\n只为一扇窗\n当你迷失在路上\n能够看见那灯光\n不知不觉把他乡\n当做了故乡\n只是偶尔难过时\n不经意遥望远方\n曾经的乡音\n悄悄地隐藏\n说不出的诺言\n一直放心上\n有许多时候\n眼泪就要流\n那扇窗是让我坚强的理由\n小小的门口\n还有她的温柔\n给我温暖陪伴我左右\n   想念你\n  小鸟睡在我身旁\n  异乡人（伴奏）\n  寂寞星空·见歌 2008年10月\n 遥远的天空底下 露天电影院 矜持 陀螺 溺爱 大海啊,故乡 梦一场 窗台 绒花 再别康桥  音乐傲骨 2009年12月\n 璀璨   作曲 : 李健\n作词 : 李健\n没有一朵花 留住它的季节\n像我一样 不能在你身边 到永远\n总有一阵风 要带走些什么\n像你一样 离去时总不说 再见\n生命如此无常\n我总是一样 不停地追寻我终究要 失去的\n像一阵风在原野流浪\n生命就是这样\n我却是无常 永远不知道下一刻 欢乐或悲伤\n像河水漫无目的流淌\n多绚烂的花 多美妙的季节\n说我爱你 请你一定相信 这一刻\n总有一阵风 要带走些什么\n像你一样 离去时总不说 再见\n生命如此无常\n我总是一样 不停地追寻我终究要 失去的\n像一阵风在原野流浪\n生命就是这样\n我却是无常 永远不知道下一刻 欢乐或悲伤\n像河水漫无目的流淌\n多绚烂的花 多美妙的季节\n我说爱你 请你一定相信 这一切\n   一往情深的恋人\n  圣洁之光\n  完美坚持\n  在每个想你的夜里\n  故乡山川\n   作曲 : 李健\n作词 : 李健\n当微风送花草清香\n正是我想你的季节\n远方的家是否无恙\n江水日夜流淌\n当风筝已漫天飞旋\n曾是你望眼欲穿\n往日时光\n匆匆流水\n带你奔向何方\n我心中的世界竟是如此遥远\n不知不觉中已离家千万里\n此刻灯火辉煌多想与你分享\n却再也不能回到你身边\n脚下虽有万水千山\n却远不过对你的思念\n看过多少\n月落日出\n没有相同的一天\n每当雪花绽放\n心也跟随飞舞\n曾经的候鸟\n如今身在何处\n在那遥远地方\n灯火依然昏黄\n却无数次\n照亮我的梦乡\n我心中的世界竟是如此遥远\n不知不觉中已离家千万里\n在那遥远地方灯火依然昏黄\n却无数次照亮我的梦乡\n  Lily 爱的四季 转眼瞬间 好望角 我的朋友 传奇 (2010版) *再版Bonus Track  传奇 2010年7月\n 传奇 当有天老去 *新歌 似水流年 绽放 我愿人长久 *新歌 远 为你而来 云上的日子 八月照相馆 恋人 什刹海 向往 父亲 一辈子的十分钟  依然 2011年12月\n 心升明月 Color Me Love 我始终在这里 回到从前 舍得 珍爱深深 依然在路上 贝加尔湖畔 眷恋 凌晨两点 谢谢你  拾光 2013年9月\n  向往\n  抚仙湖\n  为你而来\n  异乡人\n  风吹麦浪\n  远\n  你像从前一样\n  绽放\n  八月照相馆\n  恋人\n  丽江\n  当有天老去\n  一往情深的恋人\n  今生今世遥不可及\n  父亲\n  传奇 (2013重唱版)\n  李健 2015年8月\n  深海之寻\n  美若黎明\n  日落之前\n  沧海轻舟\n  雨后初晴\n  众妙\n  迷雾\n  风吹黄昏\n  消失的月光\n  假如爱有天意\n   词：李健\n曲：Yoo Young Seok\n当天边那颗星出现\n你可知我又开始想念\n有多少爱恋只能遥遥相望\n就像月光洒向海面\n年少的我们曾以为\n相爱的人就能到永远\n当我们相信情到深处在一起\n听不见风中的叹息\n谁知道爱是什么\n短暂的相遇却念念不忘\n用尽一生的时间\n竟学不会遗忘\n如今我们已天各一方\n生活得像周围人一样\n眼前人给我最信任的依赖\n但愿你被温柔对待\n多少恍惚的时候\n仿佛看见你在人海川流\n隐约中你已浮现\n一转眼又不见\n短暂的相遇却念念不忘\n多少恍惚的时候\n仿佛看见你在人海川流\n隐约中你已浮现\n一转眼又不见\n当天边那颗星出现\n你可知我又开始想念\n有多少爱恋今生无处安放\n冥冥中什么已改变\n月光如春风拂面\n ","description":"","id":19,"section":"life","tags":null,"title":"李健","uri":"http://austinzgx.github.io/life/ido/"},{"content":"张官祥，施耐德IAC团队有色行业架构师，硕士研究生，毕业于北京科技大学冶金工程专业，2020年有色金属学会青年科技论坛学术委员会委员、有色冶金过程智能优化控制与智能装备分会主席。\n2019年执笔主编由工信部及有色金属协会组织《有色金属行业智能冶炼工厂建设指南》。\n曾在中国恩菲工程技术有限公司从事有色工程项目咨询设计及施工服务工作，自主研发应用有色冶金数模在线优化控制系统，后主要负责有色冶炼智能工厂架构规划与项目管理工作。\n","description":"","id":20,"section":"oa","tags":null,"title":"自我介绍","uri":"http://austinzgx.github.io/oa/introduce/"},{"content":"饮酒-陶渊明  结庐在人境，而无车马喧\n问君何能尔，心远地自偏\n采菊东篱下，悠然见南山\n山气日夕佳，飞鸟相与还\n此中有真意，欲辨已忘言\n ","description":"","id":21,"section":"life","tags":null,"title":"诗词","uri":"http://austinzgx.github.io/life/%E8%AF%97%E8%AF%8D/"},{"content":"web前端开发工程师 职位职责：  参与Web前端项目架构及核心代码研发工作； 各产品web端功能的设计开发及实现； JS与其他语言的混合型应用开发； 配合后端工程师完成产品前台页面的开发； 根据产品需求，从技术的角度进行评估，并给出建议，推动用户体验的优化。 解决各种浏览器设备和移动设备的兼容性问题； 负责完成领导交办其它各项工作； 学习新技术，提高开发能力；  \n岗位要求： 1. 本科以上学历，学习能力强，适应能力好。\r2. 熟悉javascript，HTML，CSS等相关技术，熟悉页面架构及布局、熟悉浏览器的资源加载、渲染机制。\r3. 至少熟练掌握Angular，Vue，React框架其中一种，并有相关SPA项目经验，能够处理页面复杂数据交互；\r4. 熟练掌握常用开发工具和调试技巧，如Git，抓包工具，命令行等；\r5. 良好的编码习惯和团队合作精神，较强的沟通能力及较好的创新能力，诚实、细致、敬业；\r6. 3年以上Web前端开发经验者优先、有Electron使用经验者优先。\r\n智能冶炼后端开发工程师 职位职责：\n  参与有色冶炼智能工厂项目设计与架构设计。\n  负责业务流程分析、详细设计、数据库设计、测试报告等相关技术材料编制工作；\n  负责系统模块的开发与单元测试。\n  负责完成领导交办其它各项工作；\n  学习新技术，提高开发能力；\n  岗位要求：\n 本科以上学历，学习能力强，适应能力好，关注新技术； 基础知识扎实，熟悉面向对象设计方法，熟悉常用数据结构、算法及设计模式； 熟练掌握C#或python语言; 熟悉Asp dotnet Core技术框架或python web开发框架（flask熟悉者优先）; 熟悉MySQL、 SQL Server等数据库CURD操作; 良好的编码习惯和团队合作精神，较强的沟通能力及较好的创新能力，诚实、细致、敬业; 熟练掌握常用开发工具和调试技巧，如Git，基本linux操作等； 对复杂的服务端系统有构架、优化经验者优先; 具有冶金相关专业学习背景者优先  ","description":"","id":22,"section":"oa","tags":null,"title":"软件工程师招聘","uri":"http://austinzgx.github.io/oa/recruit/"},{"content":"一、研究目标及研究内容简介 本项目基于对有色企业生产、管理、运营等现状的全面分析和调研，发挥恩菲所具有的冶金工艺、装备、设计经验等优势，结合工业互联网平台技术，应用成熟可靠的技术架构，率先开拓实践恩菲自身牵头编制的《有色金属行业智能工厂建设指南》中的有色冶炼数据化集成平台，搭建恩菲有色冶炼云平台，拓宽恩菲的设计咨询工程建设业务范围到冶炼企业的生产运营管理服务，为有色冶炼企业提供快捷部署、先进可依赖的工业级SaaS服务。在恩菲冶炼云平台上，集成优化已市场应用的恩菲自主开发的“烟台国润侧吹+多枪顶吹”及“云南驰宏锌锗会泽侧吹熔化炉”先进过程控制系统，同时针对有色生产企业过程控制的难点和运营管理的痛点，研究开发智能化升级建设的关键技术软件系统，逐步落地实施公司有色冶炼八大任务规划中重点项目，以打造绿色安全高效的有色冶炼企业为目标，形成恩菲智能冶炼方面的核心专长技术、形成新的利润增长点提供强力技术支持。\n1 背景及来源： 当前，有色金属冶炼企业普遍认识到智能制造的重要性，加快推进数字化、网络化建设，部分企业在无人行车、设备智能诊断、铜板自动剥离等局部领域的智能化应用取得突破。但总体看，有色金属冶炼企业距离全自动化、全数字化还有一定差距。企业尚未实现整体互联互通，外部产业链协同基本空白；决策模型普遍缺乏，自适应、自执行、自学习的智能制造系统仍处于初步探索阶段。\n2019年4月始，由工信部组织，委托中国有色金属行业协会编制《有色金属行业智能制造建设指南》，其中恩菲作为牵头单位编制了其中《有色金属行业智能冶炼工厂建设指南》，编制组先后赴江西铜业集团有限公司、重庆旗能电铝有限公司、云南驰宏锌锗股份有限公司、云南锡业集团（控股）有限责任公司开展系列调研活动，深入了解有色金属行业智能冶炼工厂建设需求、建设现状、建设范围及存在的主要问题，另外对西门子智能制造（成都）创新中心、华为技术有限公司（深圳龙岗坂田基地、东莞松山湖基地）进行现场调研和沟通交流，了解最新的智能制造技术及IT技术。\n恩菲作为有色行业的龙头设计单位，，应进一步发挥具备多年的设计咨询及工程实践项目经验的优势，积极拥抱工业互联网、物联网、人工智能等先进技术，研究开发具有自主知识产权的有色冶炼智能化的关键技术及软件，抢占市场先机与市场，打造恩菲特色鲜明的实用先进的工业互联网有色服务平台。\n2 研究目标： （1）\t完成恩菲有色冶炼云服务平台的技术架构设计。\n（2）\t完成云服务平台基础设施建设与平台基础应用集成。\n（3）\t测试云平台服务接口，面向市场上线运行。\n（4）\t部署应用恩菲冶炼先进过程控制系统等应用服务。\n（5）\t联合外部服务商、设备商开发应用其他服务。\n3 研究内容： （1）\t先进过程控制系统开发\n针对新疆紫金有色金属有限公司新建10万吨电锌冶炼项目的核心生产工序“焙烧制酸工序”建立冶金数学模型，实现业主方面提出的焙烧炉投矿智能化控制要求，系统采集焙烧炉沸腾层各点温度、炉底压力、二氧化硫浓度、氧浓度数据，由数模计算得出应有的鼓风量和投矿量，经DCS系统下发执行。研究该系统于上下层MES、DCS层的通讯交互及数据库架构。\n（2）\t设备管理系统开发\n基于项目实际情况，自主开发设备管理系统，实现设备信息数字化、设备巡检、维修智能化，切实解决业主日常经营维护中痛点。包含有设备台账、设备维护记录、设备点检管理、设备备品备件管理等，并考虑与MES层系统融合。\n（3）\t物流管理系统开发\n基于项目实际情况，自主开发物流管理系统，完成企业原料、辅料等进厂接卸，半成品库存管理，成品出入库管理及渣料管理，提高企业精细化管理水平。包含有来料进厂预报、销售出厂预报、出入库管理、检斤化验集成等等。考虑与MES层系统融合。\n（4）\t系统架构及技术方案研究\n研究整体企业信息系统架构及业务蓝图规划，明确落实技术方案中整体性的数据架构、网络架构、应用架构。撰写新疆三化建设技术方案，明确分期建设内容，重点突出整体性基础网络、数据中心建设，具体到一期三化建设目标、功能、分工、计划、投资。\n二、技术路线、主要创新点 技术路线： （包括研究途径、技术方案。研究途径如调研-设计-加工-应用-改进优化-试验等，技术方案可以是工艺流程图等）\n 利用烟台国润“侧吹+多枪顶吹”连续炼铜先进过程控制系统的经验，自主开发锌冶炼焙烧制酸工序的先进过程控制系统，建立冶金数学模型，实现业主方面提出的焙烧炉投矿智能化控制要求。 针对恩菲可自主开发的设备管理系统、物流管理系统，组织人员进行集中编程开发，经过测试后上线发布，请紫金方面进行使用，结合业主方面意见不断优化改进。 MES系统中恩菲不擅长的子系统，积极联系第三方进行合作开发，恩菲方面提出具体需求，由第三方进行编程开发，测试。恩菲进行最后验收。 整体技术方案撰写，结合项目实际，编写适合新疆紫金有色的三化建设方案，落实到各系统的功能、建设步骤、投资及硬件需求。重点关注网络架构、数据架构及应用架构。  人员安排： 部门/专业\t主体参与人员\t备注\n1\t主体工艺\t陈向强、王鸿振、张官祥\t2\t仪表\t薛昊洋、杨扬\t3\t编程开发\t张官祥\t部分外委\n4\t网络运维\t赵学宸\n主要创新点： （研究成果整体或其中某项具体工艺技术、装备的先进性、特点）\n 自主开发锌冶炼焙烧制酸工序等核心工艺过程的先进过程控制系统，实现锌冶炼过程的数模控制。 开发应用有色行业锌冶炼企业的MES系统，自主开发生产核心相关的设备管理系统、物流管理系统等。  三、考核指标及可视成果 考核指标： （尽量有量化指标，或通过专家论证、工程应用验证等）\n 先进过程控制系统、设备管理系统、物流管理系统上线发布并投入使用，满足业主方需求。 新疆紫金有色认可同意技术方案，签订市场合同或合作开发协议。  可视成果：  先进过程控制系统、设备管理系统、物流管理系统软件。 新疆紫金有色金属有限公司生产系统“三化”建设技术方案书。 形成一个恩菲特色智能冶炼方案规划，数个自主开发的核心系统应用。 形成以恩菲为中心的MES系统开发团队及合作方的人才队伍。 恩菲智能冶炼理念及建设方案动画演示视频。  四、技术难点及解决方案 1．MES系统中包含子系统大部分都是基础通用性功能模块，如化验分析系统、质量管理系统等，是MES标准组成，恩菲缺乏IT技术人才，没有自主开发的能立，通过合同外包或合作解决。\n五、技术风险分析 三化建设涉及专业有化工、仪表、冶炼、计算机等等，业务分散在不同部分，需要结合课题多位专业人员丰富的研发、工程经验，通过相关技术攻关可有效规避技术风险并缩短系统研发时间。\n","description":"","id":23,"section":"sf","tags":null,"title":"恩菲有色冶炼云平台建设及智能冶炼关键技术研发","uri":"http://austinzgx.github.io/sf/%E4%BA%91%E5%B9%B3%E5%8F%B0%E7%AB%8B%E9%A1%B9/"},{"content":"定义  工业大数据是指在工业领域中，围绕典型智能制造模式，从客户需求到销售、\n订单、计划、研发、设计、工艺、制造、采购、供应、库存、发货和交付、售后\n服务、运维、报废或回收再制造等整个产品全生命周期各个环节所产生的各类数\n据及相关技术和应用的总称。工业大数据以产品数据为核心，极大延展了传统工\n业数据范围，同时还包括工业大数据相关技术和应用。\n 双重属性  价值属性 产权属性  数据来源  企业运营管理相关的业务数据 制造过程数据 企业外部数据  智能制造标准  平台建设的要求、运维和检测评估等工业大数据平台标准 工业大数据采集、预处理、分析、可视化和访问等数据处理标准 数据质量、数据管理能力等数据管理标准 工厂内部数据共享、工厂外部数据交换等数据流通标准  工业互联网标准  工业数据交换标准，用于规范工业互联网平台内不同系统之间数据交换体系架构、互操作、性能等要求； 工业数据分析与系统标准，用于规范工业互联网数据分析的流程及方法； 工业数据管理标准，用于规范工业互联网数据的存储结构、数据字典、元数据、数据质量要求、数据生命周期管理、数据管理能力成熟度等要求； 工业数据建模标准，用于规范物理实体（在制品、设备、产线、产品等）在网络空间中的映像及相互关系； 工业大数据服务标准，用于规范工业互联网平台运用大数据能力对外提供的服务，包括大数据存储服务、大数据分析服务、大数据可视化服务、数据建模及数据开放、数据共享等相关标准。  应用架构图  系统协调者  规范和集成各类所需的数据应用活动\n  数据提供者  将原始数据收集起来经过预处理提供给工业大数据应用提供者\n  工业大数据应用提供者  围绕数据消费者需求，将来自数据提供者的数据进行处理和提取，提供给数据消费者，主要包括收集、预处理、分析、可视化和访问\n  大数据框架提供者  为工业大数据应用提供者在创建具体应用时提供使用的资源和服务，包括基础设施、平台、处理框架、信息交互/通信、资源管理\n  数据消费者  通过调用工业大数据应用提供者提供的接口按需访问信息，并进行加工处理，以达到特定的目标。包括智能化设计、智能化生产、网络化协同制造、 智能化服务、个性化定制\n  安全与隐私  实现覆盖硬件、软件和上层应用的安全保护。包含网络安全、主机安全、应用安全、数据安全\n  管理  一是提供大规模集群统一的运维管理系统，能够对包括数据中心、基础硬件、平台软件和应用软件进行集中运维、统一管理，实现安装部署、参数配置、监控、告警、用户管理、权限管理、审计、服务管理、健康检查、问题定位、升级和补丁等功能。 二是具有自动化运维的能力，通过对多个数据中心的资源进行统一管理，合理的分配和调度业务所需要的资源，做到自动化按需分配。 三是对主管理系统节点及所有业务组件中心管理节点实现高可靠性的双机机制，采用主备或负荷分担配置，避免单点故障场景对系统可靠性的影响。    技术架构   数据采集层\n 包括时序数据采集与治理、结构化数据采集与治理和非结构化数据采集与实时处理。海量工业时序数据具有 7*24 小时持续发送，存在峰值和滞后等波动，质量问题突出等特点。需要构建前置性数据治理组件与高性能时序数据采集系统。针对结构化与非结构化数据，需要构建同时兼顾可扩展性和处理性能的数据采集系统。数据采集层的数据源主要包括通过ETL 方式同步的企业生产经营相关的业务数据、实时或批量采集的设备物联数据和从外部获取的第三方数据。\n  以传感器为主要采集工具，结合 RFID、条码扫描器、生产和监测设备、PDA、人机交互、智能终端等手段采集制造领域多源、异构数据信息，并通过互联网或现场总线等技术实现原始数据的实时准确传输。 工业大数据的采集主要是通过 PLC、SCADA、DCS 等系统从机器设备实时采集数据，也可以通过数据交换接口从实时数据库等系统以透传或批量同步的方式获取物联网数据。同时还需要从业务系统的关系型数据库、文件系统中采集所需的结构化与非结构化业务数据      数据存储与管理层\n 包括大数据存储技术和管理功能。利用大数据分布式存储的技术，构建在性能和容量都能线性扩展的时序数据存储、结构化数据存储和非结构化数据存储等。基于以上存储技术并结合工业大数据在数据建模、资产沉淀、开放共享等方面的特殊需求，构建数据模型管理、数据质量管理、数据资产管理、数据安全管理和数据共享管理技术体系。\n  多源异构数据管理技术  从系统角度，针对工业领域涉及的数据在不同阶段、不同流程呈现多种模态（关系、图、键值、时序、非结构化）的特点，研制不同的数据管理引擎致力于对多源异构数据进行高效地采集、存储和管理   多模态数据集成技术  数据集成的核心任务是要将互相关联的多模态数据集成到一起，使用户能够以透明的方式访问这些数据源        数据分析层\n 包括基础大数据计算技术和大数据分析服务功能，其中基础大数据计算技术包括并行计算技术、流计算技术和数据科学计算技术。在此之上构建完善的大数据分析服务功能来管理和调度工业大数据分析，通过数据建模、数据计算、数据分析形成知识积累，以实现工业大数据面向生产过程智能化、产品智能化、新业态新模式智能化、管理智能化以及服务智能化等领域的数据分析. 大数据分析服务功能包括分析模型管理、可视化编排、分析作业管理、工业专用/通用算法库和分析服务发布。\n  工业数据的分析需要融合工业机理模型，以“数据驱动+机理驱动”的双驱动模式来进行工业大数据的分析，从而建立高精度、高可靠性的模型来真正解决实际的工业问题 时序模式分析技术 工业知识图谱技术 多源数据融合分析技术      数据服务层\n 利用工业大数据技术对外提供服务的功能层。包括数据访问服务和数据分析服务。其中数据访问服务对外提供大数据平台内所有原始数据、加工数据和分析结果数据的服务化访问接口和功能；数据分析服务对外提供大数据平台上积累的实时流处理模型、机理模型、统计模型和机器学习模型的服务化接口。数据服务层提供平台各类数据源与外界系统和应用程序的访问共享接口，其目标是实现工业大数据平台的各类原始、加工和分析结果数据与数据应用和外部系统的对接集成。\n   数据应用层\n 主要面向工业大数据的应用技术，包括数据可视化技术和数据应用开发技术。综合原始数据、加工数据和分析结果数据，通过可视化技术，将多来源、多层次、多维度数据以更为直观简洁的方式展示出来，易于用户理解分析，提高决策效率。综合利用微服务开发框架和移动应用开发工具等，基于工业大数据管理、分析技术快速实现工业大数据应用的开发与迭代，构建面向实际业务需求的，数据驱动的工业大数据应用，实现提质降本与增效。数据应用层通过生成可视化、告警、预测决策、控制等不同的应用，从而实现智能化设计、智能化生产、网络化协同制造、智能化服务和个性化定制等典型的智能制造模式，并将结果以规范化数据形式存储下来，最终构成从生产物联设备层级到控制系统层级、车间生产管理层级、企业经营层级、产业链上企业协同运营管理的持续优化闭环。\n   ","description":"","id":24,"section":"sf","tags":null,"title":"工业大数据白皮书 2019版","uri":"http://austinzgx.github.io/sf/%E5%B7%A5%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"content":"安装工具  Nodejs npm Angular CLI   npm install -g @angular/cli\n 项目建立 ng new blog-client\ncd my-app\nng serve –open (aliasng serve -o)\n 常用命令  --dry-run (alias: -d) : Run through without making any changes. --style less : The file extension to be used for style files.    NG-ZORRO ng add ng-zorro-antd\n","description":"","id":25,"section":"code","tags":null,"title":"01_项目创建","uri":"http://austinzgx.github.io/code/angular/angular_01_%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"content":"项目创建  ASP .NET Core Web Application 设置为Blog.Api 选择Empty+No Authentication 添加.NET Core类库，Blog.Core + Blog.Infrastructure  Infrastructure 依赖 Core Api 依赖 Infrastructure + Core    Program + Startup Program进行基础设施的配置，很少发生变化\n HTTP Server 集成 IIS 配置信息来源  Startup 配置自定义行为，可能经常发生变化\n 组件 服务 功能 中间件管道  Startup.cs\n  ConfigureServices 所有程序级的依赖项都可以在这里注册到默认的IoC容器里, 把它们添加到IServiceCollection即可\n  Configure 配置应该遵循Add/Use的风格样式, 首先定义需要什么, 然后定义如何使用它.是真正负责配置HTTP请求管道的方法, 并且运行时也需要它\n  基础配置 运行时环境 ASPNETCORE_ENVIRONMENT\n ASP.NET Core还允许我们按约定为指定环境建立单独的启动配置. 启动类可以通过这个函数定义UseStartup(startupAssemblyName: xxx); 运行时会在这个指定的组件查找叫做Startup, Startup[环境名]的类, 其中[环境名]就是ASPNETCORE_ENVIRONMENT这个环境变量的值. 如果能找到指定环境的类, 那么它将覆盖默认的启动类.\n  例如:环境变量值如果是Development的话, 那么运行时就会尝试寻找Startup和StartupDevelopment类, 该约定在启动类里面的方法名上也有效, 环境特定的启动类里的两个方法分别是 Configure[环境名]和Configure[环境名]Services.\n  ASPNETCORE_ENVIRONMENT环境变量 Production Development Staging 没有设置则使用Production\n 1 2 3 4 5  public static IWebHostBuilder CreateWebHostBuilder(string[] args) =\u0026gt; WebHost.CreateDefaultBuilder(args) //.UseStartup\u0026lt;Startup\u0026gt;();  .UseStartup(typeof(StartupDevelopment).GetTypeInfo().Assembly.FullName);   HTTPS\n 微软建议所有应用调用HTTPS重定向中间件，来把所有的HTTP请求重定向为HTTPS Startup：  ConfigureServices方法注册，并配置端口及状态码 Configure方法使用该中间件： app.UseHttpsRedirection()    1 2 3 4 5  services.AddHttpsRedirection(options =\u0026gt; { options.RedirectStatusCode = StatusCodes.Status307TemporaryRedirect; options.HttpsPort = 5001; });   HSTS （HTTP Strict Transport Sercurity Protocol）\n 微软建议在生产环境(production)下启用HSTS Startup：\n* ConfigureServices方法注册并配置 HSTS * Configure方法使用该中间件： app.UseHsts()  1 2 3 4 5 6 7 8 9  //HSTS 只配置在生产环境 services.AddHsts(options =\u0026gt; { options.Preload = true; options.IncludeSubDomains = true; options.MaxAge = TimeSpan.FromDays(60); options.ExcludedHosts.Add(\u0026#34;example.com\u0026#34;); options.ExcludedHosts.Add(\u0026#34;www.example.com\u0026#34;); });   launchSettings.json\n 开发时只保留console,其余删除  1 2 3 4 5 6 7 8 9 10 11 12 13  { \u0026#34;profiles\u0026#34;: { \u0026#34;Blog.Api\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;Project\u0026#34;, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;launchUrl\u0026#34;: \u0026#34;http://localhost:5000/api/posts\u0026#34;, \u0026#34;applicationUrl\u0026#34;: \u0026#34;https://localhost:5001;http://localhost:5000\u0026#34;, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Development\u0026#34; } } } }   ","description":"","id":26,"section":"code","tags":null,"title":"01_项目创建及基础配置","uri":"http://austinzgx.github.io/code/dotnetcore/01%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"},{"content":"建立和注册Context  安装包 \u0026raquo;\u0026gt; Infrastructure项目   Microsoft.EntityFrameworkCore.Design Microsoft.EntityFrameworkCore.[Sqlite][SqlServer][MySql]\ndotnet add package Microsoft.EntityFrameworkCore.SqlServer\nInstall-Package Microsoft.EntityFrameworkCore.SqlServer  建立Context   Entities \u0026raquo;\u0026gt; Core项目  1 2 3 4 5 6 7 8  public class Post : Entity { // public int Id { get; set; }  public string Title { get; set; } public string Body { get; set; } public string Author { get; set; } public DateTime LastModified { get; set; } }    Context:DbContext \u0026raquo;\u0026gt;Infrastructure项目  1 2 3 4 5 6 7  public class ApplicationContext:DbContext { public ApplicationContext(DbContextOptions\u0026lt;ApplicationContext\u0026gt; options):base(options) { } public DbSet\u0026lt;Post\u0026gt; Posts { get; set; } }   Startup里注册Context  1 2 3 4 5 6 7  //注册Dbcontxt  services.AddDbContext\u0026lt;ApplicationContext\u0026gt;(options =\u0026gt; { //var contectionString = \u0026#34;Data Source = localhost; Database = Blog.db; User = sa; Password = password\u0026#34;;  var contectionString = \u0026#34;Data Source = .;Database = Blog.db;Integrated Security=True\u0026#34;; options.UseSqlServer(contectionString); });   数据库迁移   快速调出package manager console Alt + T N O add-migration [Name] update-database\n  添加种子数据   Seed.cs  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  public class Seed { public static async Task SeedAsync(ApplicationContext applicationContext, ILoggerFactory loggerFactory, int retry = 0) { int retryForAvailability = retry; try { // TODO: Only run this if using a real database  // myContext.Database.Migrate();  if (!applicationContext.Posts.Any()) { applicationContext.Posts.AddRange( new List\u0026lt;Post\u0026gt;{ new Post{ Title = \u0026#34;Post Title 1\u0026#34;, Body = \u0026#34;Post Body 1\u0026#34;, Author = \u0026#34;Dave\u0026#34;, LastModified = DateTime.Now }, new Post{ Title = \u0026#34;Post Title 2\u0026#34;, Body = \u0026#34;Post Body 2\u0026#34;, Author = \u0026#34;Dave\u0026#34;, LastModified = DateTime.Now }, new Post{ Title = \u0026#34;Post Title 3\u0026#34;, Body = \u0026#34;Post Body 3\u0026#34;, Author = \u0026#34;Dave\u0026#34;, LastModified = DateTime.Now }, new Post{ Title = \u0026#34;Post Title 4\u0026#34;, Body = \u0026#34;Post Body 4\u0026#34;, Author = \u0026#34;Dave\u0026#34;, LastModified = DateTime.Now }, new Post{ Title = \u0026#34;Post Title 5\u0026#34;, Body = \u0026#34;Post Body 5\u0026#34;, Author = \u0026#34;Dave\u0026#34;, LastModified = DateTime.Now }, new Post{ Title = \u0026#34;Post Title 6\u0026#34;, Body = \u0026#34;Post Body 6\u0026#34;, Author = \u0026#34;Dave\u0026#34;, LastModified = DateTime.Now }, new Post{ Title = \u0026#34;Post Title 7\u0026#34;, Body = \u0026#34;Post Body 7\u0026#34;, Author = \u0026#34;Dave\u0026#34;, LastModified = DateTime.Now }, new Post{ Title = \u0026#34;Post Title 8\u0026#34;, Body = \u0026#34;Post Body 8\u0026#34;, Author = \u0026#34;Dave\u0026#34;, LastModified = DateTime.Now } } ); await applicationContext.SaveChangesAsync(); } } catch (Exception ex) { if (retryForAvailability \u0026lt; 10) { retryForAvailability++; var logger = loggerFactory.CreateLogger\u0026lt;Seed\u0026gt;(); logger.LogError(ex.Message); await SeedAsync(applicationContext, loggerFactory, retryForAvailability); } } } }    Program中调用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public static void Main(string[] args) { var host = CreateWebHostBuilder(args).Build(); using (var scope = host.Services.CreateScope()) { var services = scope.ServiceProvider; var loggerFactory = services.GetRequiredService\u0026lt;ILoggerFactory\u0026gt;(); try { var applicationContext = services.GetRequiredService\u0026lt;ApplicationContext\u0026gt;(); //调用方法创建种子数据  Seed.SeedAsync(applicationContext, loggerFactory).Wait(); } catch (Exception e) { var logger = loggerFactory.CreateLogger\u0026lt;Program\u0026gt;(); logger.LogError(e, \u0026#34;Error occured seeding the Database.\u0026#34;); } } host.Run(); }    添加PostController  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  [Route(\u0026#34;api/posts\u0026#34;)] public class PostController : Controller { private readonly ApplicationContext _applicationContext; public PostController(ApplicationContext applicationContext) { _applicationContext = applicationContext; } [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get() { var posts = await _applicationContext.Posts.ToListAsync(); return Ok(posts); } }    成功\n  Repository 仓储服务 与持久化技术无关(使用其他Drapper等替代EF Core)、易于测试、代码重用\nIRepository接口：依赖注入、松耦合、DIP原则、易于测试\n 注入的是接口，而不是具体的类。如果注入Repository这个类，Controller就依赖了Repository，这样就是高级别模块依赖了低级别模块，违反了DIP原则! 应该都依赖于抽象IRepository接口。   IRepository \u0026raquo;\u0026gt; Core.Interface  1 2 3 4  public interface IPostRepository { Task\u0026lt;IEnumerable\u0026lt;Post\u0026gt;\u0026gt; GetAllPostsAsync(); }   Repository \u0026raquo;\u0026gt; Infrastructure.Repositories  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class PostRepository : IPostRepository { //注入DbContext  private readonly ApplicationContext _applicationContext; public PostRepository(ApplicationContext applicationContext) { _applicationContext = applicationContext; } public async Task\u0026lt;IEnumerable\u0026lt;Post\u0026gt;\u0026gt; GetAllPostsAsync() { return await _applicationContext.Posts.ToListAsync(); } }   Startup中注册服务  1 2  //注册仓储服务  services.AddScoped\u0026lt;IPostRepository, PostRepository\u0026gt;();    服务注册生命周期  Transient: 每次其它的类请求（不是指HTTP Request）都会创建一个新的实例，它比较适合轻量级的无状态的（Stateless）的service. Scope: 每次HTTP请求会创建一个实例。 Singleton: 在第一次请求的时候就会创建一个实例，以后也只有这一个实例; 或者在ConfigureServices这段代码运行的时候创建唯一一个实例。    修改Controller,注入Repository  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  [Route(\u0026#34;api/posts\u0026#34;)] public class PostController : Controller { private readonly IPostRepository _postRepository; public PostController(IPostRepository postRepository) { _postRepository = postRepository; } [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get() { var posts = await _postRepository.GetAllPostsAsync(); return Ok(posts); } }   Unit of Work 仓储服务  IUntiOfWork \u0026raquo;\u0026gt; Core.Interface  1 2 3 4  public interface IUnitOfWork { Task\u0026lt;bool\u0026gt; SaveAsync(); }   UnitOfWork \u0026raquo;\u0026gt; Infrastructure.Database  1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class UnitOfWork : IUnitOfWork { private readonly ApplicationContext _applicationContext; public UnitOfWork(ApplicationContext applicationContext) { _applicationContext = applicationContext; } public async Task\u0026lt;bool\u0026gt; SaveAsync() { return await _applicationContext.SaveChangesAsync() \u0026gt; 0; } }   Startup中注册服务  1 2  //注册仓储服务  services.AddScoped\u0026lt;IUnitOfWork , UnitOfWork \u0026gt;();   Repository添加AddPost方法  1 2 3 4  public void AddPost(Post post) { _applicationContext.Posts.Add(post); }   修改controller, 注入IUnitOfWork, Post()方法中调用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  [Route(\u0026#34;api/posts\u0026#34;)] public class PostController : Controller { private readonly IPostRepository _postRepository; private readonly IUnitOfWork _unitOfWork; public PostController( IPostRepository postRepository, IUnitOfWork unitOfWork) { _postRepository = postRepository; _unitOfWork = unitOfWork; } [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get() { var posts = await _postRepository.GetAllPostsAsync(); return Ok(posts); } [HttpPost] public async Task\u0026lt;IActionResult\u0026gt; Post() { var newPost = new Post { Title = \u0026#34;ENFI\u0026#34;, Author = \u0026#34;ZGX\u0026#34;, Body = \u0026#34;adskfasdjfladsjfa;ldsfads\u0026#34;, LastModified = DateTime.Now }; _postRepository.AddPost(newPost); await _unitOfWork.SaveAsync(); return Ok(); } }   Entity约束  PostConfiguration.cs \u0026raquo;\u0026gt; Infrastructure.EntityConfiguration  1 2 3 4 5 6 7 8 9  public class PostConfiguration : IEntityTypeConfiguration\u0026lt;Post\u0026gt; { public void Configure(EntityTypeBuilder\u0026lt;Post\u0026gt; builder) { builder.Property(x =\u0026gt; x.Author).IsRequired().HasMaxLength(50); builder.Property(x =\u0026gt; x.Title).IsRequired().HasMaxLength(100); builder.Property(x =\u0026gt; x.Body).IsRequired().HasColumnType(\u0026#34;nvarchar(max)\u0026#34;); } }   DbContext中重写OnModel  1 2 3 4 5  protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); modelBuilder.ApplyConfiguration(new PostConfiguration()); }   ","description":"","id":27,"section":"code","tags":null,"title":"02_集成EFCore","uri":"http://austinzgx.github.io/code/dotnetcore/02%E9%9B%86%E6%88%90efcore/"},{"content":"Log  默认自带log \u0026raquo;\u0026gt;Program  1  WebHost.CreateDefaultBuilder()中做了默认配置   2. Log API\nASP .NET Core 提供了一套Log API, 它可以各种各样的Log提供商配合使用. http://www.cnblogs.com/cgzl/p/9019314.html\n内置6个Log提供商:\n Console Debug EventSource EventLog TraceSource Azure App Service\n第三方提供商： Nlog Serilog  ILogger接口  创建ILogger的时候指明分类，分类名约定是调用类的全名(string) PostController例如：\n依赖注入ILogger\u0026lt;TCategoryName\u0026gt;\n 在ILoggerFactory 上调用CreateLogger方法时可以指定分类的名称.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  [Route(\u0026#34;api/posts\u0026#34;)] public class PostController : Controller { private readonly IPostRepository _postRepository; private readonly IUnitOfWork _unitOfWork; private readonly ILogger _logger; public PostController( IPostRepository postRepository, IUnitOfWork unitOfWork, ILoggerFactory loggerFactory) { _postRepository = postRepository; _unitOfWork = unitOfWork; _logger = loggerFactory.CreateLogger(\u0026#34;Blog.Api.Controllers.PostController\u0026#34;); } [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get() { var posts = await _postRepository.GetAllPostsAsync(); _logger.LogError(\u0026#34;Get All Posts ......\u0026#34;); return Ok(posts); }   ILogger其他  级别  LogTrace(), 0，记录追踪信息 LogDebug(), 1，记录调试信息 LogInformation(), 2，记录信息性的事情 LogWarning(), 3，记录警告信息 LogError(), 4，记录异常 LogCritical(), 5，用来记录严重的事情   Event ID 信息模板 异常 过滤 作用范围\n……  添加Serilog  安装包\nInstall-Package Serilog\nInstall-Package Serilog.AspNetCore\nSinks日志输出媒介(控制台、文件、sqlserver等）\nInstall-Package Serilog.Sinks.Console\nInstall-Package Serilog.Sinks.File\n… Main()中配置  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  public static void Main(string[] args) { //配置Serilog  Log.Logger = new LoggerConfiguration() //最低输出级别为Debug  .MinimumLevel.Debug() //以Microsoft开头的特殊,调整最小级别为Information  .MinimumLevel.Override(\u0026#34;Microsoft\u0026#34;, LogEventLevel.Information) .Enrich.FromLogContext() .WriteTo.Console() .WriteTo.File(Path.Combine(\u0026#34;logs\u0026#34;, @\u0026#34;log.txt\u0026#34;), rollingInterval: RollingInterval.Day) .CreateLogger(); var host = CreateWebHostBuilder(args).Build(); //种子文件  using (var scope = host.Services.CreateScope()) { var services = scope.ServiceProvider; var loggerFactory = services.GetRequiredService\u0026lt;ILoggerFactory\u0026gt;(); try { var applicationContext = services.GetRequiredService\u0026lt;ApplicationContext\u0026gt;(); //调用方法创建种子数据  Seed.SeedAsync(applicationContext, loggerFactory).Wait(); } catch (Exception e) { var logger = loggerFactory.CreateLogger\u0026lt;Program\u0026gt;(); logger.LogError(e, \u0026#34;Error occured seeding the Database.\u0026#34;); } } host.Run(); } public static IWebHostBuilder CreateWebHostBuilder(string[] args) =\u0026gt; WebHost.CreateDefaultBuilder(args) //.UseStartup\u0026lt;Startup\u0026gt;();  .UseStartup(typeof(StartupDevelopment).GetTypeInfo().Assembly.FullName) .UseSerilog(); //调用Serilog,覆盖掉CreateDefaultBuilder中的默认配置  }   ","description":"","id":28,"section":"code","tags":null,"title":"03_日志","uri":"http://austinzgx.github.io/code/dotnetcore/03%E6%97%A5%E5%BF%97logger/"},{"content":" 配置提供商  文件格式(INI, JSON, XML) 命令行参数 环境变量 内存中的.NET对象 未加密的Secret管理存储 加密的用户存储, 例如Azure秘钥库 自定义的提供商   JSON配置文件  默认 appsettings.json 注意：后加载的值会覆盖。\n 取得配置  IConfiguration[“Key:ChildKey”] 针对”ConnectionStrings:xxx”, 可以使用IConfiguration. GetConnectionString(“xxx”)      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public static IConfiguration Configuration; public StartupDevelopment(IConfiguration configuration) { Configuration = configuration; } public void ConfigureServices(IServiceCollection services) { services.AddMvc(); //注册Dbcontxt  services.AddDbContext\u0026lt;ApplicationContext\u0026gt;(options =\u0026gt; { //var connectionString = \u0026#34;Data Source = 10.30.0.14; Database = Blog.db; User = sa; Password = Hello,MMOC\u0026#34;;  //var connectionString = \u0026#34;Data Source = .;Database = Blog.db;Integrated Security=True\u0026#34;;  //var connectionString = Configuration[\u0026#34;ConnectionStrings:DefaultConnection\u0026#34;];  var connectionString = Configuration.GetConnectionString(\u0026#34;DefaultConnection\u0026#34;); options.UseSqlServer(connectionString); }); ... }    其他文件配置\nConfigurationBuilder().AddJsonFile(\u0026ldquo;appsettings.json\u0026rdquo;).Build() 返回IConfigurationRoot，继承于IConfiguration. 使用接口IConfiguration即可。  ","description":"","id":29,"section":"code","tags":null,"title":"04_项目配置","uri":"http://austinzgx.github.io/code/dotnetcore/04%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/"},{"content":"默认异常处理 1  app.UseDeveloperExceptionPage();   自定义异常处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public static class ExceptionHandlingExtensions { public static void UseMyExceptionHandler(this IApplicationBuilder app,ILoggerFactory loggerFactory) { app.UseExceptionHandler(build =\u0026gt; { build.Run(async context =\u0026gt; { context.Response.StatusCode = StatusCodes.Status500InternalServerError; context.Response.ContentType = \u0026#34;application/json\u0026#34;; var ex = context.Features.Get\u0026lt;IExceptionHandlerFeature\u0026gt;(); if (ex != null) { var logger = loggerFactory.CreateLogger(\u0026#34;Blog.Api.Extensions.ExceptionHandlingExtensions\u0026#34;); logger.LogError(500, ex.Error, ex.Error.Message); } await context.Response.WriteAsync(ex?.Error?.Message ?? \u0026#34;An Error Occurred.\u0026#34;); }); }); } }   1 2 3 4 5 6  public void Configure(IApplicationBuilder app,ILoggerFactory loggerFactory) { app.UseMyExceptionHandler(loggerFactory); app.UseHttpsRedirection(); app.UseMvc(); }   ","description":"","id":30,"section":"code","tags":null,"title":"05_异常处理","uri":"http://austinzgx.github.io/code/dotnetcore/05%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"content":"API 不应直接返回Entity  * Entity/Domain Model是内部实现细节 * 合约/接口界面  API应返回另外一个类（资源 Resource）  与Entity可能很像. 独立于Entity, 单独进化和改变. 也可以叫做ViewModel, Dto  Entity与Resoucre之间映射[AutoMapper]  安装Nuget包:\nAutoMapper\nAutoMapper.Extensions.Microsoft.DependencyInjection \u0026raquo;\u0026gt; API 配置映射\n可以创建Profile\nCreateMap\u0026lt;TSource, TDestination\u0026gt;()  1 2 3 4 5 6 7 8 9  public class MappingProfile:Profile { public MappingProfile() { CreateMap\u0026lt;Post, PostResource\u0026gt;() .ForMember(dest =\u0026gt; dest.UpdateTime, opt =\u0026gt; opt.MapFrom(src =\u0026gt; src.LastModified)); CreateMap\u0026lt;PostResource,Post\u0026gt;(); } }    services.AddAutoMapper() 依赖注入AutoMapper  1 2 3 4 5 6 7  [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get() { var posts = await _postRepository.GetAllPostsAsync(); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;,IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(posts); return Ok(postResources); }   ","description":"","id":31,"section":"code","tags":null,"title":"06_ResourceModel","uri":"http://austinzgx.github.io/code/dotnetcore/06resourcemodel/"},{"content":"属性标签 https://docs.microsoft.com/zh-cn/aspnet/core/mvc/models/validation?view=aspnetcore-2.1\n [CreditCard]：验证属性是否具有信用卡格式。 [Compare]：验证某个模型中的两个属性是否匹配。 [EmailAddress]：验证属性是否具有电子邮件格式。 [Phone]：验证属性是否具有电话格式。 [Range]：验证属性值是否落在给定范围内。 [RegularExpression]：验证数据是否与指定的正则表达式匹配。 [Required]：将属性设置为必需属性。 [StringLength]：验证字符串属性是否最多具有给定的最大长度。 [Url]：验证属性是否具有 URL 格式。  FluentValidation  验证逻辑与业务逻辑分离 灵活, 功能强大\nFluent API, Lambda表达式 安装Nuget包:\nFluentValidation\nFluentValidation.AspNetCore 为Resource配置验证器\n继承于AbstractValidator  1 2 3 4 5 6 7 8 9 10 11 12  public class PostResourceValidator:AbstractValidator\u0026lt;PostResource\u0026gt; { public PostResourceValidator() { RuleFor(x =\u0026gt; x.Author) .NotNull() .WithName(\u0026#34;作者\u0026#34;) .WithMessage(\u0026#34;{PropertyName}是必填的\u0026#34;) .MaximumLength(20) .WithMessage(\u0026#34;{PropertyName}的最大长度是{MaxLength}\u0026#34;); } }   注册到容器: services.AddTransient\u0026lt;\u0026gt;()  1 2  //注册FluentValidator  services.AddTransient\u0026lt;IValidator\u0026lt;PostResource\u0026gt;, PostResourceValidator\u0026gt;();   ","description":"","id":32,"section":"code","tags":null,"title":"07_模型验证","uri":"http://austinzgx.github.io/code/dotnetcore/07%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81/"},{"content":"什么是REST REST 是 Representational State Transfer 的缩写. 它是一种架构的风格, 这种风格基于一套预定义的规则, 这些规则描述了网络资源是如何定义和寻址的.\n一个实现了REST这些规则的服务就叫做RESTful的服务.\nREST的原则/约束 REST有6大原则/约束, 每一个原则都是对API有正面或负面影响的设计决定.\nRESTful API 最关心的有这几方面: 性能, 可扩展性, 简洁性, 互操作性, 通讯可见性, 组件便携性和可靠性.\n这些方面被封装在REST的6个原则里, 它们是:\n 客服端-服务端约束: 客户端和服务端是分离的, 它们可以独自的进化. 无状态: 客户端和服务段的通信必须是无状态的, 状态应包含在请求里的. 也就是说请求里要包含服务端需要的所有的信息, 以便服务端可以理解请求并可以创造上下文. 分层系统: 就像其它的软件架构一样, REST也需要分层结构, 但是不允许某层直接访问不相邻的层. 统一接口: 这里分为4点, 他们是: 资源标识符(URI), 资源的操作(也就是方法Method, HTTP动词), 自描述的响应(可以认为是媒体类型Media-Type), 以及状态管理(超媒体作为应用状态的引擎 HATEOAS, Hypermedia as the Engine of Application State). 缓存: 缓存约束派生于无状态约束, 它要求从服务端返回的响应必须明确表明是可缓存的还是不可缓存的. 按需编码: 这允许客户端可以从服务端访问特定的资源而无须知晓如何处理它们. 服务端可以扩展或自定义客户端的功能.  只有满足了这6个原则的系统才可以真正称得上是RESTful的, 其实大部分系统的RESTful API并不是RESTful的, 但这样并不代表这些API就不好, 利弊需要开发人员去衡量.\nRichardson 成熟度模型 Richardson 成熟度模型代表着你的API是否足够成熟, 分为4个级别, 0代表最差, 3代表最好.\n  0级, Plain Old XML沼泽:\n这里HTTP协议只是被用来进行远程交互, 协议的其余部分都用错了, 都是RPC风格的实现(例如SOAP, 尤其是使用WCF的时候).\n例如:\nPOST (查询数据信息)\nhttp://host/myapi\nPOST (创建数据)\nhttp://host/myapi\n  1级, 资源:\n这级里, 每个资源都映射到一个URI上了, 但是HTTP方法并没有正确的使用, 结果的复杂度不算太高.\n例如这两个查询:\nPOST\nhttp://host/api/authors\nPOST\nhttp://host/api/authors/{id}\n  2级, 动词:\n正确使用了HTTP动词, 状态码也正确的使用了, 同时也去掉了不必要的变种.\n例如:\nGET\nhttp://host/api/authors\nOk (authors)\nPOST (author representation)\nhttp://host/api/authors\nCreated (author)\n  3级, 超媒体:\nAPI支持超媒体作为应用状态的引擎 HATEOAS, Hypermedia as the Engine of Application State, 引入了可发现性.\n例如:\nGET\nhttp://host/api/authors\n200 Ok (返回了authors 和 驱动应用程序的超链接)\n  API 资源命名  资源应该使用名词, 它是个东西, 不是动作\nGET api/users 就是正确的\nGET api/users/{userId}. 层次结构\n例如 api/department/{departmentId}/emoloyees, 这就表示了department (部门)和员工(employee)之前是主从关系.\n而 api/department/{departmentId}/emoloyees/{employeeId}, 就表示了该部门下的某个员工. 过滤排序\n过滤和排序, 不是资源, 应作为参数.例如 api/users?orderby=username ID\n资源的URI应该永远都是一样的.\n推荐GUID应该作为ID来使用.\n自增int类型的ID, 在迁移到新数据库时需要特殊设定, 保证ID值不会发生变化.  HTTP方法与资源交互 注意:\n HEAD: 和GET差不多, 但是它不应该返回响应的body, 所以没有响应的payload. 它主要使用来获取资源的一些信息, 例如查看资源是否可用等. OPTIONS: 它是用来查询某个资源URI的可交互方式有哪些, 换句话说就是, 使用它可以知道某个URI是否可以执行GET或者POST动作, 这些结果通常是在响应的Headers里面而不是body里, 所以也没有响应的payload.  状态码  状态码会告诉API的消费者:  请求是否如预期的成功，或者失败 如果出现了错误，谁该为这个错误负责   API主要用到:  200级别, 表示成功.\n* 200 - OK\n* 201 - Created，表示资源创建成功了\n* 204 - No content，成功执行，但是不应该返回任何东西 400级别, 表示客户端引起的错误.\n* 400 - Bad request，表示API的消费者发送到服务器的请求是错误的\n* 401 - Unauthorized，表示没有权限\n* 403 - Forbidden，表示用户验证成功，但是该用户仍然无法访问该资源\n* 404 - Not found，表示请求的资源不存在\n* 405 - Method not allowed，这就是当我们尝试发送请求给某个资源时，使用的HTTP方法却是不允许的，例如使用POST api/countries, 而该资源只实现了 GET，所以POST不被允许\n* 406 - Not acceptable，这里涉及到了media type，例如API消费者请求的是application/xml格式的media type，而API只支持application/json\n* 409 - Conflict，表示该请求无法完成，因为请求与当前资源的状态有冲突，例如你编辑某个资源数据以后，该资源又被其它人更新了，这时你再PUT你的数据就会出现409错误；有时也用在尝试创建资源时该资源已存在的情况。\n* 415 - Unsupported media type，这个和406正好返回来，比如说我向服务器提交数据的media type是xml的，而服务器只支持json，那么就会返回415\n* 422 - Unprocessable entity，表示请求的格式没问题，但是语义有错误，例如实体验证错误。 500级别, 表示服务器错误.\n* 500 - Internal server error，这表示是服务器发生了错误    HTTP GET  单个数据\n找到了: 200\n没找到: 404  1 2 3 4 5 6 7 8 9 10 11  [HttpGet(\u0026#34;{id}\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get(int id) { var post = await _postRepository.GetPostByIdAsync(id); if (post == null) { return NotFound();//404  } var postResource = _mapper.Map\u0026lt;Post, PostResource\u0026gt;(post); return Ok(postResource); //200  }    集合数据\n至少有一条数据, 200\n没有数据, 也是200  1 2 3 4 5 6 7  [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get() { var posts = await _postRepository.GetAllPostsAsync(); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(posts); return Ok(postResources); }   内容协商 如果资源支持多种展现格式，那么消费者可以选择它想要的格式\n 在请求的Accept Header指定Media Type\n* application/json, application/xml\n* 若未指定, 返回默认 application/json 请求的media type不可用时, 并且消费者不支持默认格式, 返回406 ASP.NET Core支持输出和输入两种格式化器.\n* 用于输出的media type放在Accept Header里, 表示客户端接受这种格式的输出.\n* 用于输入的media type放Content-Type Header里, 表示客户端传进来的数据是这种格式.\n* ReturnHttpNotAcceptable设为true, 就会返回406.  1 2 3 4 5 6  services.AddMvc( options=\u0026gt; { options.ReturnHttpNotAcceptable = true; //开启406  options.OutputFormatters.Add(new XmlDataContractSerializerOutputFormatter()); });   ","description":"","id":33,"section":"code","tags":null,"title":"08_RESTful API","uri":"http://austinzgx.github.io/code/dotnetcore/08rest/"},{"content":"翻页  Query String\nhttp://localhost:5000/api/posts?pageIndex=1\u0026amp;pageSize=10\u0026amp;orderBy=id 使用抽象父类 QueryParameters, 包含常见参数:\nPageIndex PageSize OrderBy…  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  public abstract class QueryParameters : INotifyPropertyChanged { private const int DefaultPageSize = 10; private const int DefaultMaxPageSize = 100; private int _pageIndex; public int PageIndex { get { return _pageIndex; } set { _pageIndex = value \u0026gt;= 0 ? value : 0; } } private int _pageSize; public virtual int PageSize { get { return _pageSize; } set =\u0026gt; SetField(ref _pageSize, value); } private string _orderBy; public string OrderBy { get { return _orderBy; } set { _orderBy = value ?? nameof(IEntity.Id); } } private int _maxPageSize = DefaultMaxPageSize; protected internal virtual int MaxPageSize { get { return _maxPageSize; } set =\u0026gt; SetField(ref _maxPageSize, value); } public string Fields { get; set; } public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } protected bool SetField\u0026lt;T\u0026gt;(ref T field, T value, [CallerMemberName] string propertyName = null) { if (EqualityComparer\u0026lt;T\u0026gt;.Default.Equals(field, value)) { return false; } field = value; OnPropertyChanged(propertyName); if (propertyName == nameof(PageSize) || propertyName == nameof(MaxPageSize)) { SetPageSize(); } return true; } private void SetPageSize() { if (_maxPageSize\u0026lt;=0) { _maxPageSize = DefaultMaxPageSize; } if (_pageSize\u0026lt;=0) { _pageSize = DefaultPageSize; } _pageSize = _pageSize \u0026gt; _maxPageSize ? _maxPageSize : _pageSize; } }   子类继承  1 2 3  public class PostParameters:QueryParameters { }   HTTP Get 传参  1 2 3 4 5 6 7  [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get(PostParameters postParameters) { var posts = await _postRepository.GetAllPostsAsync(postParameters); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(posts); return Ok(postResources); }   修改Repositroy  1 2 3 4 5 6 7 8 9  public async Task\u0026lt;IEnumerable\u0026lt;Post\u0026gt;\u0026gt; GetAllPostsAsync(PostParameters postParameters) { var query = _applicationContext.Posts.OrderBy(x =\u0026gt; x.Id); return await query .Skip(postParameters.PageIndex * postParameters.PageSize) .Take(postParameters.PageSize) .ToListAsync(); }   返回翻页元数据  如果将数据和翻页元数据一起返回:\n* * 响应的body不再符合Accept Header了(不是资源的application/json), 这是一种新的media type.\n* 违反REST约束, API消费者不知道如何通过application/json这个类型来解释响应的数据. 翻页数据不是资源表述的一部分, 应使用自定义Header (X-Pagination). 存放翻页数据的类: PaginatedList可以继承于List.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class PaginatedList\u0026lt;T\u0026gt;:List\u0026lt;T\u0026gt; where T:class { public int PageSize { get; set; } public int PageIndex { get; set; } private int _totalItemsCount; public int TotalItemsCount { get { return _totalItemsCount; } set { _totalItemsCount = value; } } public int PageCount =\u0026gt; TotalItemsCount / PageSize + (TotalItemsCount % PageSize \u0026gt; 0 ? 1 : 0); public bool HasPrevious =\u0026gt; PageIndex \u0026gt; 0; public bool HasNext =\u0026gt; PageIndex \u0026lt; PageCount - 1; public PaginatedList(int pageIndex,int pageSize,int totalItemsCount,IEnumerable\u0026lt;T\u0026gt; data) { PageIndex = pageIndex; PageSize = pageSize; TotalItemsCount = totalItemsCount; AddRange(data); } }   修改Repository\n1 2 3 4 5 6 7 8 9 10 11  public async Task\u0026lt;PaginatedList\u0026lt;Post\u0026gt;\u0026gt; GetAllPostsAsync(PostParameters postParameters) { var query = _applicationContext.Posts.OrderBy(x =\u0026gt; x.Id); var count = await query.CountAsync(); var data = await query .Skip(postParameters.PageIndex * postParameters.PageSize) .Take(postParameters.PageSize) .ToListAsync(); return new PaginatedList\u0026lt;Post\u0026gt;(postParameters.PageIndex, postParameters.PageSize, count, data); }   修改controller\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get(PostParameters postParameters) { var postList = await _postRepository.GetAllPostsAsync(postParameters); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(postList); var meta = new { postList.PageSize, postList.PageIndex, postList.TotalItemsCount, postList.PageCount }; Response.Headers.Add(\u0026#34;X-Pagination\u0026#34;, JsonConvert.SerializeObject(meta, new JsonSerializerSettings { //使得命名符合驼峰命名法  ContractResolver = new CamelCasePropertyNamesContractResolver() })); return Ok(postResources); }   生成前后页的URI  枚举UriType  1 2 3 4 5 6  public enum PaginationResourceUriType { CurrentPage, PreviousPage, NextPage }   注册UrlHelper  1 2 3 4 5 6 7  //注册UrlHelper services.AddSingleton\u0026lt;IActionContextAccessor, ActionContextAccessor\u0026gt;(); services.AddScoped\u0026lt;IUrlHelper\u0026gt;(factory =\u0026gt; { var actionContext = factory.GetService\u0026lt;IActionContextAccessor\u0026gt;().ActionContext; return new IUrlHelper(actionContext); });   创建CreatePostUri()方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  private string CreatePostUri(PostParameters parameters,PaginationResourceUriType uriType) { switch(uriType) { case PaginationResourceUriType.PreviousPage: var previousParameters = new { pageIndex = parameters.PageIndex - 1, pagesize = parameters.PageSize, orderBy = parameters.OrderBy, fields = parameters.Fields }; return _urlHelper.Link(\u0026#34;GetPosts\u0026#34;, previousParameters); case PaginationResourceUriType.NextPage: var nextParameters = new { pageIndex = parameters.PageIndex + 1, pagesize = parameters.PageSize, orderBy = parameters.OrderBy, fields = parameters.Fields }; return _urlHelper.Link(\u0026#34;GetPosts\u0026#34;, nextParameters); default: var currentParameters = new { pageIndex = parameters.PageIndex, pagesize = parameters.PageSize, orderBy = parameters.OrderBy, fields = parameters.Fields }; return _urlHelper.Link(\u0026#34;GetPosts\u0026#34;, currentParameters); } }   修改Get方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  [HttpGet(Name =\u0026#34;GetPosts\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get(PostParameters postParameters) { var postList = await _postRepository.GetAllPostsAsync(postParameters); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(postList); var previousPageLink = postList.HasPrevious ? CreatePostUri(postParameters, PaginationResourceUriType.PreviousPage) : null; var nextPageLink = postList.HasNext ? CreatePostUri(postParameters, PaginationResourceUriType.NextPage) : null; var meta = new { postList.PageSize, postList.PageIndex, postList.TotalItemsCount, postList.PageCount, previousPageLink, nextPageLink }; Response.Headers.Add(\u0026#34;X-Pagination\u0026#34;, JsonConvert.SerializeObject(meta, new JsonSerializerSettings { //使得命名符合驼峰命名法  ContractResolver = new CamelCasePropertyNamesContractResolver() })); return Ok(postResources); }   过滤和搜索  过滤: 对集合资源附加一些条件, 筛选出结果.\nhttp://localhost:5000/api/posts?title=China\n条件应用于Resource Model.\n过滤属性可以放在QueryParameters的子类里.  1 2 3 4  public class PostParameters:QueryParameters { public string Title { get; set; } }   修改Repository\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public async Task\u0026lt;PaginatedList\u0026lt;Post\u0026gt;\u0026gt; GetAllPostsAsync(PostParameters postParameters) { var query = _applicationContext.Posts.AsQueryable(); if (!string.IsNullOrEmpty(postParameters.Title)) { var title = postParameters.Title.ToLowerInvariant(); query = query.Where(x =\u0026gt; x.Title.ToLowerInvariant()==title); } query = query.OrderBy(x =\u0026gt; x.Id); var count = await query.CountAsync(); var data = await query .Skip(postParameters.PageIndex * postParameters.PageSize) .Take(postParameters.PageSize) .ToListAsync(); return new PaginatedList\u0026lt;Post\u0026gt;(postParameters.PageIndex, postParameters.PageSize, count, data); }    搜索: 使用关键字对集合资源进行模糊搜索.\nhttp://localhost/api/posts?searchTerm=hin  排序  问题\n翻页需要排序.\n让资源按照资源的某个属性或多个属性进行正向或反向的排序.\nResource Model的一个属性可能会映射到Entity Model的多个属性上\nResource Model上的正序可能在Entity Model上就是倒序的\n需要支持多属性的排序\n复用 安装System.Linq.Dynamic.Core 排序异常返回400BadRequest 排序思路   PropertyMappingContainer\n* PropertyMapping (PostPropertyMapping)\n* MappedProperty\n  MappedProperty 1 2 3 4 5  public class MappedProperty { public string Name { get; set; } public bool Revert { get; set; } }   PropertyMapping 1 2 3 4  public interface IPropertyMapping { Dictionary\u0026lt;string, List\u0026lt;MappedProperty\u0026gt;\u0026gt; MappingDictionary { get; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  public abstract class PropertyMapping\u0026lt;TSource,TDestination\u0026gt;:IPropertyMapping where TDestination:IEntity { //可能映射多个Entity中属性，所以使用List\u0026lt;MappedProperty\u0026gt;  public Dictionary\u0026lt;string,List\u0026lt;MappedProperty\u0026gt;\u0026gt; MappingDictionary { get; } protected PropertyMapping(Dictionary\u0026lt;string,List\u0026lt;MappedProperty\u0026gt;\u0026gt; mappingDictionary) { MappingDictionary = mappingDictionary; MappingDictionary[nameof(IEntity.Id)] = new List\u0026lt;MappedProperty\u0026gt; { new MappedProperty{Name=nameof(IEntity.Id),Revert =false} }; } }    PostPropertyMapping  1 2 3 4 5 6 7 8 9 10 11 12  public class PostPropertyMapping : PropertyMapping\u0026lt;PostResource, Post\u0026gt; { public PostPropertyMapping() : base(new Dictionary\u0026lt;string, List\u0026lt;MappedProperty\u0026gt;\u0026gt;(StringComparer.OrdinalIgnoreCase) { [nameof(PostResource.Title)] = new List\u0026lt;MappedProperty\u0026gt; { new MappedProperty { Name=nameof(Post.Title),Revert=false}}, [nameof(PostResource.Body)] = new List\u0026lt;MappedProperty\u0026gt; { new MappedProperty { Name=nameof(Post.Body),Revert=false}}, [nameof(PostResource.Author)] = new List\u0026lt;MappedProperty\u0026gt; { new MappedProperty { Name=nameof(Post.Author),Revert=false}}, }) { }   PropertyMappingContainer 1 2 3 4 5 6  public interface IPropertyMappingContainer { void Register\u0026lt;T\u0026gt;() where T : IPropertyMapping, new(); IPropertyMapping Resolve\u0026lt;TSource, TDestination\u0026gt;() where TDestination : IEntity; bool ValidateMappingExistsFor\u0026lt;TSource, TDestination\u0026gt;(string fields) where TDestination : IEntity; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  public class PropertyMappingContainer : IPropertyMappingContainer { protected internal readonly IList\u0026lt;IPropertyMapping\u0026gt; PropertyMappings = new List\u0026lt;IPropertyMapping\u0026gt;(); public void Register\u0026lt;T\u0026gt;() where T : IPropertyMapping, new() { if (PropertyMappings.All(x=\u0026gt;x.GetType()!=typeof(T))) { PropertyMappings.Add(new T()); } } //注册  public IPropertyMapping Resolve\u0026lt;TSource, TDestination\u0026gt;() where TDestination : IEntity { var matchingMapping = PropertyMappings.OfType\u0026lt;PropertyMapping\u0026lt;TSource, TDestination\u0026gt;\u0026gt;().ToList(); if (matchingMapping.Count ==1) { return matchingMapping.First(); } throw new Exception($\u0026#34;Cannot find property mapping instance for {typeof(TSource)},{typeof(TDestination)}\u0026#34;); } //验证  public bool ValidateMappingExistsFor\u0026lt;TSource, TDestination\u0026gt;(string fields) where TDestination : IEntity { var propertyMapping = Resolve\u0026lt;TSource, TDestination\u0026gt;(); if (string.IsNullOrWhiteSpace(fields)) { return false; } var fieldsAfterSplit = fields.Split(\u0026#39;,\u0026#39;); foreach (var field in fieldsAfterSplit) { var trimedField = field.Trim(); var indexOfFirstSpace = trimedField.IndexOf(\u0026#34; \u0026#34;, StringComparison.Ordinal); var propertyName = indexOfFirstSpace == -1 ? trimedField : trimedField.Remove(indexOfFirstSpace); if (string.IsNullOrWhiteSpace(propertyName)) { continue; } if (!propertyMapping.MappingDictionary.ContainsKey(propertyName)) { return false; } } return true; } }   注册服务 1 2 3 4 5 6 7  //注册排序服务  //1.新建一个容器 var propertyMappingContainer = new PropertyMappingContainer(); //2.把PostPropertyMapping注册 propertyMappingContainer.Register\u0026lt;PostPropertyMapping\u0026gt;(); //3.注册单例容器 services.AddSingleton\u0026lt;IPropertyMappingContainer\u0026gt;(propertyMappingContainer);   QueryableExtensions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95  public static class QueryableExtensions { public static IQueryable\u0026lt;T\u0026gt; ApplySort\u0026lt;T\u0026gt;(this IQueryable\u0026lt;T\u0026gt; source, string orderBy, IPropertyMapping propertyMapping) { if (source ==null) throw new ArgumentNullException(nameof(source)); if (propertyMapping == null) throw new ArgumentNullException(nameof(propertyMapping)); var mappingDictionary = propertyMapping.MappingDictionary; if (mappingDictionary ==null) throw new ArgumentNullException(nameof(mappingDictionary)); if (string.IsNullOrWhiteSpace(orderBy)) return source; var orderByAfterSplit = orderBy.Split(\u0026#39;,\u0026#39;); foreach (var orderByClause in orderByAfterSplit.Reverse()) { var trimedOrderByClause = orderByClause.Trim(); var orderDescending = trimedOrderByClause.EndsWith(\u0026#34; desc\u0026#34;); var indexOfFirstSpace = trimedOrderByClause.IndexOf(\u0026#34; \u0026#34;, StringComparison.Ordinal); var propertyName = indexOfFirstSpace == -1 ? trimedOrderByClause : trimedOrderByClause.Remove(indexOfFirstSpace); if (string.IsNullOrEmpty(propertyName)) continue; if (!mappingDictionary.TryGetValue(propertyName,out List\u0026lt;MappedProperty\u0026gt; mappedProperties)) throw new ArgumentNullException($\u0026#34;Key mapping for {propertyName} is missing\u0026#34;); if (mappedProperties == null) throw new ArgumentNullException(propertyName); mappedProperties.Reverse(); foreach (var destinationProperty in mappedProperties) { if (destinationProperty.Revert) { orderDescending = !orderDescending; } source = source.OrderBy(destinationProperty.Name + (orderDescending ? \u0026#34; descending\u0026#34; : \u0026#34; ascending\u0026#34;)); //OrderBy =====\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; System.Linq.Dynamic.Core;  } } return source; } public static IQueryable\u0026lt;object\u0026gt; ToDynamicQueryable\u0026lt;TSource\u0026gt; (this IQueryable\u0026lt;TSource\u0026gt; source, string fields, Dictionary\u0026lt;string, List\u0026lt;MappedProperty\u0026gt;\u0026gt; mappingDictionary) { if (source == null) { throw new ArgumentNullException(nameof(source)); } if (mappingDictionary == null) { throw new ArgumentNullException(nameof(mappingDictionary)); } if (string.IsNullOrWhiteSpace(fields)) { return (IQueryable\u0026lt;object\u0026gt;)source; } fields = fields.ToLower(); var fieldsAfterSplit = fields.Split(\u0026#39;,\u0026#39;).ToList(); if (!fieldsAfterSplit.Contains(\u0026#34;id\u0026#34;, StringComparer.InvariantCultureIgnoreCase)) { fieldsAfterSplit.Add(\u0026#34;id\u0026#34;); } var selectClause = \u0026#34;new (\u0026#34;; foreach (var field in fieldsAfterSplit) { var propertyName = field.Trim(); if (string.IsNullOrEmpty(propertyName)) { continue; } var key = mappingDictionary.Keys.SingleOrDefault(k =\u0026gt; String.CompareOrdinal(k.ToLower(), propertyName.ToLower()) == 0); if (string.IsNullOrEmpty(key)) { throw new ArgumentException($\u0026#34;Key mapping for {propertyName} is missing\u0026#34;); } var mappedProperties = mappingDictionary[key]; if (mappedProperties == null) { throw new ArgumentNullException(key); } foreach (var destinationProperty in mappedProperties) { selectClause += $\u0026#34; {destinationProperty.Name},\u0026#34;; } } selectClause = selectClause.Substring(0, selectClause.Length - 1) + \u0026#34;)\u0026#34;; return (IQueryable\u0026lt;object\u0026gt;)source.Select(selectClause); } }   修改Repository 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public async Task\u0026lt;PaginatedList\u0026lt;Post\u0026gt;\u0026gt; GetAllPostsAsync(PostParameters postParameters) { var query = _applicationContext.Posts.AsQueryable(); if (!string.IsNullOrEmpty(postParameters.Title)) { var title = postParameters.Title.ToLowerInvariant(); query = query.Where(x =\u0026gt; x.Title.ToLowerInvariant()==title); } //调用排序  //query = query.OrderBy(x =\u0026gt; x.Id);  query = query.ApplySort(postParameters.OrderBy, _propertyMappingContainer.Resolve\u0026lt;PostResource, Post\u0026gt;()); var count = await query.CountAsync(); var data = await query .Skip(postParameters.PageIndex * postParameters.PageSize) .Take(postParameters.PageSize) .ToListAsync(); return new PaginatedList\u0026lt;Post\u0026gt;(postParameters.PageIndex, postParameters.PageSize, count, data); }   ","description":"","id":34,"section":"code","tags":null,"title":"09_翻页过滤排序","uri":"http://austinzgx.github.io/code/dotnetcore/09%E7%BF%BB%E9%A1%B5%E8%BF%87%E6%BB%A4%E6%8E%92%E5%BA%8F/"},{"content":"资源塑形 如果资源的属性较多, 而且API消费者只需要一分部属性, 那么就应该考虑资源塑形\n集合资源 单个资源 异常处理\n IEnumerableExtensions  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  //集合资源塑性  public static class IEnumerableExtensions { public static IEnumerable\u0026lt;ExpandoObject\u0026gt; ToDynamicIEnumerable\u0026lt;TSource\u0026gt;(this IEnumerable\u0026lt;TSource\u0026gt; source,string fields = null) { if (source ==null) { throw new ArgumentNullException(nameof(source)); } var expandoObjectList = new List\u0026lt;ExpandoObject\u0026gt;(); var propertyInfoList = new List\u0026lt;PropertyInfo\u0026gt;(); if (string.IsNullOrWhiteSpace(fields)) { var propertyInfos = typeof(TSource).GetProperties(BindingFlags.Public | BindingFlags.Instance); propertyInfoList.AddRange(propertyInfos); } else { var fieldsAfterSplit = fields.Split(\u0026#39;,\u0026#39;).ToList(); foreach (var field in fieldsAfterSplit) { var propertyName = field.Trim(); if (string.IsNullOrEmpty(propertyName)) { continue; } var propertyInfo = typeof(TSource).GetProperty(propertyName, BindingFlags.IgnoreCase | BindingFlags.Public | BindingFlags.Instance); if (propertyInfo ==null) { throw new Exception($\u0026#34;Property {propertyName} was\u0026#39;t found on {typeof(TSource)}\u0026#34;); } propertyInfoList.Add(propertyInfo); } } foreach (TSource sourceObject in source) { var dataShapedObject = new ExpandoObject(); foreach (var propertyInfo in propertyInfoList) { var propertyValue = propertyInfo.GetValue(sourceObject); ((IDictionary\u0026lt;string, object\u0026gt;)dataShapedObject).Add(propertyInfo.Name, propertyValue); } expandoObjectList.Add(dataShapedObject); } return expandoObjectList; } }   ObjectExtensions  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  //单个资源塑性  public static class ObjectExtensions { public static ExpandoObject ToDynamic\u0026lt;TSoucre\u0026gt;(this TSoucre source,string fields = null) { if (source == null) { throw new ArgumentNullException(nameof(source)); } var dataShapedObject = new ExpandoObject(); if (string.IsNullOrWhiteSpace(fields)) { var propertyInfos = typeof(TSoucre).GetProperties(BindingFlags.IgnoreCase | BindingFlags.Public | BindingFlags.Instance); foreach (var propertyInfo in propertyInfos) { var propertyValue = propertyInfo.GetValue(source); ((IDictionary\u0026lt;string, object\u0026gt;)dataShapedObject).Add(propertyInfo.Name, propertyValue); } return dataShapedObject; } var fieldsAfterSplit = fields.Split(\u0026#39;,\u0026#39;).ToList(); foreach (var field in fieldsAfterSplit) { var propertyName = field.Trim(); var propertyInfo = typeof(TSoucre).GetProperty(propertyName, BindingFlags.IgnoreCase | BindingFlags.Public | BindingFlags.Instance); if (propertyInfo ==null) { throw new Exception($\u0026#34;Can\u0026#39;t found property {typeof(TSoucre)} on {propertyName}\u0026#34;); } var propertyValue = propertyInfo.GetValue(source); ((IDictionary\u0026lt;string, object\u0026gt;)dataShapedObject).Add(propertyInfo.Name, propertyValue); } return dataShapedObject; } }   修改controller  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  [HttpGet(Name =\u0026#34;GetPosts\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get(PostParameters postParameters) { var postList = await _postRepository.GetAllPostsAsync(postParameters); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(postList); //集合资源塑性  var shapedPostResources = postResources.ToDynamicIEnumerable(postParameters.Fields); var previousPageLink = postList.HasPrevious ? CreatePostUri(postParameters, PaginationResourceUriType.PreviousPage) : null; var nextPageLink = postList.HasNext ? CreatePostUri(postParameters, PaginationResourceUriType.NextPage) : null; var meta = new { postList.PageSize, postList.PageIndex, postList.TotalItemsCount, postList.PageCount, previousPageLink, nextPageLink }; Response.Headers.Add(\u0026#34;X-Pagination\u0026#34;, JsonConvert.SerializeObject(meta, new JsonSerializerSettings { //使得命名符合驼峰命名法  ContractResolver = new CamelCasePropertyNamesContractResolver() })); return Ok(shapedPostResources);   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  [HttpGet(\u0026#34;{id}\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get(int id, string fields = null) { var post = await _postRepository.GetPostByIdAsync(id); if (post == null) { return NotFound();//404  } var postResource = _mapper.Map\u0026lt;Post, PostResource\u0026gt;(post); //单个资源塑性  var shapedPostResource = postResource.ToDynamic(fields); return Ok(shapedPostResource); //200  }   4. 修改startup,返回资源命名为驼峰命名\n1 2 3 4 5 6 7 8 9 10  services.AddMvc( options=\u0026gt; { options.ReturnHttpNotAcceptable = true; //开启406  options.OutputFormatters.Add(new XmlDataContractSerializerOutputFormatter()); }) .AddJsonOptions(options=\u0026gt; { options.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver(); });   异常处理  ITypeHelperService  1 2 3 4  public interface ITypeHelperService { bool TypeHasProperties\u0026lt;T\u0026gt;(string fields); }   TypeHelperService  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  public class TypeHelperService:ITypeHelperService { public bool TypeHasProperties\u0026lt;T\u0026gt;(string fields) { if (string.IsNullOrWhiteSpace(fields)) { return true; } var fieldsAfterSplit = fields.Split(\u0026#39;,\u0026#39;); foreach (var field in fieldsAfterSplit) { var propertyName = field.Trim(); if (string.IsNullOrEmpty(propertyName)) { continue; } var propertyInfo = typeof(T) .GetProperty(propertyName, BindingFlags.IgnoreCase | BindingFlags.Public | BindingFlags.Instance); if (propertyInfo == null) { return false; } } return true; } }   注册TypeHelperService  1  services.AddTransient\u0026lt;ITypeHelperService, TypeHelperService\u0026gt;();   修改Controller  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  [HttpGet(Name =\u0026#34;GetPosts\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get(PostParameters postParameters) { if (!_propertyMappingContainer.ValidateMappingExistsFor\u0026lt;PostResource,Post\u0026gt;(postParameters.OrderBy)) { return BadRequest(\u0026#34;cannot finds fields for sorting.\u0026#34;); } if (!_typeHelperService.TypeHasProperties\u0026lt;PostResource\u0026gt;(postParameters.Fields)) { return BadRequest(\u0026#34;Fields not exist.\u0026#34;); } var postList = await _postRepository.GetAllPostsAsync(postParameters); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(postList); //集合资源塑性  var shapedPostResources = postResources.ToDynamicIEnumerable(postParameters.Fields); var previousPageLink = postList.HasPrevious ? CreatePostUri(postParameters, PaginationResourceUriType.PreviousPage) : null; var nextPageLink = postList.HasNext ? CreatePostUri(postParameters, PaginationResourceUriType.NextPage) : null; var meta = new { postList.PageSize, postList.PageIndex, postList.TotalItemsCount, postList.PageCount, previousPageLink, nextPageLink }; Response.Headers.Add(\u0026#34;X-Pagination\u0026#34;, JsonConvert.SerializeObject(meta, new JsonSerializerSettings { //使得命名符合驼峰命名法  ContractResolver = new CamelCasePropertyNamesContractResolver() })); return Ok(shapedPostResources); } [HttpGet(\u0026#34;{id}\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get(int id, string fields = null) { if (!_typeHelperService.TypeHasProperties\u0026lt;PostResource\u0026gt;(fields)) { return BadRequest(\u0026#34;Fields not exist.\u0026#34;); } var post = await _postRepository.GetPostByIdAsync(id); if (post == null) { return NotFound();//404  } var postResource = _mapper.Map\u0026lt;Post, PostResource\u0026gt;(post); //单个资源塑性  var shapedPostResource = postResource.ToDynamic(fields); return Ok(shapedPostResource); //200  }   ","description":"","id":35,"section":"code","tags":null,"title":"10_资源塑形","uri":"http://austinzgx.github.io/code/dotnetcore/10%E8%B5%84%E6%BA%90%E5%A1%91%E5%BD%A2/"},{"content":"Hypermedia as the Engine of Application State\nREST里最复杂的约束, 构建成熟REST API的核心\n 可进化性, 自我描述 超媒体(Hypermedia, 例如超链接)驱动如何消费和使用API  不使用HATEOAS  客户端更多的需要了解API内在逻辑 如果API发生了一点变化(添加了额外的规则, 改变规则)都会破坏API的消费者. API无法独立于消费它的应用进行进化.\n  使用HATEOAS  这个response里面包含了若干link, 第一个link包含着获取当前响应的链接, 第二个link则告诉客户端如何去更新该post. 不改变响应主体结果的情况下添加另外一个删除的功能(link), 客户端通过响应里的links就会发现这个删除功能, 但是对其他部分都没有影响.\n  展示链接  JSON和XML并没有如何展示link的概念. 但是HTML的anchor元素却知道: .  href包含了URI rel则描述了link如何和资源的关系 type是可选的, 它表示了媒体的类型   我们的例子:  method: 定义了需要使用的方法 rel: 表明了动作的类型 href: 包含了执行这个动作所包含的URI.\n    实现  静态基类\n需要基类(包含link)和包装类, 也就是返回的资源里面都含有link, 通过继承于同一个基类来实现 动态类型, 需要使用例如匿名类或ExpandoObject等\n* 对于单个资源可以使用ExpandoObject\n* 对于集合类资源则使用匿名类.   LinkResource  1 2 3 4 5 6 7 8 9 10 11 12  public class LinkResource { public LinkResource(string href,string rel,string method) { Href = href; Rel = rel; Method = method; } public string Href { get; set; } public string Rel { get; set; } public string Method { get; set; } }   Controller中添加CreateLinksForPost  1 2 3 4 5 6 7 8 9 10 11 12 13  //为每个资源创建链接link  private IEnumerable\u0026lt;LinkResource\u0026gt; CreateLinksForPost(int id,string fields = null) { var links = new List\u0026lt;LinkResource\u0026gt;(); if (string.IsNullOrWhiteSpace(fields)) links.Add(new LinkResource(_urlHelper.Link(\u0026#34;GetPost\u0026#34;, new { id }), \u0026#34;self\u0026#34;, \u0026#34;GET\u0026#34;)); else links.Add(new LinkResource(_urlHelper.Link(\u0026#34;GetPost\u0026#34;, new { id,fields}), \u0026#34;self\u0026#34;, \u0026#34;GET\u0026#34;)); links.Add(new LinkResource(_urlHelper.Link(\u0026#34;DeletePost\u0026#34;, new { id }), \u0026#34;delete_post\u0026#34;, \u0026#34;DELETE\u0026#34;)); return links; }   GETPOST中调用  1 2 3 4 5 6 7 8 9 10 11  //单个资源塑性 var shapedPostResource = postResource.ToDynamic(fields); //加载link var links = CreateLinksForPost(id, fields); //整合返回数据 var result = shapedPostResource as IDictionary\u0026lt;string, object\u0026gt;; result.Add(\u0026#34;links\u0026#34;, links); return Ok(result);   1 2 3 4 5 6 7 8 9 10 11  //集合资源塑性  var shapedPostResources = postResources.ToDynamicIEnumerable(postParameters.Fields); //循环遍历为每个资源添加link var shapdeWithLinks = shapedPostResources.Select(x =\u0026gt; { var dict = x as IDictionary\u0026lt;string, object\u0026gt;; var postLinks = CreateLinksForPost((int)dict[\u0026#34;Id\u0026#34;], postParameters.Fields); dict.Add(\u0026#34;links\u0026#34;, psotLinks); return dict; });   4. 集合资源整体Link\n1 2 3 4 5 6 7 8 9 10 11 12 13  //为集合资源创建整体link private IEnumerable\u0026lt;LinkResource\u0026gt; CreateLinksForPosts(PostParameters postParameters,bool hasPrevious,bool hasNext) { var links = new List\u0026lt;LinkResource\u0026gt; { new LinkResource(CreatePostUri(postParameters,PaginationResourceUriType.CurrentPage),\u0026#34;self\u0026#34;,\u0026#34;GET\u0026#34;) }; if (hasPrevious) links.Add(new LinkResource(CreatePostUri(postParameters,PaginationResourceUriType.PreviousPage),\u0026#34;previous_page\u0026#34;,\u0026#34;GET\u0026#34;)); if (hasNext) links.Add(new LinkResource(CreatePostUri(postParameters,PaginationResourceUriType.NextPage),\u0026#34;next_page\u0026#34;,\u0026#34;GET\u0026#34;)); return links; }   1 2 3 4 5 6 7 8  //集合的整体links var links = CreateLinksForPosts(postParameters, postList.HasPrevious, postList.HasNext); var result = new { values = shapdeWithLinks, links };   Vendor-specific media type 创建供应商特定媒体类型\n上例中使用application/json会破坏了资源的自我描述性这条约束, API消费者无法从content-type的类型来正确的解析响应.\n application/vnd.mycompany.hateoas+json\n* vnd是vendor的缩写，这一条是mime type的原则，表示这个媒体类型是供应商特定的  自定义的标识，也可能还包括额外的值，这里我是用的是公司名，随后是hateoas表示返回的响应里面要包含链接 +json   在Startup里注册.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  services.AddMvc( options=\u0026gt; { options.ReturnHttpNotAcceptable = true; //开启406  //支持xml  //options.OutputFormatters.Add(new XmlDataContractSerializerOutputFormatter());  //自定义mediaType  var outputFormatter = options.OutputFormatters.OfType\u0026lt;JsonOutputFormatter\u0026gt;().FirstOrDefault(); if (outputFormatter!=null) { outputFormatter.SupportedMediaTypes.Add(\u0026#34;application/vnd.enfi.hateoas+json\u0026#34;); } }) .AddJsonOptions(options=\u0026gt; { options.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver(); });    判断Media Type类型\n* [FromHeader(Name = \u0026ldquo;Accept\u0026rdquo;)] string mediaType\n* 自定义Action约束.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  [HttpGet(Name = \u0026#34;GetPosts\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get(PostParameters postParameters, [FromHeader(Name = \u0026#34;Accept\u0026#34;)] string mediaType) { if (!_propertyMappingContainer.ValidateMappingExistsFor\u0026lt;PostResource, Post\u0026gt;(postParameters.OrderBy)) { return BadRequest(\u0026#34;cannot finds fields for sorting.\u0026#34;); } if (!_typeHelperService.TypeHasProperties\u0026lt;PostResource\u0026gt;(postParameters.Fields)) { return BadRequest(\u0026#34;Fields not exist.\u0026#34;); } var postList = await _postRepository.GetAllPostsAsync(postParameters); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(postList); //判断mediaType  if (mediaType == \u0026#34;application/vnd.enfi.hateoas+json\u0026#34;) { //集合资源塑性  var shapedPostResources = postResources.ToDynamicIEnumerable(postParameters.Fields); //循环遍历为每个资源添加link  var shapdeWithLinks = shapedPostResources.Select(x =\u0026gt; { var dict = x as IDictionary\u0026lt;string, object\u0026gt;; var postLinks = CreateLinksForPost((int)dict[\u0026#34;Id\u0026#34;], postParameters.Fields); dict.Add(\u0026#34;links\u0026#34;, postLinks); return dict; }); //集合的整体links  var links = CreateLinksForPosts(postParameters, postList.HasPrevious, postList.HasNext); var result = new { values = shapdeWithLinks, links }; //var previousPageLink = postList.HasPrevious ? CreatePostUri(postParameters, PaginationResourceUriType.PreviousPage) : null;  //var nextPageLink = postList.HasNext ? CreatePostUri(postParameters, PaginationResourceUriType.NextPage) : null;  var meta = new { postList.PageSize, postList.PageIndex, postList.TotalItemsCount, postList.PageCount, //previousPageLink,  //nextPageLink  }; Response.Headers.Add(\u0026#34;X-Pagination\u0026#34;, JsonConvert.SerializeObject(meta, new JsonSerializerSettings { //使得命名符合驼峰命名法  ContractResolver = new CamelCasePropertyNamesContractResolver() })); return Ok(result); } else //不是自定义的mediaType按json返回，元数据包含在返回的head中  { var previousPageLink = postList.HasPrevious ? CreatePostUri(postParameters, PaginationResourceUriType.PreviousPage) : null; var nextPageLink = postList.HasNext ? CreatePostUri(postParameters, PaginationResourceUriType.NextPage) : null; var meta = new { postList.PageSize, postList.PageIndex, postList.TotalItemsCount, postList.PageCount, previousPageLink, nextPageLink }; Response.Headers.Add(\u0026#34;X-Pagination\u0026#34;, JsonConvert.SerializeObject(meta, new JsonSerializerSettings { //使得命名符合驼峰命名法  ContractResolver = new CamelCasePropertyNamesContractResolver() })); return Ok(postResources.ToDynamicIEnumerable(postParameters.Fields)); } }   使用Action约束分解为两个方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  [AttributeUsage(AttributeTargets.All, Inherited = true, AllowMultiple = true)] public class RequestHeaderMatchingMediaTypeAttribute : Attribute, IActionConstraint { private readonly string _requestHeaderToMatch; private readonly string[] _mediaTypes; public RequestHeaderMatchingMediaTypeAttribute(string requestHeaderToMatch, string[] mediaTypes) { _requestHeaderToMatch = requestHeaderToMatch; _mediaTypes = mediaTypes; } public bool Accept(ActionConstraintContext context) { var requestHeaders = context.RouteContext.HttpContext.Request.Headers; if (!requestHeaders.ContainsKey(_requestHeaderToMatch)) { return false; } foreach (var mediaType in _mediaTypes) { var mediaTypeMatches = string.Equals(requestHeaders[_requestHeaderToMatch].ToString(), mediaType, StringComparison.OrdinalIgnoreCase); if (mediaTypeMatches) { return true; } } return false; } public int Order { get; } = 0; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  [HttpGet(Name = \u0026#34;GetPosts\u0026#34;)] [RequestHeaderMatchingMediaType(\u0026#34;Accept\u0026#34;, new[] { \u0026#34;application/vnd.enfi.hateoas+json\u0026#34; })] public async Task\u0026lt;IActionResult\u0026gt; GetHateoas(PostParameters postParameters) { if (!_propertyMappingContainer.ValidateMappingExistsFor\u0026lt;PostResource, Post\u0026gt;(postParameters.OrderBy)) { return BadRequest(\u0026#34;cannot finds fields for sorting.\u0026#34;); } if (!_typeHelperService.TypeHasProperties\u0026lt;PostResource\u0026gt;(postParameters.Fields)) { return BadRequest(\u0026#34;Fields not exist.\u0026#34;); } var postList = await _postRepository.GetAllPostsAsync(postParameters); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(postList); //集合资源塑性  var shapedPostResources = postResources.ToDynamicIEnumerable(postParameters.Fields); //循环遍历为每个资源添加link  var shapdeWithLinks = shapedPostResources.Select(x =\u0026gt; { var dict = x as IDictionary\u0026lt;string, object\u0026gt;; var postLinks = CreateLinksForPost((int)dict[\u0026#34;Id\u0026#34;], postParameters.Fields); dict.Add(\u0026#34;links\u0026#34;, postLinks); return dict; }); //集合的整体links  var links = CreateLinksForPosts(postParameters, postList.HasPrevious, postList.HasNext); var result = new { values = shapdeWithLinks, links }; var meta = new { postList.PageSize, postList.PageIndex, postList.TotalItemsCount, postList.PageCount, }; Response.Headers.Add(\u0026#34;X-Pagination\u0026#34;, JsonConvert.SerializeObject(meta, new JsonSerializerSettings { //使得命名符合驼峰命名法  ContractResolver = new CamelCasePropertyNamesContractResolver() })); return Ok(result); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  [HttpGet(Name = \u0026#34;GetPosts\u0026#34;)] [RequestHeaderMatchingMediaType(\u0026#34;Accept\u0026#34;, new[] { \u0026#34;application/json\u0026#34; })] //不是自定义的mediaType按json返回，元数据包含在返回的head中  public async Task\u0026lt;IActionResult\u0026gt; Get(PostParameters postParameters) { if (!_propertyMappingContainer.ValidateMappingExistsFor\u0026lt;PostResource, Post\u0026gt;(postParameters.OrderBy)) { return BadRequest(\u0026#34;cannot finds fields for sorting.\u0026#34;); } if (!_typeHelperService.TypeHasProperties\u0026lt;PostResource\u0026gt;(postParameters.Fields)) { return BadRequest(\u0026#34;Fields not exist.\u0026#34;); } var postList = await _postRepository.GetAllPostsAsync(postParameters); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(postList); var previousPageLink = postList.HasPrevious ? CreatePostUri(postParameters, PaginationResourceUriType.PreviousPage) : null; var nextPageLink = postList.HasNext ? CreatePostUri(postParameters, PaginationResourceUriType.NextPage) : null; var meta = new { postList.PageSize, postList.PageIndex, postList.TotalItemsCount, postList.PageCount, previousPageLink, nextPageLink }; Response.Headers.Add(\u0026#34;X-Pagination\u0026#34;, JsonConvert.SerializeObject(meta, new JsonSerializerSettings { //使得命名符合驼峰命名法  ContractResolver = new CamelCasePropertyNamesContractResolver() })); return Ok(postResources.ToDynamicIEnumerable(postParameters.Fields)); }   ","description":"","id":36,"section":"code","tags":null,"title":"11_HATEOAS","uri":"http://austinzgx.github.io/code/dotnetcore/11hateoas/"},{"content":"安全性\u0026amp;幂等性  安全性☞方法执行后并不会改变资源的表述 幂等性☞方法无论执行多少次都会得到同样的结果\n  POST 添加资源 不安全，不幂等\n 参数[FromBody] 返回201 Created\n* CreatedAtRoute(): 它允许响应里带着LocationHeader，其中包含着一个URI,通过这个URI就可以GET到我们刚刚创建好的资源。 HATEOAS   PostAddResource  1 2 3 4 5  public class PostAddResource { public string Title { get; set; } public string Body { get; set; } }   MappingProfile  1 2 3 4 5 6 7 8 9  public MappingProfile() { CreateMap\u0026lt;Post, PostResource\u0026gt;() .ForMember(dest =\u0026gt; dest.UpdateTime, opt =\u0026gt; opt.MapFrom(src =\u0026gt; src.LastModified)); CreateMap\u0026lt;PostResource, Post\u0026gt;(); CreateMap\u0026lt;PostAddResource,Post\u0026gt;(); }   Action中Post方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  [HttpPost(Name =\u0026#34;CreatePost\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Post([FromBody] PostAddResource postAddResource) { if (postAddResource == null) { return BadRequest(\u0026#34;not data!\u0026#34;); } var newPost = _mapper.Map\u0026lt;PostAddResource, Post\u0026gt;(postAddResource); newPost.Author = \u0026#34;admin\u0026#34;; newPost.LastModified = DateTime.Now; _postRepository.AddPost(newPost); if (!await _unitOfWork.SaveAsync()) { throw new Exception(\u0026#34;Save post data Failed!\u0026#34;); } var resultResource = _mapper.Map\u0026lt;Post, PostResource\u0026gt;(newPost); //HATEOAS  var links = CreateLinksForPost(newPost.Id); var linkedPostResource = resultResource.ToDynamic() as IDictionary\u0026lt;string, object\u0026gt;; linkedPostResource.Add(\u0026#34;links\u0026#34;, links); //return Ok(resultResource);//200  return CreatedAtRoute(\u0026#34;GetPost\u0026#34;,new { id = linkedPostResource[\u0026#34;Id\u0026#34;] },linkedPostResource); //201  }   Model 验证  定义验证规则 检查验证规则 把验证错误信息发送给API消费者   内置验证：  DataAnnotation\n ValidationAttribute IValidatebleObject   第三方FluentValidation  关注点分离（SOC,Seperation of Concerns) 安装包\n* FluentValidation\n* FluentValidation.AspNetCore 为每一个Resource建立验证器  继承AbstractValidator\n      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public class PostAddResourceValidator:AbstractValidator\u0026lt;PostAddResource\u0026gt; { public PostAddResourceValidator() { RuleFor(x =\u0026gt; x.Title) .NotNull() .WithName(\u0026#34;标题\u0026#34;) .WithMessage(\u0026#34;{PropertyName}是必填的\u0026#34;) .MaximumLength(50) .WithMessage(\u0026#34;{PropertyName}的最大长度是{MaxLength}\u0026#34;); RuleFor(x =\u0026gt; x.Body) .NotNull() .WithName(\u0026#34;正文\u0026#34;) .WithMessage(\u0026#34;{PropertyName}是必填的\u0026#34;) .MinimumLength(50) .WithMessage(\u0026#34;{PropertyName}的最小长度是{MaxLength}\u0026#34;); } }    配置  1 2  //注册FluentValidator services.AddTransient\u0026lt;IValidator\u0026lt;PostAddResource\u0026gt;, PostAddResourceValidator\u0026gt;();   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  services.AddMvc( options =\u0026gt; { options.ReturnHttpNotAcceptable = true; //开启406  //options.OutputFormatters.Add(new XmlDataContractSerializerOutputFormatter());  //自定义mediaType  var outputFormatter = options.OutputFormatters.OfType\u0026lt;JsonOutputFormatter\u0026gt;().FirstOrDefault(); if (outputFormatter != null) { outputFormatter.SupportedMediaTypes.Add(\u0026#34;application/vnd.enfi.hateoas+json\u0026#34;); } }) .AddJsonOptions(options =\u0026gt; { options.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver(); }) .AddFluentValidation();    验证  ModelStatus.IsValid ModelState  字典，包含Model的状态以及Model所绑定的验证 对于提交的每个属性，它都包含了一个错误信息的集合     返回：422 UnprocessableEntity  验证错误信息在响应的body里面带回去    1 2 3 4  if (!ModelState.IsValid) { return UnprocessableEntity(ModelState); }    MediaType  1 2 3 4 5  var inputFormatter = options.InputFormatters.OfType\u0026lt;JsonInputFormatter\u0026gt;().FirstOrDefault(); if (inputFormatter!=null) { inputFormatter.SupportedMediaTypes.Add(\u0026#34;application/vnd.enfi.post.create+json\u0026#34;); }   1 2 3 4 5 6 7  [HttpPost(Name =\u0026#34;CreatePost\u0026#34;)] [RequestHeaderMatchingMediaType(\u0026#34;Content-Type\u0026#34;, new[] { \u0026#34;application/vnd.enfi.post.create+json\u0026#34; })] [RequestHeaderMatchingMediaType(\u0026#34;Accept\u0026#34;, new[] { \u0026#34;application/vnd.enfi.hateoas+json\u0026#34; })] public async Task\u0026lt;IActionResult\u0026gt; Post([FromBody] PostAddResource postAddResource) { ... }   POST 一次性添加集合资源  把整个集合看作一种资源 参数[FromBody]IEnumerable 返回201，CreatedAtRoute()，带着ID的集合 GET方法参数为ID的集合，用于查询创建的集合资源  ArrayModelBinder:IModelBinder    自定义验证错误返回结果  满足Angular客户端表单验证要求：  错误的类型：required,maxLength \u0026hellip;   MyUnprocessableEntityObjectResult  继承：ObjectResult ResourceValidationResult:Dictionary\u0026lt;string,IEnumerable\u0026gt;     PostAddResourceValidator  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public class PostAddResourceValidator:AbstractValidator\u0026lt;PostAddResource\u0026gt; { public PostAddOrUpdateResourceValidator() { RuleFor(x =\u0026gt; x.Title) .NotNull() .WithName(\u0026#34;标题\u0026#34;) .WithMessage(\u0026#34;required|{propertyName}是必填的\u0026#34;) .MaximumLength(50) .WithMessage(\u0026#34;maxlength|{PropertyName}的最大长度是{MaxLength}\u0026#34;); RuleFor(x =\u0026gt; x.Body) .NotNull() .WithName(\u0026#34;正文\u0026#34;) .WithMessage(\u0026#34;required|{PropertyName}是必填的\u0026#34;) .MinimumLength(50) .WithMessage(\u0026#34;minlength|{PropertyName}的最小长度是{MinLength}\u0026#34;); } }   ResourceValidationError  1 2 3 4 5 6 7 8 9 10 11 12  public class ResourceValidationError { public ResourceValidationError(string message,string validatorKey =\u0026#34;\u0026#34;) { Message = message; ValidatorKey = validatorKey; } public string Message { get; private set; } public string ValidatorKey { get; private set; } }   ResourceValidationResult  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public class ResourceValidationResult:Dictionary\u0026lt;string,IEnumerable\u0026lt;ResourceValidationError\u0026gt;\u0026gt; { public ResourceValidationResult():base(StringComparer.OrdinalIgnoreCase) { } public ResourceValidationResult(ModelStateDictionary modelState):this() { if (modelState ==null) { throw new ArgumentNullException(nameof(modelState)); } foreach (var keyModelStatePair in modelState) { var key = keyModelStatePair.Key; var errors = keyModelStatePair.Value.Errors; if (errors!=null\u0026amp;\u0026amp;errors.Count\u0026gt;0) { var errorsToAdd = new List\u0026lt;ResourceValidationError\u0026gt;(); foreach (var error in errors) { var keyAndMessage = error.ErrorMessage.Split(\u0026#39;|\u0026#39;); if (keyAndMessage.Length \u0026gt;1) { errorsToAdd.Add(new ResourceValidationError(keyAndMessage[1], keyAndMessage[0])); } else { errorsToAdd.Add(new ResourceValidationError(keyAndMessage[0])); } } Add(key, errorsToAdd); } } } }   MyUnprocessableEntityObjectResult  1 2 3 4 5 6 7 8 9 10 11  public class MyUnprocessableEntityObjectResult : UnprocessableEntityObjectResult { public MyUnprocessableEntityObjectResult(ModelStateDictionary modelState) : base(new ResourceValidationResult(modelState)) { if (modelState == null) { throw new ArgumentNullException(nameof(modelState)); } StatusCode = 422; } }   使用  1 2 3 4 5  if (!ModelState.IsValid) { return new MyUnprocessableEntityObjectResult(ModelState); //return UnprocessableEntity(ModelState); }   DELETE  参数： ID 返回： 204 No Content 不安全 幂等：多次请求的副作用和单次请求的副作用是一样的，每次发送DELETE请求后，服务器的状态是一样的  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  [HttpDelete(\u0026#34;{id}\u0026#34;,Name =\u0026#34;DeletePost\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; DeletePost(int id) { var post = await _postRepository.GetPostByIdAsync(id); if (post ==null) { return NotFound(); } _postRepository.DeletePost(post); if (!await _unitOfWork.SaveAsync()) { throw new Exception($\u0026#34;Deleting post {id} failed when saving.\u0026#34;); } return NoContent(); }   PUT 整体更新  参数： ID [FromBody]不需要ID属性  单独的Resource Model.   返回： 204 No Content 202 OK 不安全 幂等 整体更新 容易引起问题 集合资源整体更新   抽象父类  1 2 3 4 5  public class PostAddOrUpdateResource { public string Title { get; set; } public string Body { get; set; } }   继承  1 2 3  public class PostUpdateResource:PostAddOrUpdateResource { }   修改FluentValidator  1 2 3 4  public class PostAddOrUpdateResourceValidator\u0026lt;T\u0026gt;:AbstractValidator\u0026lt;T\u0026gt; where T:PostAddOrUpdateResource { ...... }   修改注册  1 2 3  //注册FluentValidator  services.AddTransient\u0026lt;IValidator\u0026lt;PostAddResource\u0026gt;, PostAddOrUpdateResourceValidator\u0026lt;PostAddResource\u0026gt;\u0026gt;(); services.AddTransient\u0026lt;IValidator\u0026lt;PostUpdateResource\u0026gt;, PostAddOrUpdateResourceValidator\u0026lt;PostUpdateResource\u0026gt;\u0026gt;();   添加mappingProfile  1  CreateMap\u0026lt;PostUpdateResource,Post\u0026gt;();   6.Action\u0026raquo;\u0026gt;Post\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  [HttpPut(\u0026#34;{id}\u0026#34;,Name =\u0026#34;UpdatePost\u0026#34;)] //注意要在mvc中注册 Content-Type [RequestHeaderMatchingMediaType(\u0026#34;Content-Type\u0026#34;, new[] { \u0026#34;application/vnd.enfi.post.update+json\u0026#34; })] public async Task\u0026lt;IActionResult\u0026gt; UpdatePost(int id,[FromBody] PostUpdateResource postUpdate) { if (postUpdate == null) { return BadRequest(); } if (!ModelState.IsValid) { return new MyUnprocessableEntityObjectResult(ModelState); } var post = await _postRepository.GetPostByIdAsync(id); if (post == null) { return NotFound(\u0026#34;Cannot found the data for update.\u0026#34;); } post.LastModified = DateTime.Now; _mapper.Map(postUpdate, post); if (!await _unitOfWork.SaveAsync()) { throw new Exception($\u0026#34;Deleting post {id} failed when updating.\u0026#34;); } return NoContent(); }   PATCH 局部更新  application/json-patch+json\n 参数： ID [FromBody] JsonPatchDocument patchDoc.ApplyTo() 返回： 204 No Content 202 OK 不安全 不幂等   Repository中添加Update方法  1 2 3 4  public void UpdatePost(Post post) { _applicationContext.Entry(post).State = EntityState.Modified; }   Action 中添加Update方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  [HttpPatch(\u0026#34;{id}\u0026#34;,Name =\u0026#34;PartiallyUpdatePost\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; PartiallyUpdatePost(int id,[FromBody] JsonPatchDocument\u0026lt;PostUpdateResource\u0026gt; pathDoc) { if (pathDoc ==null) { return BadRequest(); } var post = await _postRepository.GetPostByIdAsync(id); if (post ==null) { return NotFound(\u0026#34;Cannot found the data for update.\u0026#34;); } var postToPatch = _mapper.Map\u0026lt;PostUpdateResource\u0026gt;(post); pathDoc.ApplyTo(postToPatch, ModelState); TryValidateModel(postToPatch); if (!ModelState.IsValid) { return new MyUnprocessableEntityObjectResult(ModelState); } _mapper.Map(postToPatch, post); post.LastModified = DateTime.Now; _postRepository.UpdatePost(post); if (!await _unitOfWork.SaveAsync()) { throw new Exception($\u0026#34;post {id} failed when partially updating patch.\u0026#34;); } return NoContent(); }   总结 ","description":"","id":37,"section":"code","tags":null,"title":"12_CURD","uri":"http://austinzgx.github.io/code/dotnetcore/12postputpatchdelete/"},{"content":"BASE ","description":"","id":38,"section":"code","tags":null,"title":"Base","uri":"http://austinzgx.github.io/code/go/base/"},{"content":"作者 Jon Skeet\n\nBlog\nStackOverflow\n第1章的作用是搭建起一个舞台，从一段简单的C#1代码开始，让它不断演变，观察更高的版本如何使代码变得越来越易读，越来越强大。我们介绍了C#成长的历史背景，以及它作为一个完整平台的一部分而工作的技术背景。具体地说，C#作为一种语言，它的基础是各种各样的“框架库”（.NETFramework中的各种库）以及一个强大的运行时（runtime）。借助它们，我们可以将抽象的东西转变成现实。\n第2章回顾了C#1的3个特定方面：委托、类型系统的特征以及值类型和引用类型的差异。许多C#1开发者对这些主题有了“足够”的认识，但由于C#对它们进行了极大的拓展，所以要充分利用那些新特性，就需要一个坚实的基础。\n第3章探讨了C#2大、同时也有可能难掌握的一个特性：泛型。方法和类型可以用泛型的方式来写，调用代码中指定的真实类型将被泛型定义中的“类型参数”代替。刚开始，这个说法确实会令人迷惑，但理解了泛型后，就会感觉自己再也离不开它们了。\n第4章介绍了可空类型，这是基于泛型建立起来的一个特性，利用了语言、运行时和框架所提供的支持。\n第5章介绍了C#2对委托的增强。在此之前，你也许只用委托处理过像按钮单击这样的事件。C#2使委托更容易创建，而库的支持使它们在除了事件之外的其他场合更加有用。\n第6章讨论了迭代器，以及在C#2中实现它们的简易方式。很少有开发者使用迭代器块，但由于LINQ to Objects是建立在迭代器基础上的，所以它们会变得越来越重要。它们执行时的“惰性”也是LINQ的一个关键部分。\n第7章对C#2引入的许多较小的特性进行了描述，它们使我们的编程工作变得更加令人愉悦。语言的设计者对C#1的一些粗糙的设计进行了改进，现在能够更灵活地与代码生成器交互，能更好地支持工具类，能更细致地访问属性，等等。\n第8章同样研究了一些相对简单的特性，但这一次是针对C#3的。几乎所有新语法都针对LINQ这个共同的目标进行了调整。但是这些基本的构建单元本身也相当有用。使用匿名类型、自动实现的属性、隐式类型的局部变量以及得到显著增强的初始化支持，C#3变成一个内容更加丰富的语言，使你的代码可以更好地表达程序的行为。\n第9章探讨了C#3的第一个重要主题——Lambda表达式。语言的设计者并不满足于第5章介绍得已经相当精简的语法，而是将委托变得比在C#2中还要容易创建。Lambda表达式还能做更多的事情——它们可以转换成表达式树：这是以数据形式来表示代码的一种强大的方式。\n第10章探讨了扩展方法，它提供了一种完美的方式来欺骗编译器，使编译器相信在一个类型中声明的方法实际上从属于另一个类型。从表面上看，这似乎会带来可读性上的灾难，但经过仔细考虑之后，你就会发现它是一个相当强大的特性——而且对LINQ来说至关重要。\n第11章以查询表达式的形式合并了前面3章的内容。查询表达式是一种简单而又强大的数据查询方式。我们先是将重点放在LINQ to Objects上，但所谓举一反三，通过观察如何应用查询表达式模式，你就明白LINQtoObjects能轻松地替换成其他数据提供器。\n第12章简要介绍了LINQ的不同用法。首先，我们学习了LINQtoSQL如何将看似普通的C#转换为SQL语句，以此来展示查询表达式和表达式树相结合的好处。然后，以LINQtoXML为例，继续介绍了如何将库设计得能够与LINQ相契合。Parallel LINQ（并行LINQ）和Reactive Extensions（响应式扩展）展示了进程内查询的两种替代方法。本章后讨论了如何用自己的LINQ操作符扩展LINQtoObjects。\n第13章开始介绍C#4，包括命名实参和可选参数、COM互操作的改进和泛型可变性。在某种程度上，这些特性彼此互不相干，但COM互操作以及用于处理COM对象的其他功能，都受益于命名实参和可选参数。\n第14章介绍了C#4中重要的特性：动态类型。用执行时的动态成员绑定代替编译时的静态绑定，对C#来说是一个巨大的尝试。但它在应用时是有选择性的：只有那些与动态值相关的代码才会动态地执行。\n第15章介绍的是异步。C#5只包含一个主要特性——编写异步函数的能力。这个特性非常复杂，不能一下子掌握，但掌握以后，使用起来非常优雅。在接近尾声的\n第16章介绍了C#5的其他特性（两个小特性），又展望了一下未来。\n附录列出了所有的参考资料。附录A通过一些示例，介绍了LINQ标准查询操作符。附录B展示了核心的泛型集合类和接口。附录C简要介绍了.NET的不同版本，包括精简框架和Silverlight。\n从简单的数据类型开始 product类型的定义演变历史 展示了越来越好的封装性、越来越强的类型化 以及越来越容易的初始化\n C#1.0 只读属性 弱类型集合 C#2.0 私有属性赋值方法 强类型集合 C#3.0 自动实现的属性、增加的集合和对象初始化 C#4.0 用命名实参更清晰地调用构造函数和方法  C#1.0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  using System.Collections; public class Product { string name; public string Name { get { return name; } } //代码中为属性提供了公共的取值方法，这意味着如果添加对应的赋值方法，那么赋值方 法也必须是公共的。  decimal price; public decimal Price { get { return price; } } //用于创建属性和变量的代码很复杂——封装一个字符串和一个十进制数应该是一个十分 简单的任务，不该这么复杂。  public Product(string name,decimal price) { this.name = name; this.price = price; } public static ArrayList GetSampleProducts() { ArrayList list = new ArrayList(); list.Add(new Product(\u0026#34;West Side Story\u0026#34;, 9.99m)); list.Add(new Product(\u0026#34;Assassins\u0026#34;, 14.99m)); list.Add(new Product(\u0026#34;Frogs\u0026#34;, 13.99m)); list.Add(new Product(\u0026#34;Sweeney\u0026#34;, 10.99m)); return list; //ArrayList没有提供与其内部内容有关的编译时信息。不慎在GetSampleProducts创建的列表中添加一个字符串是完全有可能的，而编译器对此没有任何反应。  } public override string ToString() { return string.Format(\u0026#34;{0}:{1}\u0026#34;,name,price); } }   C#2.0 强类型集合和私有的赋值方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  using System.Collections.Generic; public class Product { string name; public string Name { get { return name; } private set { name = value; } //属性拥有了私有的赋值方法  } decimal price; public decimal Price { get { return price; } private set { price = value; } } public Product(string name,decimal price) { Name = name; Price = price; } public static List\u0026lt;Product\u0026gt; GetSampleProducts() { List\u0026lt;Product\u0026gt; list = new List\u0026lt;Product\u0026gt;(); list.Add(new Product(\u0026#34;West Side Story\u0026#34;, 9.99m)); list.Add(new Product(\u0026#34;Assassins\u0026#34;, 14.99m)); list.Add(new Product(\u0026#34;Frogs\u0026#34;, 13.99m)); list.Add(new Product(\u0026#34;Sweeney\u0026#34;, 10.99m)); return list; // list集合中必须添加的是Product类  } public override string ToString() { return string.Format(\u0026#34;{0}:{1}\u0026#34;,name,price); } }   C#3.0 自动实现的属性和更简单的初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public class Product { public string Name { get; private set; } public decimal Price { get; private set; } public Product(string name,decimal price) { Name = name; Price = price; } Product() //私有无参构造函数  { } public static List\u0026lt;Product\u0026gt; GetSampleProducts() { return new List\u0026lt;Product\u0026gt; { new Product(\u0026#34;West Side Story\u0026#34;, 9.99m), new Product(\u0026#34;Assassins\u0026#34;, 14.99m), new Product(\u0026#34;Frogs\u0026#34;, 13.99m), new Product(\u0026#34;Sweeney\u0026#34;, 10.99m) }; } public override string ToString() { return string.Format(\u0026#34;{0}:{1}\u0026#34;,Name,Price); } }   C#4.0 命名实参清晰的初始化代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public class Product { readonly string name;//只读 尽管私有赋值方法的类型不能被公共地改变，但不希望他可以被私有地改变  public string Name { get { return Name; } } readonly decimal price; public decimal Price { get { return price; } } public Product(string name,decimal price) { this.name = name; this.price = price; } public static List\u0026lt;Product\u0026gt; GetSampleProducts() { return new List\u0026lt;Product\u0026gt; { new Product(\u0026#34;West Side Story\u0026#34;, 9.99m), new Product(\u0026#34;Assassins\u0026#34;, 14.99m), new Product(\u0026#34;Frogs\u0026#34;, 13.99m), new Product(\u0026#34;Sweeney\u0026#34;, 10.99m) }; } public override string ToString() { return string.Format(\u0026#34;{0}:{1}\u0026#34;,name,price); } }   排序和过滤 按名称对产品进行排序  C#1.0 弱类型的比较功能 不支持委托排序 C#2.0 强类型的比较功能 委托比较 匿名方法 C#3.0 表达式 扩展方法 允许列表保持未排序状态  C#1.0 使用IComparer对ArrayList进行排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  using System.Collections; public class Product { string name; public string Name { get { return name; } } //代码中为属性提供了公共的取值方法，这意味着如果添加对应的赋值方法，那么赋值方 法也必须是公共的。  decimal price; public decimal Price { get { return price; } } //用于创建属性和变量的代码很复杂——封装一个字符串和一个十进制数应该是一个十分 简单的任务，不该这么复杂。  public Product(string name,decimal price) { this.name = name; this.price = price; } public static ArrayList GetSampleProducts() { ArrayList list = new ArrayList(); list.Add(new Product(\u0026#34;West Side Story\u0026#34;, 9.99m)); list.Add(new Product(\u0026#34;Assassins\u0026#34;, 14.99m)); list.Add(new Product(\u0026#34;Frogs\u0026#34;, 13.99m)); list.Add(new Product(\u0026#34;Sweeney\u0026#34;, 10.99m)); return list; //ArrayList没有提供与其内部内容有关的编译时信息。不慎在GetSampleProducts创建的列表中添加一个字符串是完全有可能的，而编译器对此没有任何反应。  } public override string ToString() { return string.Format(\u0026#34;{0}:{1}\u0026#34;,name,price); } } class ProductNameComparer:IComparer //必须要引入一个额外的类型来帮助排序 { public int Compare(object x,object y) { Product first = (Product)x;//强制转换可能会出错  Product second = (Product)y; return first.Name.CompareTo(second.Name); } } ArrayList products = Product.GetSampleProducts(); products.Sort(new ProductNameComparer()); foreach (Product product in products) { Console.WriteLine(product); //隐蔽地使用了重载的ToString方法 }   C#2.0 使用IComparer对List进行排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  using System.Collections.Generic; public class Product { string name; public string Name { get { return name; } private set { name = value; } //属性拥有了私有的赋值方法  } decimal price; public decimal Price { get { return price; } private set { price = value; } } public Product(string name,decimal price) { Name = name; Price = price; } public static List\u0026lt;Product\u0026gt; GetSampleProducts() { List\u0026lt;Product\u0026gt; list = new List\u0026lt;Product\u0026gt;(); list.Add(new Product(\u0026#34;West Side Story\u0026#34;, 9.99m)); list.Add(new Product(\u0026#34;Assassins\u0026#34;, 14.99m)); list.Add(new Product(\u0026#34;Frogs\u0026#34;, 13.99m)); list.Add(new Product(\u0026#34;Sweeney\u0026#34;, 10.99m)); return list; // list集合中必须添加的是Product类  } public override string ToString() { return string.Format(\u0026#34;{0}:{1}\u0026#34;,name,price); } } class ProductNameComparer : IComparer\u0026lt;Product\u0026gt; //规定了比较的就是Product类型，不需要强制转换 { public int Compare(Product x, Product y) { return x.Name.CompareTo(y.Name); } } List\u0026lt;Product\u0026gt; products = Product.GetSampleProducts(); products.Sort(new ProductNameComparer()); foreach (Product product in products) { Console.WriteLine(product); }   C#2.0 直接进行比较，不需要实现一个接口实现\n1 2 3 4 5 6 7 8 9 10 11 12 13  //不在需要ProductNameComparer类型。 List\u0026lt;Product\u0026gt; products = Product.GetSampleProducts(); products.Sort( delegate (Product x, Product y) { return x.Name.CompareTo(y.Name); } //创建委托实例。将这个委托提供给Sort方法来执行比较 ); foreach (Product product in products) { Console.WriteLine(product); }   C#3.0 Lambda表达式\n1 2 3 4 5 6  List\u0026lt;Product\u0026gt; products = Product.GetSampleProducts(); products.Sort(x,y) =\u0026gt; x.Name.CompareTo(y.Name)); foreach (Product product in products) { Console.WriteLine(product); }   C#3.0 不修改原始产品列表(没有任何副作用),使用OrderBy扩展方法\n1 2 3 4 5  List\u0026lt;Product\u0026gt; products = Product.GetSampleProducts(); foreach (Product product in products.OrderBy(p =\u0026gt; p.Name)) { Console.WriteLine(product); }   查询 找出价格大于10的产品  C#1.0 条件和操作紧密耦合 两者都是硬编码的 C#2.0 条件和操作分开 匿名方法使委托变得简单 C#3.0 Lambda表达式使条件变得更容易阅读\nC#1.0 循环、测试和打印  1 2 3 4 5 6 7 8  ArrayList products = Product.GetSampleProducts(); foreach (Product product in products)//循环 { if (product.Price \u0026gt; 10m)//测试  { Console.WriteLine(product);//显示  } }   C#2.0 测试和打印分开进行\n.NET2.0 FindAll和ForEach方法只是鼓励你多分解问题\n1 2 3 4 5  List\u0026lt;Product\u0026gt; products = Product.GetSampleProducts(); Predicate\u0026lt;Product\u0026gt; test = delegate(Product p){return p.Price \u0026gt; 10m;};//匿名方法初始化 List\u0026lt;Product\u0026gt; matches = products.FindAll(test); Action\u0026lt;Product\u0026gt; print = Console.WriteLine;//使用了方法组转换，简化了从现有方法创建委托的过程。 matches.ForEach (print);//注意不要写成了foreach   C#2.0 测试和打印分开进行另一版本\n1 2 3  List\u0026lt;Product\u0026gt; products = Product.GetSampleProducts(); products.FindAll(delegate (Product p){ return p.Price \u0026gt; 10; }).ForEach(Console.WriteLine); //有点小题大做，有碍可读性   C#3 用Lambda表达式来测试\n1 2 3 4 5  List\u0026lt;Product\u0026gt; products = Product.GetSampleProducts(); foreach (Product product in products.where(p =\u0026gt; p.Price \u0026gt; 10)) { Console.WriteLine(product); }   处理未知数据  C#1.0 要么维护一个标志，要么更改引用类型的语义，要么利用一个魔数 C#2.0/C#3.0 可空类型避免了采用C#1的各种繁琐的方案，语法糖进一步简化了编程 C#4.0 可选参数简化了默认设置  表示未知价格 产品列表中包含尚未面市的产品，不知道价格，如果decimal是引用类型，那么只需要使用Null来表示未知价格即可。\n但是decimal是值类型，不可以这样！\nC#1.0\n在变量和属性声明中添加一个额外的 字符，即可解决这个问题.\n 围绕decimal创建一个引用类型包装器； 维护一个单独的Boolean标志，它表示价格是否已知； 使用一个“魔数”（magic value）（比如decimal.MinValue）来表示未知价格。  C#2.0\n.NET 2.0通过引入Nullable结构，C# 2通过提供一些语法糖 （syntactic sugar），使事情得到了极大的简化\n1 2 3 4 5 6  decimal？price; public decimal? Price { get { return price; } private set { price = value; } }   构造函数的参数也更改为decimal?，这样就可以将null作为参数值传递进来，或者在类中写Price = null;\nnull的含义原本是“不指向任何对象的一个特殊引用”变为\u0026quot;代表没有给出其他数据的任意可空类型的一个特殊值\u0026quot;。\n其中所有 引用类型 和 基于Nullable 的类型被视为 可空类型\n可空值是通过“大于”操作符来处理比较的(4.3.2 涉及可空类型的操作符)。\n为了检查一个价格是否已知，可以把它同null比较，或者使用HasValue属性\n可选参数和默认值 C#4 引入的可选参数（optional parameter)可以简化传统的方法重载\n定义没有价格参数的产品，C#4.0之前可能构造函数的重载来实现，但是C#4.0可以为价格参数声明一个默认值（如null)\n1 2 3 4 5  public Product(string name, decimal? price = null) { this.name = name; this.price = price; }   LINQ Language Integrated Query 语言集成查询，C#3.0核心\n目的是使用一致的语法和特性，以一种易阅读、可组合的方式，使对多数据源的查 询变得简单。\n查询表达式和进程内查询 使用查询表达式的前几步：\n 过滤集合  1 2 3 4 5 6 7 8  List\u0026lt;Product\u0026gt; products = Product.GetSampleProducts(); var filtered = from Product p in products where p.Price \u0026gt; 10 select p; foreach (Product product in filtered) { Console.WriteLine(product); }   查询表达式不是特别适合简单任务，但在一些较复杂的情况下，如果换成用方法调用来写（尤其是用C# 1或C# 2的方式），代码会变得难以阅读。在这些情况下，查询表达式就显得非常好用。\n2. 连接（joining）、过滤（filtering）、排序（ordering）和投影（projecting）（C# 3）\n为了稍微增大一点难度，引入另一个类型——Supplier（供货商）。每个供货商都有一个Name(string)和一个SupplierID(int)。在Product类添加了 SupplierID属性\n1 2 3 4 5 6 7 8 9 10 11  List\u0026lt;Product\u0026gt; products = Product.GetSampleProducts(); List\u0026lt;Supplier\u0026gt; suppliers = Supplier.GetSamplesSuppliers(); var filtered = from Product p in products join s in suppliers on p.SupplierID equals s.SupplierID where p.Price \u0026gt; 10 OrderBy s.Name, p.Name select new {SupplierName = s.Name, ProductName = p.Name}; foreach (var v in filtered) { Console.WriteLine(\u0026#34;Supplier={0}; Product={1}\u0026#34;, v.SupplierName, v.ProductName); }   查询XML 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;Data\u0026gt; \u0026lt;Products\u0026gt; \u0026lt;Product Name=\u0026#34;West Side Story\u0026#34; price=\u0026#34;9.99\u0026#34; SupplierID=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Product Name=\u0026#34;Assassins\u0026#34; price=\u0026#34;14.99\u0026#34; SupplierID=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Product Name=\u0026#34;Frogs\u0026#34; price=\u0026#34;13.99\u0026#34; SupplierID=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Product Name=\u0026#34;Sweeney\u0026#34; price=\u0026#34;10.99\u0026#34; SupplierID=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;/Products\u0026gt; \u0026lt;Suppliers\u0026gt; \u0026lt;Supplier Name=\u0026#34;Solely Sondhim\u0026#34; SupplierID=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Supplier Name=\u0026#34;CD-by-CD-by-Sondheim\u0026#34; SupplierID=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Supplier Name=\u0026#34;Barbershop\u0026#34; SupplierID=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;/Suppliers\u0026gt; \u0026lt;/Data\u0026gt;   用LINQ to XML对XML文件进行“复杂”的处理 C# 3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  XDocument doc = XDocument.Load(\u0026#34;data.xml\u0026#34;); var filtered = from p in doc.Descendants(\u0026#34;Product\u0026#34;) join s in doc.Descendants(\u0026#34;Supplier\u0026#34;) on (int)p.Attribute(\u0026#34;SupplierID\u0026#34;) equals (int)s.Attribute(\u0026#34;SupplierID\u0026#34;) where (decimal)p.Attribute(\u0026#34;Price\u0026#34;) \u0026gt; 10 OrderBy (string)s.Attribute(\u0026#34;Name\u0026#34;), (string)p.Attribute(\u0026#34;Name\u0026#34;) select new { SupplierName = (string)s.Attribute(\u0026#34;Name\u0026#34;), ProductName = (string)p.Attribute(\u0026#34;Name\u0026#34;) }; foreach (var v in filtered) { Console.WriteLine(\u0026#34;Supplier={0};Product={1}\u0026#34;,v.SupplierName,v.ProductName); }   LINQ to SQL 对SQL数据库应用查询表达式 C# 3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  using (LinqDemoDataContext db = new LinqDemoDataContext()) { var filtered = from p in db.Products join s in db.Suppliers on p.SupplierID equals s.SupplierID where p.Price \u0026gt; 10 orderby s.Name, p.Name select new { SupplierName = s.Name, ProductName = p.Name }; foreach (var v in filtered) { Console.WriteLine(\u0026#34;Supplier={0};Product={1}\u0026#34;,v.SupplierName,v.ProductName); } }   为什么不直接让数据库来做这些事情呢？那不正是它擅长的事情吗？\n事实上，这正是LINQ to SQL所做的事情。以上代码发出了一个数据库请求，它基本上被转换为SQL查询。\n虽然查询是用C#代码来表示的，但却是作为SQL来执行的。\n","description":"","id":39,"section":"code","tags":null,"title":"C# in depth_01","uri":"http://austinzgx.github.io/code/dotnetcore/csharp_in_depth_01/"},{"content":"准备  https://identityserver4.readthedocs.io/en/release/ OpenID Connect \u0026amp; OAuth 2.0 framework for ASP.NET Core 2.   建立Identity Provider项目   IdentityServer4.Templates https://github.com/IdentityServer/IdentityServer4.Templates 安装工具:  dotnet new -i identityserver4.templates 重置 “dotnet new” 功能列表: dotnet new --debug:reinit   模板:  dotnet new is4empty dotnet new is4ui dotnet new is4inmem dotnet new is4aspid dotnet new is4ef dotnet new is4admin (收费)    创建项目  dotnet new -i identityserver4.templates dotnet new is4aspid --name BlogIdp 升级为.NET Core 2.1, 更新Nuget包 配置Hsts|HttpsRedirection  1 2 3 4 5 6 7 8 9 10 11 12 13 14  //注册Hsts  services.AddHsts(options =\u0026gt; { options.Preload = true; options.IncludeSubDomains = true; options.MaxAge = TimeSpan.FromDays(60); }); //配置HTTP重定向  services.AddHttpsRedirection(options =\u0026gt; { options.RedirectStatusCode = StatusCodes.Status307TemporaryRedirect; options.HttpsPort = 6001; });   MVC 测试  安全/机密客户端(Confidential Client), 它是传统的服务器端Web应用. 它需要长时间访问(long-lived access), 所以需要refresh token. 那么它可以使用Authorization Code Flow或Hybrid Flow. Hybrid Flow是相对高级一些的, 它可以让客户端首先从授权端点获得一个ID Token并通过浏览器(front-channel)传递过来, 这样我们就可以验证这个ID Token. 如果验证成功然后, 客户端再打开一个后端通道(back-channel), 从Token端点获取Access Token.   身份认证请求\n   第一行的URI: \u0026ldquo;/authorize\u0026rdquo; 就是授权端点(Authorization Endpoint), 它位于身份提供商(Identity provider, IDP)那里. 这个URI可以从前面介绍的discovery document里面找到. 第二行 response_type=code id_token, 它决定了采取了哪一种Hybrid流程(参考上面那三个图). 第三行 client_id=xxxx, 这是客户端的身份标识. 第四行 redirect_uri=https\u0026hellip;., 这是客户端那里的重定向端点(Redirection Endpoint). 第五行 scope=openid profile email, 这就是客户端所请求的scopes.  Hybrid Flow\n   为什么要返回两次ID Token呢? 这是因为第(4)步里面请求Token的时候要求客户端身份认证, 这时请求Token的时候需要提供Authorization Code, Client ID和 Client Secret, 这些secret并不暴露给外界, 这些东西是由客户端服务器通过后端通道传递给Token端点的. 而第一次获得的ID Token是从前端通道(浏览器)返回的. 当这个ID Token被验证通过之后, 也就证明了当前用户到底是谁.\n  code demo  新建MVC 修改端口为7000，7001 修改Idp项目config.cs  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  new Client { ClientId = \u0026#34;mvcclient\u0026#34;, ClientName = \u0026#34;MVC客户端\u0026#34;, AllowedGrantTypes = GrantTypes.HybridAndClientCredentials, ClientSecrets = { new Secret(\u0026#34;49C1A7E1-0C79-4A89-A3D6-A37998FB86B0\u0026#34;.Sha256()) }, RedirectUris = { \u0026#34;http://localhost:7001/signin-oidc\u0026#34; }, FrontChannelLogoutUri = \u0026#34;http://localhost:7001/signout-oidc\u0026#34;, PostLogoutRedirectUris = { \u0026#34;http://localhost:7001/signout-callback-oidc\u0026#34; }, AllowOfflineAccess = true, //offline_access(refresh token)  AllowedScopes = { IdentityServerConstants.StandardScopes.OpenId }// { \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34;, \u0026#34;api1\u0026#34; }  },   修改mvc项目Startup  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.Configure\u0026lt;CookiePolicyOptions\u0026gt;(options =\u0026gt; { // This lambda determines whether user consent for non-essential cookies is needed for a given request.  options.CheckConsentNeeded = context =\u0026gt; true; options.MinimumSameSitePolicy = SameSiteMode.None; }); services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1); JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear(); services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;Cookies\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;Cookies\u0026#34;, options =\u0026gt; { options.AccessDeniedPath = \u0026#34;/Authorization/AccessDenied\u0026#34;; }) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.SignInScheme = \u0026#34;Cookies\u0026#34;; options.Authority = \u0026#34;https://localhost:6001\u0026#34;; options.RequireHttpsMetadata = true; options.ClientId = \u0026#34;mvcclient\u0026#34;; options.ResponseType = \u0026#34;code id_token\u0026#34;; options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); //与Idp中config对应  //options.Scope.Add(\u0026#34;profile\u0026#34;);  //options.Scope.Add(\u0026#34;email\u0026#34;);  //options.Scope.Add(\u0026#34;restapi\u0026#34;);  options.SaveTokens = true; options.ClientSecret = \u0026#34;49C1A7E1-0C79-4A89-A3D6-A37998FB86B0\u0026#34;; options.GetClaimsFromUserInfoEndpoint = true; }); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } else { app.UseExceptionHandler(\u0026#34;/Home/Error\u0026#34;); app.UseHsts(); } app.UseHttpsRedirection(); app.UseAuthentication(); app.UseStaticFiles(); app.UseCookiePolicy(); app.UseMvc(routes =\u0026gt; { routes.MapRoute( name: \u0026#34;default\u0026#34;, template: \u0026#34;{controller=Home}/{action=Index}/{id?}\u0026#34;); }); } }   HomeController 测试  1 2 3 4 5 6 7 8  [Authorize] public class HomeController : Controller { public IActionResult Index() { return View(); } ......   6. 添加更多获取资源\n1 2 3 4 5 6 7 8  public async Task\u0026lt;IActionResult\u0026gt; About() { var idToken = await HttpContext.GetTokenAsync(OpenIdConnectParameterNames.IdToken); ViewData[\u0026#34;idToken\u0026#34;] = idToken; return View(); }   Config.cs添加  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public static IEnumerable\u0026lt;IdentityResource\u0026gt; GetIdentityResources() { return new IdentityResource[] { new IdentityResources.OpenId(), new IdentityResources.Profile(), new IdentityResources.Email(), }; } public static IEnumerable\u0026lt;ApiResource\u0026gt; GetApis() { return new ApiResource[] { new ApiResource(\u0026#34;restapi\u0026#34;, \u0026#34;My RESTful API\u0026#34;) }; }   1 2 3 4 5 6 7 8  AllowOfflineAccess = true, //offline_access(开启refresh token)  AllowedScopes = { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, IdentityServerConstants.StandardScopes.Email, \u0026#34;restapi\u0026#34; }// { \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34;, \u0026#34;api1\u0026#34; }   修改html  1 2 3 4 5 6 7 8 9 10 11 12 13  @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;About\u0026#34;; } \u0026lt;h2\u0026gt;@ViewData[\u0026#34;Title\u0026#34;]\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;IdToken:@ViewData[\u0026#34;idToken\u0026#34;]\u0026lt;/h3\u0026gt; \u0026lt;dl\u0026gt; @foreach (var claim in User.Claims) { \u0026lt;dt\u0026gt;@claim.Type\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;@claim.Value\u0026lt;/dd\u0026gt; } \u0026lt;/dl\u0026gt;   保护API资源  安装包 `IdentityServer4.AccessTokenValidation 注册  1 2 3 4 5 6 7 8  // 注册IdentityServer  services.AddAuthentication(IdentityServerAuthenticationDefaults.AuthenticationScheme) .AddIdentityServerAuthentication(options =\u0026gt; { options.Authority = \u0026#34;https://localhost:6001\u0026#34;; options.ApiName = \u0026#34;restapi\u0026#34;; });   config\napp.UseAuthentication(); api中加验证  属性标签 [Authorize] 全局filter    1 2 3 4 5 6 7 8  //设置全局filter保护api需要认真用户才可访问  services.Configure\u0026lt;MvcOptions\u0026gt;(options =\u0026gt; { var policy = new AuthorizationPolicyBuilder() .RequireAuthenticatedUser() .Build(); options.Filters.Add(new AuthorizeFilter(policy)); });   NoAuth\n MVC客户端   安装IdentityModel 修改HomeController  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public async Task\u0026lt;IActionResult\u0026gt; Contact() { var httpClient = new HttpClient { BaseAddress = new Uri(\u0026#34;https://localhost:5001\u0026#34;) }; httpClient.DefaultRequestHeaders.Clear(); httpClient.DefaultRequestHeaders.Accept.Add( new MediaTypeWithQualityHeaderValue(\u0026#34;application/vnd.enfi.hateoas+json\u0026#34;) ); var accessToken = await HttpContext.GetTokenAsync(OpenIdConnectParameterNames.AccessToken); ViewData[\u0026#34;accessToken\u0026#34;] = accessToken; httpClient.SetBearerToken(accessToken); var res = await httpClient.GetAsync(\u0026#34;api/posts\u0026#34;).ConfigureAwait(false); if (res.IsSuccessStatusCode) { var json = await res.Content.ReadAsStringAsync().ConfigureAwait(false); var objects = JsonConvert.DeserializeObject\u0026lt;dynamic\u0026gt;(json); ViewData[\u0026#34;json\u0026#34;] = objects; return View(); } if (res.StatusCode == HttpStatusCode.Unauthorized) { return RedirectToAction(\u0026#34;AccessDenied\u0026#34;, \u0026#34;Authorization\u0026#34;); } throw new Exception($\u0026#34;Error Occurred:${res.ReasonPhrase}\u0026#34;); }    添加 Authorization/AccessDenied  1 2 3 4 5 6 7  public class AuthorizationController : Controller { public IActionResult AccessDenied() { return View(); } }   1 2 3 4  @{ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;AccessDenied\u0026#34;;} \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Access Denied\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt;   https://jwt.io 网站解析token  ","description":"","id":40,"section":"code","tags":null,"title":"ex_IdentityServer4","uri":"http://austinzgx.github.io/code/dotnetcore/identityserver4/"},{"content":"OAuth 2.0 vs OpenId Connect OAuth 2.0  OAuth 2.0是一个委托协议, 它可以让那些控制资源的人允许某个应用代表他们来访问他们控制的资源, 注意是代表这些人, 而不是假冒或模仿这些人. 这个应用从资源的所有者那里获得到授权(Authorization)和access token, 随后就可以使用这个access token来访问资源. (这里提到的假冒或模仿就是指在客户端复制一份用户名和密码，从而获取相应的权限)。 是关于授权(Authorization)的, 客户端应用可以请求access token, 使用这个token就可以访问API资源了 让客户端应用可以代表资源所有者(通常是用户)来访问被保护的资源\n 资源所有者(Resource Owner), 他拥有访问API资源的权限, 并且他还可以委派权限(delegate)给其他应用来访问API. 资源所有者通常是可以使用浏览器的人. 被保护的资源(Protected Resource)就是资源所有者拥有权限去访问的组件, 它可以是很多种形式的, 但是web API的形式还是最常见的. 客户端(Client)应用就是代表资源所有者访问被保护资源的一个软件. 注意它既不是指浏览器, 也不是指给你钱让你开发软件的人. 在OAuth2里面, 它是指被保护的API资源的消费者.     授权服务器 (Authorization Server, AS)   是被受保护的资源所信任的, 它可以发行具有特定目的的安全凭据给客户端应用, 这个凭据叫做OAuth的 access token.\n  授权种类   Authorization Code mplicit Resource Owner Password Credentials, 直接使用密码凭据(用户名和密码)作为授权来获得access token. 只有当资源所有者和客户端之间高度信任的时候并且其它授权方式不可用的时候才可以使用这种授权方式 Client Credentials, 有时候, 资源或者叫资源服务器并不属于某个最终用户, 也就是没有资源所有者对该资源负责. 但是客户端应用肯定还是要访问这些资源, 这时候就只能使用Client Credentials这种授权方式了.  其它重要角色和组件   资源所有者 Resource Owner 客户端 Client 被保护资源 Protected Resource 授权服务器 Authorization Server Access Token, 它是用来访问被保护资源的凭据. 授权服务器只是发行token, 被保护资源验证token. 客户端对于access token应该是完全健忘的. Scopes, 表示被保护资源那里的一套权限, 具有叠加性. Refresh Token, 用来获得Access Token的凭据. 客户端是用refresh token来请求新的access token  通过refresh token来取得新的access token的流程\n 重要端点   授权端点(authorization endpoint)是用来和资源所有者交互的, 资源所有者在这里进行登录(身份认证), 然后通过该端点可以对客户端进行授权(authorization grant). 授权服务器首先要验证资源所有者的身份, 但是验证的方式并不在OAuth2的协议范围内. Token端点(token endpoint), 客户端通过向token端点展示它的授权(auhtorization grant)或refresh token来获取access token. 除了implicit之外所有的授权类型都需要使用该端点, 因为implicit的access token是直接发行的.  OpenId Connect   身份认证与授权\n OAuth 2.0 不是身份认证(Authentication)协议, OpenId Connect 可以进行身份认证(Authentication).\n一个比喻:\n授权: 生牛奶 (多用途原料).\n身份认证: 奶茶 (一个最终产品), 以牛奶为主原料. OAuth 2.0, 生牛奶, 众多web安全架构的一种多用途的基本成分. OIDC, 奶茶, 基于OAuth 2.0的身份认证协议, 添加了一些组件来提供身份认证的能力.    更高级的协议, 扩展并替代了OAuth2\n OpenID Connect是建立在OAuth2协议上的一个简单的身份标识层, 所以OpenID Connect兼容OAuth2.  使用OpenID Connect, 客户端应用可以请求identity token, 它会和access token一同返回给客户端应用. 这个identity token就可以被用来登录客户端应用程序, 而客户端应用还可以使用access token来访问API资源. UserInfo端点, (OAuth2定义了Authorization端点和Token端点)它允许客户端应用获取用户的额外信息.  定义了不同类型的应用如何从身份识别提供商(IDP)安全的获取这些token    与OAuth 2.0之间的角色映射关系\n身份提供商(Identity Provider, IdP)\n依赖方(Relying Party, RP, 可以理解为客户端)\n OAuth2里可以分为两部分: 1.资源所有者/客户端应用, 2.授权服务器/被保护资源. 身份认证协议里也是两大部分: 1.依赖方, 2.身份提供商. 映射OAuth 2 \u0026mdash;- OIDC  授权服务器/被保护资源 \u0026mdash;- 身份提供商进行映射 资源所有者 \u0026mdash;- 最终用户 客户端应用 \u0026mdash;- 依赖方(RP).\n      抽象流程\n 依赖发(RP)发送请求到OpenID提供商(OP, 也就是身份提供商). OpenID提供商验证最终用户的身份, 并获得了用户委派的授权 OpenID提供商返回响应, 里面带着ID Token, 也通常带着Access Token. 依赖方现在可以使用Access Token发送请求到用户信息的端点. 用户信息端点返回用户的声明(claims, 相当于是用户的信息).\n    身份认证流程  Authorization Code Flow  在Authorization Code 流程里, 一个授权码(Authorization Code)会被返回给客户端. 这个授权码可以被直接用来交换ID Token和Access Token. 该流程也可以在客户端使用授权码兑换Access Token之前对其身份认证. 但是该流程要求客户端的身份认证动作在后台使用client id和secret来获得tokens, 这样就不会把tokens暴露给浏览器或其它可访问浏览器的恶意应用了. 要求客户端应用可以安全的在它和授权服务器之间维护客户端的secret, 也就是说只适合这样的客户端应用. 它还适合于长时间的访问(通过refresh token). 授权码来自于授权端点, 而所有的tokens都来自于Token端点.  Authorization Code流程的步骤如下:  客户端准备身份认证请求, 请求里包含所需的参数 客户端发送请求到授权服务器 授权服务器对最终用户进行身份认证 授权服务器获得最终用户的同意/授权 授权服务器把最终用户发送回客户端, 同时带着授权码 客户端使用授权码向Token端点请求一个响应 客户端接收到响应, 响应的body里面包含着ID Token 和 Access Token 客户端验证ID Token, 并获得用户的一些身份信息.     Implicit Flow(Angular)  Implicit Flow在请求token的时候不需要明确的客户端身份认证, 它使用重定向URI的方式来验证客户端的身份. 因为这一点, refresh token也就无法使用了, 这同样也不适合于长时间有效的access token. 所有的tokens都来自于授权端点, 而Token端点并没有用到. 该流程主要用于浏览器内的应用, Access Token和ID Token一同被直接返回给客户端. 因为这个原因, 这些tokens也会暴露于最终用户和可以访问该浏览器的其它应用了.  它并不适合于长时间的访问. Implicit流程的步骤如下:  客户端准备身份认证请求, 请求里包含所需的参数 客户端发送请求到授权服务器 授权服务器对最终用户进行身份认证 授权服务器获得最终用户的同意/授权 授权服务器把最终用户发送回客户端, 同时带着ID Token. 如果也请求了Access Token的话, 那么Access Token也会一同返回. 客户端验证ID Token, 并获得用户的一些身份信息.     Hybrid Flow  Hybrid Flow是前两者的混合, 在该流程里. 有一些tokens和授权码来自于授权端点, 而另外一些tokens则来自于Token端点. 该流程允许客户端立即使用ID Token, 并且只需要一次往返即可获得授权码. 这种流程也要求客户端应用可以安全的维护secret. 它也适合于长时间的访问.\nHybrid流程的步骤如下:  客户端准备身份认证请求, 请求里包含所需的参数 客户端发送请求到授权服务器 授权服务器对最终用户进行身份认证 授权服务器获得最终用户的同意/授权 授权服务器把最终用户发送回客户端, 同时带着授权码, 根据响应类型的不同, 也可能还带着一个或者多个其它的参数. 客户端使用授权码向Token端点请求一个响应 客户端接收到响应, 响应的body里面包含着ID Token 和 Access Token 客户端验证ID Token, 并获得用户的一些身份信息.     比较\n  Hybrid Flow 根据response_type的不同, 分为:\n response_type=code id_token response_type=code token response_type=code id_token token\n注意:为了表明是OpenID Connect协议的请求, scope参数里必须包含openid   response_type=code id_token\n response_type=code token\n response_type=code id_token token\n  ","description":"","id":41,"section":"code","tags":null,"title":"ex_OAuth2","uri":"http://austinzgx.github.io/code/dotnetcore/oauth2openidconnect/"},{"content":"flask部署 不建议在windows系统上部署flask应用\n准备  IP config MongoDB setup MongoDB-express setup Nginx  linux 系统 * uwsgi  windows系统 * waitress * 编写.bat文件 RunHiddenConsole * 把.bat快捷方式发送开机启动目录  响应 flask默认支持2种响应方式：\n 数据响应：默认响应html文本，也可以返回JSON格式(jsonify()函数) 页面响应：  重定向 redirect('\u0026ldquo;http://www.baidu.com\u0026rdquo;') || redirect('/json') redirect(url_for(\u0026ldquo;视图函数名\u0026rdquo;)）自动解析对应视图函数名称的url地址    响应时，flask也支持自定义http响应状态码\n开发 虚拟环境 python3.5 内置虚拟环境管理工具 venv\n  Create virtual environment\npython3 -m venv venvname\nNote: Add venvname file to .gitignore\n  Active\n  source venename/bin/activate\nOr:\n. nenvname/bin/activate\n deactivate\ndeactivate\n  use pip manager package\npip install flask\npip install --upgrade flask\n​\t= pip install -U flask\npip uninstall flask\npip show flask\npip freeze \u0026gt; requirements.txt\npip install -r requirements.txt\n  helloflask watchlist项目成功部署 2019年11月22日 23:17\nGitHub: https://github.com/xtddw/watchlist.git\nDemo: http://xtddw.pythonanywhere.com\nsayhello  模块（.py) + 构造文件 __init__.py =\u0026gt; 包；当包或者包中的模块被导入时，构造文件自动被执行  ","description":"","id":42,"section":"code","tags":null,"title":"Flask","uri":"http://austinzgx.github.io/code/python/flask/"},{"content":"jupyter  jupyter 0198  1 2 3 4 5 6  @echo off cd \u0026#34;c:\\jupyter\u0026#34; jupyter notebook echo 【按任意键退出】 pause\u0026gt;nul exit   mysql  3306 root 12346  1 2 3 4 5 6  @echo off cd \u0026#34;C:\\MySQL\\Engine\\bin\u0026#34; mysqld --console echo 【按任意键退出】 pause\u0026gt;nul exit   mkdocs 1  mkdocs serve --dev-addr=0.0.0.0:5858   zhtj  ID ggcjdss9/  server  10.30.0.14 enfiyjy-svr\\svradmin ggcjdss9/  ","description":"","id":43,"section":"it","tags":null,"title":"sercet","uri":"http://austinzgx.github.io/it/sercet/"},{"content":"一、AI是什么 AI是计算机科学的一个分支，通俗的讲，就是一种高级算法，让机器解决一些原来只用人类才能完成的任务。AI可以说是一门古老的专业，1956年就被提出。经过50多年，计算机能力提到大幅度提升，深度神经网络等技术的发展，一举凭借AlphaGo围棋大获全胜，AI已经被炒的非常火热，达到潮流顶峰。现以广泛应用于机器视觉，指纹识别，人脸识别，自动规划，智能控制，机器人学，语言和图像理解，遗传编程等。\n我们既不是专家，也不是专门研究这种领域的学者，有没有简单的方法直接辨别什么是人工智能，什么是伪人工智能？答案是有的。\n举一个简单的例子，之前人们也尝试教计算机下国际象棋。计算机经过学习之后，与人们依然互有胜负，在最终完全战胜人类的时候，时间已经过去了10年。而谷歌的AlphaGo，从什么都不会到围棋中不可战胜的存在只用了短短一年的时间。由此可以看出，真正的人工智能体现在其卓越的学习能力。\n如果你隔一段时间，大概3个月左右去看一个算法的进步，比如面部识别，如语音识别，如果该算法进步只是代数级，没有达到指数级，那么这种算法可能更多的是机器学习，还未达到人工智能水平。\n既然已经辨别了什么是真正的人工智能，那么对于人工智能而言，什么才是最重要的。可能有些人会说算法，有些人会说设备，有些人会说编程技术。虽然它们也是构成人工智能中重要的一环，但是这些都不是最重要的。\n对于真正的人工智能而言，最重要的永远是大数据，只有拥有完整的数据，人工智能才能真正的发展起来。就像是一把宝刀，需要有一块好的磨刀石才能让它更加锐利，而大数据恰好就是这块最好的磨刀石。 就像是谷歌的AlphaGo，有人说为什么AlphaGo不去下象棋，而是只在围棋领域中称雄呢。\nAlphaGo的专家则表示，不是他们不想这么做，而是无法这么做。因为在围棋中，日本人一直以来有保存棋谱的习惯，在每个棋谱上都标注了什么是第1手，什么是第100手，这样很容易被AlphaGo学习。 但是对于象棋来说，自古以来大多数都是残局。虽说残局也很精彩，但是对于AlphaGo来说，它不知道残局形成的原因，对之前的步骤一无所知，这样就会对它的认知造成障碍。 这也说明，完整的数据对于人工智能多么重要。任何抛开数据谈人工智能的，全都是耍流氓。\n二、中国AI现状 现在大多数人工智能都属于伪人工智能。为什么这么说，可以从以下两个方面来解释。\n第一，人工智能不是一下就能做出来的，需要时间以及实验的积累。而做出人工智能的这些人才也是一样，他们需要切实的接触到真正的人工智能当中，不过这样的人才在全世界也就寥寥几百个。但是好像在一瞬间，在中国就有几万个人工智能方面的人才被选拔了出来，可想而知这样的人才是真正的人工智能专家吗？这些人才往往被大公司冠以年薪30万或50万疯抢，虽然里面的确有很多优秀的人才，但是这样未免显得太过着急。从人才培养角度来看，人工智能领域还存在着大量的泡沫。\n第二，许多项目只不过是换了个‘马甲’。许多创业公司喜欢为自己的项目贴上一个标签，这样的话不但可以吸引眼球，更能得到投资人的青睐。虽然不能说这种做法是错误的，但这显然也不是真正的人工智能，甚至会误导其他人对于人工智能的认知。\n比如许多项目在贴上人工智能标签之前非常简单，只是一些如同机器人学习，或者算法研究之类的项目，如今摇身一变全都成为了人工智能。\n三、投资及发展方向 综上所述，人工智能是技术，数据是人工智能的核心。人工智能自身不能够成为投资领域，需要与具体的行业结合应用，成为投资点。如与医疗行业结合，开拓智能医疗业务。\n中国大部分互联网数据被BAT（百度、阿里、腾讯）掌握，对于投资而言，直接与巨头合作互联网AI应用自然是第一选择，但BAT他们不缺投资。其次瞄准医疗、金融、工业都还没形成数据垄断的行业，都掌握在医院、金融机构、实体企业，在各个行业内寻找优质合作方，获取核心大数据，应用人工智能技术，形成垄断。\n结合自身专业背景和工作方向，下面具体叙述人工智能技术在行业专家的合作存在的一些问题，并谈谈自己的想法。\n有色冶炼行业是属于典型的流程型制造行业，生产企业每时每刻都在产生大量的生产、运营、管理的数据，但目前这些数据只是用来监视生产、绩效考核这些简单的业务应用，剩下时间都静静地躺在数据库中，直到过了有效期后销毁。\n人工智能技术可以拯救数据，让他发挥无穷地功力。从数据挖掘到生产作业的最优方案，关键设备状态的预判断，人员安全健康情况分析。\n目前BAT这类大公司也已慢慢从饱和的互联网转型实体行业，纷纷研究如何与行业结合人工智能技术，效果不佳的原因在人，BAT大公司的人工智能技术专家不懂有色冶炼，听不懂生产企业的需求和技术关键点。同样，资深的冶炼工艺专家不理解什么是人工智能技术，无法将自己的理解和专业，转化成计算机模型的方式表达。沟通成了问题，人才成了最大的问题。\n个人觉得还是应从资深的行业专家入手，培训其思维意识，不用掌握具体的人工智能技术，对其要求就是能将自身需求描述成人工智能专家能明确的目标。因为要求人工智能专家学习专业背景知识困难太大了，也不会有多少成效，现阶段成功的一些应用如人脸识别，往往都是专业知识背景比较简单，基本算共识知识。但是要想在具体的行业有所突破，真正需要理解人工智能的行业专家和了解行业的人工智能专家。\n","description":"","id":44,"section":"sf","tags":null,"title":"AI之我见","uri":"http://austinzgx.github.io/sf/ai/"},{"content":"   title author status     小王子 圣埃克苏佩里    围城 钱钟书    活着 余华    1988我想和这个世界谈谈 韩寒    平凡的世界 路遥    明朝那些事儿 当年明月    万历十五年 黄仁宇    1Q84 村上春树    边城 沈从文    许三观卖血记 余华    文化苦旅 余秋雨    三国演义 罗贯中    兄弟 余华    麦田的守望者 J.D    白鹿原 陈忠实    北京法源寺 李敖    呐喊 鲁迅    乌合之众 勒庞    阿Q正传 鲁迅    如何阅读一本书 艾德勒    乔布斯传 艾萨克森    长恨歌 王安忆    京华烟云 林语堂    飞鸟集 泰戈尔    解忧杂货店 东野圭吾    三体 刘慈欣     1.科普类\n《上帝掷骰子了吗》：以文学家的视角讲述量子力学\n2.中国历史类\n《吕氏春秋》\n《汉朝那些事》\n3.财经类：Adam Khoo老师的书\n《Winning The Game Of Stocks》\n《Secret Of Self Made Millionaires》\n","description":"","id":45,"section":"life","tags":["Read","Book"],"title":"Book","uri":"http://austinzgx.github.io/life/book/"},{"content":"概述  主流工艺：锌精矿焙烧制酸+常规两段浸出/氧压浸出+三段净化+电解熔铸+浸出渣处理（回转窑/侧吹+烟化）\n株冶主流程图：\n 焙烧炉：109m2(10万t/a)-\u0026gt;152m2(西北铅锌、株冶15万t/a) 电解：（电积）1.6小板/3.2大板 直流电耗～3000kwh  ##工艺分类：\n火法炼锌  竖罐炼锌 横（平）罐炼锌 密闭鼓风炉炼锌（ISP法） 电热（炉）炼锌  湿法炼锌  传统-两段浸出渣挥发法\n常规法（或称联合法）：两段浸出（中性浸出、低酸浸出），一般酸浸渣经过滤干燥，回转窑挥发回收Zn、Pb、In等有价元素，多膛炉或回转窑脱F、Cl、氧化锌浸出等；\n酸度 PH 3.2 渣率 ～50％ 成分     Zn Pb Cu Cd Fe S As F Bi Ag In     18.5~23.36 3.16 0.81 0.36 25 6.83 0.37 0.024 0.03 0.0262 0.012    浸出系统操作简单，浸出率基本不用担心指标限制，但仅渣处理系统就非常庞大，工程投资相对高，运行成本也高。\n  高温高酸\n   黄钾铁矾法         成分 ZnT Zn酸 Zn水 FeT Fe可 Cu Cd Co S PbAg SiO2 Mn Mg SO42-H2O In As     高浸渣 3.78 2.72 2.23 26.76 24.04 0.28 0.214 0.02 12.36 0.34 86.87 5.2 0.74 0.19 10.47 21.3 ~220    铁矾渣形成的基本原理\n低污染沉矾法除铁过程需要加中和剂，而且几乎所有采用常规黄钾铁矾工艺沉矾法生产的厂家都用锌焙砂作中和剂，这样就不可避免地使部分未溶解的锌及有价金属残留于铁矾渣中，导致锌及有价金属的损失，同时也污染铁矾渣，不利于环境保护和矾渣的进一步处理。另外低污染沉矾除铁在沉矾时，由于离子取代作用，砷、锑所形成的阴离子可以取代铁矾晶格中的硫酸根，而后，CL、F取代晶格中的OH-，使溶液得以净化。\n低污染（黄钾铁矾）沉矾除铁\n* 将预中和溢流液加入碳酸氢铵和碳酸氢钠进行低污染沉矾除铁，将低污染沉矾溢流液返回中性浸出槽，沉矾渣回收金属铟或作微肥。\n* 沉矾除铁条件为：始酸10～18 g/L，终点Fe≤3.5 g/L，反应温度90～95℃，反应时间4h。\n主要反应式:\n3Fe2(SO4)3+10H2O+2NH4HCO3=(NH4)2Fe6(SO4)4(OH)12+5H2SO4+2CO2\n3Fe2(SO4)3+12H2O+Na2SO4=Na2Fe6(SO4)4(OH)12+6H2SO4\n3Fe2(SO4)3+10H2O+2NaHCO3=Na2Fe6(SO4)4(OH)12+5H2SO4+2CO2\n3Fe2(SO4)3+10H2O+2NH4OH=(NH4)2Fe6(SO4)4(OH)12+5H2SO4\n* 2. 针铁矿法\r* 3. 赤铁矿法\r* 4. 喷淋除铁法\r    成分 ZnT Zn酸 Zn水 FeT Fe可 Pb Ag SiO2 Mn Mg Cu Cd Co S SO42- H2O In As     高浸渣 6.08 4.97 3.89 16.36 14.42 4.53 185.35 10.30 2.46 0.31 0.43 0.48 0.03 10.72 15.23 15.19 211.39 -    全湿法冶炼  常压富氧直接浸出 氧压直接浸出 氧化矿浸出法以及萃取法  现状 ☆ 2017年我国锌产量达622万吨，全球锌总产量约为1330万吨，约占世界46.7%产量。（2016年全球锌总产量为1340万吨，2016年中国锌产量为627.3万吨，按照国际有关部门统计报道，中国为598万吨，占全球44.5%）。人们不再盲目追求产能，仅管锌市场行情好转，但产能并没有随之而动。\n☆中国锌冶炼总体不但规模大，而且整体锌冶炼行业集中度更高，目前30万吨规模就有6家，20万吨以上企业近12家，仅此就占全国总产量一半以上。十年前锌冶炼企业300多家，现在仅剩不足100家。工艺技术也在不断完善，整体水平跃上新的更高平台。\n☆主要产量目标：“十三五”期间十种有色金属产量控制在6000万吨左右，其中：锌750万吨（锌增长率5.5%）。再生金属到2020年总产量达到1650万吨，其中：再生锌200万吨。\n我们将面临950万吨总锌产量规模。去产能就不会突破这指标；\n由此产生的渣量基本上与锌产量成正比，如何处理这些渣是我们必须面对的严峻问题。\n☆今年初以来，国资委多次表态，今年有色金属等行业加大去产能力度。这是首次被列入压缩产能的行业，按照这个基调锌的产能估计能维持目前水平就不错了，今后新建工厂越发困难。\n特点 ☆中国锌冶炼行业的特点是工艺齐全，世界上无论哪种工艺流程在中国都使用过，可谓铅锌冶炼世界大全，或称世界博物馆；\n☆中国锌产量占世界47％以上，技术贡献与产能不相称，尤其是研发能力差（新工艺、核心设备），我们付出能源、环保代价远远高于得到的效益。\n☆技术发展不平衡；有些企业已跨入国际锌冶炼的先进行列；但还有相当多的锌冶炼企业工艺落后、生产装备比较原始，工人作业环境非常恶劣，经济效益不理想，急需寻求出路。\n国内主要生产企业    序号 企业名称 产能 2017年产量     1 株冶集团 55 42.8   2 南方有色 30 33.1   3 汉中锌业 36 29.1   4 葫芦岛锌业 39 27.8   5 白银公司 37 27.4   6 豫光金铅 30 27.1   7 驰宏锌锗 26 23.5   8 赤峰中色 22 22.8   9 陕西锌业 22 21.4   10 中金岭南 30 21   11 陕西东岭 23 20.2   12 巴彦淖尔紫金 25 19.7   13 云铜锌业 16 16.4   14 江铜铅锌公司 10 11.0   15 兴安铜锌公司 13 10.5   16 安徽铜冠九华 10 10.3   17 呼伦贝尔驰宏 14 10.0   18 四环锌锗 12 9.7   19 四川宏达 10 7.5   20 祥云飞龙 18 7.4       集团 冶炼企业 产能(万t/a) 设计院 备注     驰宏锌锗  60      曲靖  恩菲 常规浸出，2019侧吹渣处理    会泽 \u0026lt;++\u0026gt; 恩菲 常规浸出，2019铅冶炼改造侧吹渣处理,APC    云铜新业 \u0026lt;++\u0026gt; \u0026lt;++\u0026gt;     呼伦贝尔 \u0026lt;++\u0026gt; 长沙院 氧压浸出    金鼎 \u0026lt;++\u0026gt; \u0026lt;++\u0026gt;    白银有色  40 \u0026lt;++\u0026gt;     西北铅锌厂 \u0026lt;++\u0026gt; 恩菲 常规浸出，应用在线钴镉检测，2021年投产侧吹渣处理    成洲冶炼厂 \u0026lt;++\u0026gt; 恩菲     第三冶炼厂 \u0026lt;++\u0026gt; 长沙院 ISP   葫芦岛锌业  39 恩菲 常规浸出，少量ISP, 回转窑渣处理   陕西有色汉中锌业  36 西安院、中联 黄钾铁矾法，回转窑渣处理   紫金集团  35      巴彦淖尔 \u0026lt;++\u0026gt; 恩菲 黄钾铁矾法，回转窑渣处理    新疆喀什 10 恩菲 2020年新建，常规浸出，回转窑渣处理，109m2, 3.2大板   株冶有色  30 恩菲 2018年搬迁水口山60-\u0026gt;30，氧压浸出，2*152m2, 1.6小板   南方有色  30 长沙院 常规浸出，回转窑渣处理   豫光锌业  30 恩菲 常规浸出，回转窑渣处理   陕西有色陕西锌业  20 恩菲 常规浸出，回转窑渣处理   陕西东岭  20  ISP   铜陵有色  10 恩菲     池州九华铅锌 10 恩菲 2011年，109m2，1.6小板    主要流程工艺 西北铅锌治炼厂 西北铅锌治炼厂是国家“七五”计划重点建设项目之一。1986年 9月8日动工建设,1992年5月1日锌系统焙烧炉点火成功,当年锌 系统投入生产。主要工艺流程为配料、焙烧、浸出、净化、电解、熔 铸、治炼尾气制酸、铅银渣处理、合金锌粉生产等九大主要生产系统 主要产品有锌锭、工业硫酸和精镉等产品。\n配料系统是根据冶炼工艺需要,将不同锌含量及杂质含量锌精矿 按配料计算比例进行配料,通过皮带运至沸腾焙烧炉料仓。\n焙烧系统采用采用流态化焙烧工艺,选用109m2大型鲁奇式沸 腾焙烧炉。炉料(ZnS)从炉侧通过给料机加入炉内,空气从炉底侧 鼓入参与反应。反应生成的焙砂(ZnO)经炉壁下部排出,进入圆筒冷却器冷却后由刮板传送至球磨机细磨后送至焙砂仓。沸腾焙烧炉出的SO2烟气经余热锅炉回收余热及部分烟尘后再经漩涡收尘器和电收尘器回收全部烟尘后送往制酸系统,余热锅炉、漩涡收尘器及电收尘器回收的烟尘由刮板输送至球磨机球磨后送至焙砂仓。\n浸出系统采用两段热酸浸出一黄钾铁矾工艺,该工艺分中性浸出、两段热酸浸出、予中和及两段沉矶等工序。焙砂主要从中性浸出工序加入,与沉矾上清液和电解废液混合液发生中和反应,反应生成的硫酸锌进入溶液,反应结束后,矿浆进入浓密机完成液固分离,上清液送往净化系统,中浸浓密机底流(中浸渣)由泵送至两段段热酸浸出工序,在高温下(大于85℃),与电解废液和浓硫酸溶液混合液反应,矿浆进入浓密机沉降分离,底流由泵送往压滤工序分离铅银渣, 铅银渣送往渣处理系统。热酸浸出上清液经予中和工序进入两段沉矾 除铁)工序,加碳酸氢铵和硫酸氢钠除铁再进入浓密机进行液固分离,浓密机底流由泵送往压滤工序分离铁矾渣,上清液由泵送往中性浸出工序。\n净化系统采用三段连续逆锑浄化工艺,分一段净化、二段净化及三段净化工序。中上清液先进入一段净化工序,在低温下加锌粉除去溶液中铜镉后过滤,滤渣即铜镉渣送制镉系统,滤液进入二段净化工序升温加锌粉锑盐浄化除去溶液中钴镍后过滤,滤渣即钴镍渣 送处理,滤液再经三段加锌粉净化除去残镉后过滤,滤渣返回一段净化工序再利用,滤液即新液送电解系统\n电解系统采用不溶阳极电解沉积工艺,新液与废电解液以一定的比例混合后连续注入电解槽,阳极为铅银合金板,阴极为纯铝板,在直电的作用下溶液中锌离子以锌金属的形态在阴极析,当阴极锌(99.995%)析出达一定厚度时,利用天车将阴极分批从电解槽吊出,剥离阴极锌片后的阴极板再装入电解槽继续进行电解,阴极锌片送至熔铸系统,废液部分送浸出系统,部分返回本系统经冷却塔与新液混合进入电解槽。\n熔铸系统选用工频感应电炉设备熔化锌片。利用天车将电解系统生产的阴极锌片吊至加料平台,由自动加料设备将锌片加入熔锌感应电炉内,控制相应的炉温,待锌片熔化后,加入适量的氯化铵,搅动机出浮渣,由精锌铸锭码垛机组铸锭及自动码垛,人工捆扎后贮存或外运,锌浮渣送电炉合金锌粉生产系统生产合金锌粉。\n硫酸系统采用双转双吸工艺。治炼SO2烟气由高温排烟机送至硫酸系统净化工序,经沈涤器、电除雾器、干燥塔、SO2鼓风机換热器、转化器、吸收塔等主要制酸工艺设备产出工业硫酸(产品分93%硫酸,98%硫酸)。制酸尾气的排放达到国家排放标准。酸性废水采用能有效除去As、Cu、Zn等重金属离子的硫化法处理。脱出重金属离子后的酸性废水采用石灰中和,处理后的外排水的水质达到\n国家排放标准。\n电炉合金锌粉生产系统采用国内最大的3150KVA矿热电炉生产合金锌粉,将锌焙砂、锌浮渣或较富的氧化锌精矿、碳质还原剂、熔剂等按照治炼要求的配料比均匀混合经干燥窑干燥后进入电炉还原熔炼,脉石熔化造渣,还原得到的锌蒸汽随高温烟气进入冷却器,急速冷却后被收集,再经过筛分工序得到合格的合金锌粉\n铅银渣处理系统采用国际先进的富氧顶吹熔化、烟化炉挥发铅锌 工艺。铅银渣经干燥窑干燥后送至熔炼炉,富氧从熔化炉顶部鼓入熔 池,烟气经余热锅炉回收余热和烟尘,进入布袋收尘器再次回收烟尘后送至烟气脱硫系统生产纯SO2气体,纯SO2气体送硫酸系统制酸,烟尘送往氧化锌浸出车间,熔渣进入烟化炉挥发铅锌等金属,烟化炉渣采用水淬处理,产出水淬渣,烟气经布袋收尘器送往脱硫系统,烟尘送至氧化锌浸出系统。\n新疆紫金锌业   化工\n  烟气（SO2:8.21%) =\u0026gt; 净化 =\u0026gt; 两次转化 =\u0026gt; 两次吸收 =\u0026gt; 尾气脱硫\n  高效洗涤器-气体冷却塔-一级电除雾器-二级电除雾器-干燥塔-SO2风机-一次转化-中间吸收-二次转化-最终吸收-尾气脱硫-尾气烟囱\n  净化：根据绝热蒸发原理对烟气300+-20℃进行降温85℃、除尘、除雾；\n  转化：SO2 + O2 = SO3 触媒\n  吸收：SO3 + H2O = H2SO4\n  净化工序产生对污酸送废水处理站\n废酸经收集进入调节池进行水质水量调节，然后进入硫化反应池，采用硫化钠与废酸中的重金属反应，经两级硫化反应后出水进入一体化沉淀池，加入絮凝剂进行固液分离，分离后上清液经中间池排入后续酸性废水处理站处理；分离后的底流经污泥槽收集后用泵打入压滤机压滤，压滤后滤液排入调节池，压滤后的滤渣为危废渣，临时堆存至一定量后外送危废处理站处置。\n现场设置事故池，系统处理不达标废水或现场跑冒滴漏废液通过事故池收集后，重新打入系统处理；各池体产生的尾气经收集后进入尾气吸收塔。\n  制酸尾气与渣处理回转窑烟气、脱氟氯回转窑烟气 =\u0026gt; 尾气脱硫 =\u0026gt; 烟囱外排（GB25466-2010《铅、锌工业污染物排放标准》\n    热工\n 余热锅炉 工业锅炉 化学水处理站 余热发电站 化学水处理站供应余热锅炉和工业锅炉补充水。化学水处理站工艺流程采用多介质过滤器+反渗透+混床,该系统简单、技术成熟、运行费用较低,废水排放易达标. 产品为除盐水。    给排水\n 生产新水+ 生活水 + 循环水 生产水： 水库-生产水处理净化水站-生产消防高位水池 生活水： 市政管网自来水公司 软化水：（除盐水）化学水处理站    行业现状与需求 白银有色西北铅锌厂  现状   老系统\n铅锌厂老系统已投产20多年,其中焙烧、硫酸系统2010年经过技术改造已实现设备升级及DCS控制,熔铸系统已于2019年通过改造实现自动浇铸、打包生产,扒皮、打码也于2020年 实现了自动化,目前主要的设备与控制短板在于老湿法系统。由 于各种原因制约,老湿法系统一直未进行自动控制系统升级改造 工艺控制主要依靠人工经验调整,工艺参数控制不准确,难以实 现系统的稳定、连续及高效运行。\n  新系统\n铅锌厂新系统在建设之初即考虑采用行业内成熱先进设备和控制技术提升自动化水平,火法系统各工序基本上分别实现设备升级及DCS控制,熔铸系统实现自动浇铸,打包生产自动化 湿法新系统生产控制系统采用目前行业较为成熟,先进的DCS控制系统,基本实现了设备运行的在线监视、自动控制;\n工艺流程涉及的温度、流量、压力、液位等仪表监测信号与电气控制信号全部集成于DCS自动控制系统,控制系统依据工艺流程设计,具备故障报警功能,控制界面清晰易懂、操作方便、运行稳定;\n湿法系统主要工序泵用电机加装变频器控制,其余设备加装电机保护器,实现软启动且依据工艺要求随时调整电机功率来实现流量调整;主要工艺管道阀门采用自动控制执行机构,实现远程开闭;\n电气系统配套使用安全性更高与支持自动控制的低压柜\n   需求  推进在线监测系统应用（长沙华时捷西北铅锌厂应用钴镉在线系统 应用熔铸系统生产线机器人自动扒渣扒皮机器人，引进自动称重、贴标一体机、手持式扫码机及锭垛输送机,进一步提升熔铸自动化水平,降低劳动强度,提升岗位员工.生产安全性 应用管道结晶自动化清理技术,降低岗位人员劳动强度,提高管道结晶物清理效率 创建焙烧一硫酸系统操作数模,实现风、料及炉温度等科学化全过程控制,解决原料成分复杂多变对生产的影响 引进熔铸生产线自动称重、贴标一体机、手持式扫码机及锭垛输送机,进一步提升熔铸自动化水平 实施锌精矿自动取样装置项目,解决取样过程中人工劳动强度大的问题,提高取样效率和取样代表性 实施“锌电解整体工艺重金属废水智能化源削减大型成套装备研发及工程示范” 项目,实现电解短路识别自动剥锌、阴阳极板智能化清理,堿少人力资源需求量 实施“基于物联网和工业大数据的锌电积节能系统开发”项目,降低锌电积能耗。    焙烧 目的及意义 为了提升锌精矿焙烧过程的效率，需要对焙烧过程的机理和沸腾炉的特性加以研究，\n分析不同工艺条件对于焙烧过程的影响，从而给出焙烧过程的最优控制方案。\n本方案主要从控制的角度出发对焙烧过程进行优化，\n 首先根据焙烧过程和流化床的工艺机理建立焙烧过程的机理模型，\n并通过焙烧过程的历史运行数据来对机理模型进行一定的修正。\n通过这个修正的焙烧过程数学模型分析锌焙砂进料量和鼓风量等因素对焙烧过程的影响。 然后,对锌精矿进行矿物学分析，分析锌精矿的品位、杂质离子含量、粒度和粒度分布，\n根据不同的配料组成基于焙烧过程数学模型确定不同锌精矿进料时焙烧炉的最优操作条件，\n通过对进料量的调节实现炉内温度场的稳定控制。 最后，通过大数据系统不断对焙烧过程的数学模型进行修正提高模型的准确性和有效性。  因素分析 焙烧过程是湿法炼锌过程中第一道也是极为重要的一道工序。\n在焙烧过程中，将配料过程配好的锌精矿送入到焙烧炉中进行充分的燃烧，产生锌焙砂、二氧化硫和烟尘等产物，\n焙烧炉中发生的主要反应为：\n 2ZnS + 3O2 == 2ZnO + 2SO2\n 由于反应温度、氧含量和流态化状态等一系列因素的影响，在锌精矿焙烧的过程中还伴随有一定的副反应发生，\n生成铁酸锌等不溶锌产物，导致锌焙砂的可溶锌率降低。\n因此，为了提高锌焙烧的产量以及锌焙砂的可溶锌率，需要对锌精矿焙烧过程进行优化控制。\n焙烧过程主要生产流程为：\n 锌精矿储存在储罐中，通过皮带秤送到进料口进行投料； 空气从炉底的进气口进入，然后通过多个均匀分布在炉底的喷嘴送入到焙烧炉中; 焙烧过程的主反应发生在焙烧炉中的沸腾层，温度通常控制在920~930℃。锌精矿和O2发生放热反应产生锌焙砂和SO2等产物; 锌焙砂在沸腾层的溢流口排出，通过冷却后送往锌焙砂储罐； SO2气体和烟尘则从炉顶的出口排出。  对整个生产流程和产品质量影响最大的是沸腾层温度以及锌精矿的组成，因此对焙烧过程的优化主要从这两个方面进行考虑。\n焙烧过程发生的主要区域为焙烧炉中的沸腾层，而沸腾层则是一个典型的流化床反应器，炉底吹入的空气使得锌精矿颗粒在焙烧炉中处于一种悬浮运动状态，并且空气中的氧气发生反应，生成锌焙砂和SO2等产物。流化床反应器具有许多的优点，其中对于锌精矿焙烧过程而言最主要的优点为：\n 可以实现固体物料的连续输入和输出：湿法炼锌过程是一个连续生产的过程，焙烧炉的可连续生产能够满足后续生产过程\n对原料的需求。 具有良好的传热性能：流体和颗粒的运动使床层具有良好的传热性能，床层内部温度均匀，而且易于控制，特别适用于强放热反应。  锌精矿焙烧过程中会产生大量的热量，由于沸腾床层内传热系数很大，沸腾层内各部分温度几乎一致，\n可通过对锌精矿进料量的调节控制沸腾层内温度在±10℃波动。而影响床层流态化的主要因素有3个：\n   炉内的气量和气速  由于对沸腾层温度的调节是通过调节锌精矿进料量来实现的，在调节温度时进料量的变化会对沸腾层的流态化产生影响，因此在对锌精矿进料量进行调节时需要对风料比加以考虑。\n为加强焙烧过程，增大生产率，一般要求有较大的气速，但增大气速就相应地增多烟尘的生成而降低焙砂的产量。因此，需要对风料比进行调节，通过对进料量的控制来控制炉内的气速，使得沸腾层能够处在一个最佳的流态化状态。\n此外，进料量的变化还会影响到炉内的氧气含量，所以调节进料量时还需要考虑焙烧过程对氧气的需求。\n  锌精矿的粒度和粒度分布  锌精矿的粒度和粒度分布也是影响沸腾层流态化的重要因素。\n炉内焙砂粒度越细，沸腾层的有效黏度越大，其临界速度和带出速度越小，则在生产过程中产生的烟尘量就越大，这不符合沸腾焙烧生产的工艺要求。\n在同一操作速度下，焙砂的粒度越大，在沸腾层内形成的气泡就大，当沸腾层内形成大气泡集中向上涌时，沸腾层就会被分割，大气泡将整个上部物料抬起，造成大量物料被气泡带走，形成“沸涌”现象。\n如果焙砂粒度差距过大，气体就不能均匀地流过沸腾层，如果不均匀性严重，可能形成部分区域流动慢、部分区域流动快的状况，甚至形成部分区域“死区”，出现“沟流”现象。\n因此，在焙烧过程中要对锌精矿的粒度加以充分的考虑，针对不同粒度和粒度分布的锌精矿来对焙烧过程的生产过程进行调整。\n  锌精矿中的杂质含量  锌精矿中铁离子和二氧化硅的存在会导致焙烧过程中铁酸锌和硅酸锌的生成，从而导致锌焙砂可溶锌率的降低； 铅离子以及二氧化硅的存在则会导致生产过程中沸腾层烧结以及沸腾炉结垢等情况的出现。 因此，在生产过程中要根据锌精矿中各类杂质离子的含量来对生产条件进行调整。\n一般地，锌精矿中铁、二氧化硅含量高时，温度宜取低值，尽量少生成铁酸锌和硅酸锌，以提高锌的可溶率； 反之，当原料矿中的铁、二氧化硅含量低时，焙烧生成的铁酸锌、硅酸锌己很少，对锌的可溶率影响很小，可适当提高焙烧温度，并兼顾降低焙砂残硫；\n原料矿中砷和锑含量高时，温度宜取低值；反之，当原料矿中的砷和锑含量低时，可适当提高焙烧温度。\n  正是由于以上3个因素对沸腾层流态化的影响，使得焙烧过程中沸腾层温度变化幅度很大、停留时间不一，\n导致锌焙砂的可溶锌率反复波动，甚至出现产品不合格的情况。\n目前锌精矿焙烧过程的控制方法是通过人工经验对锌精矿的进料量进行调节，\n而不是通过对锌精矿的组成和炉内的反应工况进行分析来对进料量进行调整，导致沸腾层温度波动大，产品可溶锌率低。\n因此，亟需研究锌精矿焙烧过程的反应机理、锌精矿组成的矿物学分析、焙烧过程的工艺参数优化以及智能控制方法，\n并以此来提高焙烧过程的处理量和可溶锌率，为后续工艺的生产提供保障。\n优化需求 锌精矿焙烧过程优化控制的总体目标是通过对炉的控制来提高经济效益，主要体现在高效、安全和绿色三个方面。\n其一是通过改变控制策略增加锌精矿的使用弹性；\n其二是在平稳运行的前提下增加进料量以及提高运行时间，从而整体上提升经济效益以及产品质量。\n焙烧过程目前的关键需求主要是保证沸腾炉的连续运转，实现产量的最大化，提高锌焙砂的可溶锌率。\n为了保证沸腾炉产量的最大化，一般会尽可能的增加锌精矿的进料量同时保证最大的鼓风量，这样会导致沸腾层的温度上升。\n为了维持沸腾层的标温，通常会将循环冷却水的用量调到最大，以实现产量的最大化。\n焙烧的主要目标\n 使物料中的Zn尽可能地全部转化为可溶锌(ZnO)； 降低焙砂中的不溶硫(S2-)含量； 保留少量的硫酸盐，以补偿浸出和电解过程中损失的硫酸； 尽可能少的生成铁酸锌，尽可能地脱除砷和锑，尽可能减少可溶硅含量。  实现这些目标的主要方法是控制沸腾层的温度在最优温度范围内，同时降低沸腾层温度的波动。\n由于循环冷却水的用量和鼓风量一般是调到最大来保证产量最大，所以控制沸腾层的温度一般由锌精矿的加料量来控制。\n加料量的变化会对炉内风速和氧气含量产生影响，对此可以根据进料的锌精矿的性质\n（锌的品位、杂质离子含量、粒度和粒度分布等），通过最优的风料比对进料量进行调节，\n在保证产量最大化的情况下实现炉内温度场的稳定控制。\n实现方式 根据锌精矿焙烧过程优化控制的设计思路，主要的实现方法包括以下三个方面：\n 基于机理和数据的锌精矿焙烧过程数学模型   锌精矿焙烧过程主要发生在焙烧炉中的沸腾层，沸腾层的流态化状态会直接影响到沸腾层的温度，从而影响到沸腾层的标温。\n  理论上可以通过调节进料量和鼓风量这两个关键参数来对沸腾层的标温进行控制，\n但是实际生产过程中一般是将鼓风量调到最大来保证产量的最大化，而只通过调节进料量来对沸腾层的标温进行控制。\n  为了提高控制效果，降低沸腾层标温的波动，提高锌焙砂的可溶锌率，需要建立锌精矿焙烧过程的数学模型，\n对关键参数的设定值进行优化，从而实现焙烧过程的优化控制。\n为了获得锌精矿焙烧过程的数学模型，需要深入研究锌精矿焙烧过程的工艺机理，\n通过工艺机理建立锌精矿焙烧过程的机理模型，建立起沸腾层标温与鼓风量、进料量、锌精矿成分以及焙砂成分之间的关系模型，\n然后利用大数据系统中有效的现场数据来对机理模型进行校正。\n建立锌精矿焙烧过程的数学模型是实现锌精矿焙烧过程优化控制的基础。\n 锌精矿的矿物学分析   锌精矿焙烧过程的优化控制不仅与鼓风量、进料量以及风料比等关键参数有关，还与锌精矿的性质有很大关联。\n  锌精矿中锌的品位和硫的含量是影响焙烧过程和锌焙砂可溶锌率的的关键因素；\n  锌精矿中的杂质离子会对焙烧过程产生影响，不仅降低了锌焙砂的可溶锌率还有可能会导致结垢等情况的出现，直接影响生产过程的运行；\n  锌焙砂的粒度和粒度分布会对沸腾层的流态化状态产生很大的影响，粒度过大或过小以及粒度分布不均都会降低焙烧过程的生产效率。\n  因此，锌精矿的矿物学分析对于焙烧过程的优化控制是不可或缺的。对矿物学进行研究，研究锌精矿组成和粒度对焙烧过程的影响，可以提升配料过程所带来的收益，增加锌精矿使用的弹性，提高经济效益。\n 锌精矿焙烧过程关键参数的优化和控制   目前株冶有色锌精矿焙烧过程是凭借经验对锌精矿的进料量进行调整来对沸腾层的温度进行控制的。\n这样的控制方法可以有效地利用操作员的经验，但不能实现最优的控制，导致沸腾层温度不断波动。\n对此，本项目在锌精矿焙烧过程的数学模型以及锌精矿的矿物学分析的基础上，结合专家的经验，\n对关键参数的设定值进行优化，给出不同的工况条件下最优的沸腾层标温设定值以及该条件下最优的风料比。\n然后根据最优的风料比对进料量进行调整，实现炉内温度场的稳定控制。\n 浸出 目的及意义  湿法炼锌浸出过程，是以稀硫酸溶液（主要是锌电解过程产生的废电解液）作溶剂，将含锌原料中的有价金属溶解进入溶液的过程。 其原料中除锌外，一般还含有铁、铜、镉、钴、镍、砷、锑及稀有金属等元素。 在浸出过程中，除锌进入溶液外，金属杂质也不同程度地溶解而随锌一起进入溶液。这些杂质会对锌电解过程产生不良影响，因此在电解以前必须把有害杂质尽可能除去。 在浸出过程中应尽量利用水解沉淀方法将部分杂质（如铁、砷、锑等）除去，以减轻溶液净化的负担。 浸出过程的目的是将原料中的锌尽可能完全溶解进入溶液中，并在浸出终了阶段采取措施，除去部分铁、硅、砷、锑、锗等有害杂质， 同时得到沉降速度快、过滤性能好、易于液固分离的浸出矿浆。  因素分析 (1)浸出是湿法炼锌中的核心工序，自动检测是实现智能优化控制的前提\n浸出作为湿法炼锌过程的核心工序，浸出过程的智能化控制对整个锌冶炼企业的智能化建设有重要影响。\n在工业过程中，浸出率是浸出过程最重要的指标，而pH值会通过影响浸出液中各种离子的水解程度来影响浸出率的高低。\n 当pH过高时，Zn(2+)容易水解损失，氢氧化铁胶体带负电，影响杂质的共沉淀分解，浸出率低； 当pH过低时，Fe(2+)的水解沉淀不完全，造成溶液中Fe(2+)浓度偏高。  pH值一般采用人工试纸或便携式pH计检测来判断浸出槽出口处pH值是否符合要求，检测原理简单。然而，采用人工试纸检测或便携式pH检测时，增加人工工作量，且人工检测耗时长，一般需要1-2h检测一次，存在很大的滞后性，给浸出过程的优化控制带来了困难。\n当采用pH计自动检测时，由于浸出液具有高温、强酸的特点，pH计长期浸泡在浸出液中时，电极容易损坏，且在浸出过程中，浸出液中难溶的硫酸盐及其他沉淀会附着在pH计的表面，形成结垢，使电极敏感膜迅速钝化，严重影响电极测量精度及动态响应特性，很大程度上影响pH计的检测精度和使用寿命。\n针对锌浸出过程中pH值难以在线检测、检测值不准确以及稳定控制难的问题，\n 首先，根据浸出过程pH测量的特点以及存在的问题，研制各个反应槽的pH值在线自动检测装置； 在此基础上，通过分析浸出过程的工艺机理及工业运行数据，分析浸出过程pH值、浸出率与焙砂添加量、废电解液通入量和氧气添加量等的关系，建立浸出过程机理模型，利用人工智能、机器学习等手段，实现浸出过程出口处pH值设定值的优化与智能控制，从而保证浸出过程效果最优。  为了实现浸出过程的智能优化控制，需实现浸出过程中pH值的自动检测。因此，研究浸出过程pH在线自动检测装置，对浸出过程的智能优化控制具有十分重要的意义。\n(2)稳定的反应条件是提高浸出率的必要条件，但浸出过程的长流程、多扰动的特点导致浸出过程建模和智能优化控制困难\n浸出率是衡量浸出效果的重要指标，一般通过稳定控制浸出过程的pH值来保证浸出率。正确地控制浸出终点的pH值，对提高锌浸出率，降低浸出渣中的含锌率，有效去除杂质，提高硫酸锌溶液的质量是非常重要的。\n中性浸出过程主要由5个反应槽串联和其他混合槽组成，因此，整个中性浸出过程浸出时间较长(2~3h)，工作流程长，系统惯性大；且在浸出过程中，pH值的测量是采用间断测量，不但造成了生产过程数据的延时性和不准确性，而且还不能实现实时在线控制；\n此外，在生产过程中，需要添加焙砂、废电解液和氧气(氧压浸出)等，加入浸出槽中的废电解液酸度、焙砂添加量和氧气添加量等存在一定的波动性，仅凭人工经验难以根据出口处浸出液的实际情况实时调节废电解液的流量、氧气添加量和焙砂添加量等。\n因此，研究浸出过程的反应机理模型、多工艺参数（废电解液流量、氧气添加量、焙砂添加量等）智能优化控制方法，为浸出过程的稳定运行提供了基础。\n优化需求 针对浸出槽中pH计易结垢及测量不准确的特点，利用自动清洗、自动校准等装置，研发pH值在线自动检测装置，实现浸出过程pH计的自动检测、自动校准及自动清洗功能，在保证pH计测量结果准确和稳定运行的基础上，达到减少工人的工作量以及设备的维护成本维修费用的目。\n此外，针对浸出时间长、人工经验难以确定的特点，在研究浸出过程机理模型的基础上，利用人工智能、机器学习等方法，实现废电解液的流量、氧化后液流量、焙砂添加量及氧气添加量及时准确的调整，保证浸出槽出口处溶液的pH值及浸出率符合指标。\n因此，主要包括如下关键问题：\n 1）pH值在线自动检测   浸出过程中，难溶的硫酸盐及其他沉淀会附着在pH计的表面时，会导致结垢及pH计钝化等情况，影响检测精度和效果。因此，分析浸出过程pH测量的特点，研制pH在线自动检测装置，实现pH计自动检测、自动校准及自动清洗的功能是本课题需要解决的关键问题。\n  2)浸出过程多反应动力学模型   在浸出过程中，废酸流量、氧化后液流量、焙砂添加量和氧气量等因素均会对浸出率产生影响。为此，建立浸出过程的机理模型，明确各控制量与浸出率之间的关系，是本项目需要解决的关键问题。\n  3)浸出过程智能优化控制策略   如何设定各槽出口处的pH值，并设计相应的优化控制策略，缩短调节时间，实现浸出过程各控制量（废酸流量、焙砂添加量、氧化后液流量和氧气添加量）的优化控制，使中性浸出过程出口处pH值和浸出率满足生产要求，是本项目需要解决的关键问题。\n 实现方法   1)pH在线自动检测装置\n在实际应用中，由于浸出是一个连续的过程，短时间内浸出液的pH值不会有很大的波动。\n因此，pH计探头不必长期置于待测溶液中，只要将其置于测量槽内，定期将待测污水抽至测量槽中，检测到pH值后，将pH计探头取出。由于pH值的检测时间较长，pH计探头仍将与溶液有较长时间的接触，从而吸附其他物质发生结垢或者腐蚀，影响pH值检测效果。\n因此，在每次pH值检测完成后，需要将pH计探头进行清洗，清洗完后置于缓冲液中，并定期将其置于标准溶液中进行标定。通过研制pH计在线自动检测装置，实现pH计自动检测、自动校准及自动清洗的功能，保证pH计能长期稳定的进行。\n  2)基于机理模型和大数据的浸出过程智能优化控制\n  首先，结合物料平衡和浸出反应机理，以来料组成、流量、废酸添加量、溶液pH值、氧气添加量、焙砂添加量为输入，建立浸出过程的机理模型，给出相关关键工艺参数的设定值；\n  其次，结合大量历史工况数据，利用大数据平台，基于人工智能技术、专家系统理论等，在已有工况数据的基础上，进行特征提取、模型训练和评估，形成能够进行有效计算的数据模型，能够根据当前来料成分对工艺参数进行预测；\n  最后，以在线的pH检测值序列为依据，对关键工艺参数（废酸添加量、氧气添加量、焙砂添加量等）进行校正，将pH值稳定在工艺设定区间内。\n    净化 目的及意义 湿法炼锌过程中，浸出后的硫酸锌溶液包含铜、钴、镉、镍等多种对电解极为有害的杂质离子。硫酸锌溶液中的钴、镍、铜和镉等杂质离子对电解效率影响很大。\n其中，铜是含量最高的杂质离子，钴是最难去除的杂质离子，它们不仅会降低电解效率、增加单位产品电耗，还会降低产品的产量和质量，严重时析出锌板会出现“穿孔”、“烧板”等现象，严重时会造成自动剥锌无法进行，导致长时间调整甚至停产，并显著降低产品的质量和生产效率。因此，需要通过净化工艺将这些杂质离子降低至生产指标范围内，为电解提供合格新液。\nZn2+的标准电极电位(-0.736V)较杂质离子Cu2+(+0.337V)、Cd2+(-0.403V)、Co2+(-0.277V)更负，因而可以用金属锌粉将杂质从净化液中置换出来。\n因此，净化除铜和除钴成为锌湿法冶炼净化过程中的关键环节。然而，由于净化过程在在线检测，入口溶液成分和流量的稳定性等方面存在的问题，给净化过程的优化控制带来了较大的困难。有鉴于此，本项目针对净化工序的除铜和除钴子过程设计了优化控制方案。\n因素分析 净化过程不仅要保证净化后溶液铜、钴、镍等离子浓度达标，而且需要降低过程的各种资源消耗，具体来说需满足下列指标要求。\n  (1)除铜工序出口铜离子浓度达标\n由于除铜工序出口铜离子是后续除钴工序除钴的活化剂，铜离子浓度浓度太低不利于钴的去除，浓度太高又会与钴发生竞争性还原，同样会导致除钴率下降。因此除铜工序必须根据入口条件、工况优化控制出口铜离子浓度。\n  (2)净化后溶液钴离子浓度达标\n净化除钴后溶液中钴离子浓度是关键工艺指标，实际生产过程中要求钴离子浓度不大于0.5mg/L(大于0.5mg/L为不合格)，但是并非浓度越低越好，因为钴离子浓度低至0.4mg/L以下时，对硫酸锌溶液电解的影响程度不再有明显差别，而净化后溶液的钴离子浓度越低，相同条件下消耗的锌粉越多，将造成不必要的锌粉浪费。\n  (3) 降低净化工序吨锌锌粉消耗\n锌粉是净化过程最主要的资源消耗，吨锌锌粉消耗(每生产一吨阴极锌消耗的锌粉重量)是衡量净化过程最重要的资源消耗指标，其值越低越好。净化过程的锌粉消耗包括了除铜过程和除钴过程的锌粉消耗。\n  (4)除钴工序BT值达标\nBT值达标有两方面的意义。首先是降低BT值可以降低钴渣中的锌元素含量。BT能反映溶液中碱式硫酸锌的含量。控制反应器中溶液的BT，可有效降低钴渣中锌元素的含量，提高锌元素回收率。\n其次BT值达标可以延长除钴压滤机清洗周期。当溶液中的碱式硫酸锌和硅胶过多时，除钴压滤机的压滤效果会显著降低。需要对压滤机进行清洗。通过控制BT值，可以延长压滤机清洗周期，减少生产成本。\n  为满足生产指标要求，需要对净化工序的锌粉、废酸、砷盐等操作参数进行优化控制。然而净化工序存在诸多不利于优化控制的问题，概括如下：\n  A. 关键工艺参数钴离子浓度检测存在大滞后\n净化过程中，流量、pH值、温度、含固量、氧化还原电位(ORP)等参数为实时监测量。由于浸出后液具有高温高腐蚀性等特性，在线金属分析仪难以应用在除铜过程浓度检测中。因此，除铜入口溶液、2#反应器出口溶液、除钴过程入口溶液、1~4#反应器出口溶液以及浓密机出口溶液中的铜离子、钴离子浓度，由人工采样在实验室化验获得，采样间隔时间以小时计。\n  B.入口条件参数经常频繁、大范围波动\n受国内锌精矿资源条件的制约，企业购买的锌精矿矿源复杂，经常出现溶液中钴、铜等杂质离子大幅度波动。同时企业会根据锌产品市场供求关系调整产量，也导致溶液流量发生较大的波动。\n  C.除钴过程时滞性大\n砷盐除钴过程在连续的四个反应器中进行，整个流程长达4~8小时，钴离子浓度变化为慢时变过程，操作参数的调整并不会对立即对出口钴离子浓度产生的影响，需要经过较长的时间才能体现出来，即过程具有大时滞性。\n  D.操作参数之间存在强耦合性\n砷盐除钴过程需要设定操作参数多，操作参数与净化后液的钴离子浓度之间关系复杂，呈强非线性特点，而且操作参数ORP与砷盐间有强耦合关系，ORP和砷盐、底流的调整会影响废酸的最优添加量，并且前一个反应器的操作条件的变化会显著影响后一个反应器的除钴效果，即前、后反应器之间具有强关联性；即使在锌粉总添加量相同的情况下，各反应器ORP设定值不同(即每个反应器锌粉分配不同)，除钴的效果也有明显的差别。\n  综上所述，在线检测上存在的难点，以及入口溶液成分和流量的大幅波动给净化过程的优化控制带来了较大的困难。净化过程优化控制系统需要针对这些需求和难点，设计有针对性的优化控制方案。\n优化需求   (1)除铜过程优化控制需求\n除铜过程优化控制的目的是通过合理设定操作参数，在保证净化后溶液出口铜离子浓度达标的前提下，同时保留适量铜离子作为后续除钴过程的活化剂，并尽可能降低锌粉的消耗量。该除铜过程优化控制框架可划分为四个部分：生产目标优化、锌粉优化设定、锌粉实时校正以及其他辅助协调部分。\n  A. 除铜过程生产目标优化\n针对除铜过程出口铜离子浓度影响除钴过程除钴效率的特点，生产目标优化主要优化设定出口铜离子浓度控制目标，在满足湿法炼锌除钴过程对铜离子浓度的需求的同时提高出口铜离子浓度稳定性。\n  B. 除铜过程锌粉添加量优化设定\n为减少除铜过程锌粉消耗，锌粉添加量优化设定单元根据生产目标优化部分给定的控制目标，在锌粉有效性预测值的调节下，优化设定锌粉添加量。\n  C. 除铜过程锌粉实时校正\n由于净化过程溶液成分和流量波动大，锌粉优化设定单元在铜离子浓度平稳状态下能提供合格锌粉添加量，但在铜离子浓度波动较大时，难以保证出口铜离子子的稳定性与合格率。因此，需要锌粉实时校正方法对其设定的锌粉进行调节。\n  D. 其他辅助部分\n除铜过程优化控制涉及的模型在长期运行时往往需要更具工况变更进行校正。辅助单元根据过程数据，判别各模型是否需要进行校正或者重训练。\n    (2)除钴过程优化控制需求\n砷盐除钴过程优化控制的目的是通过合理设定操作参数，在保证净化后溶液出口钴离子浓度达标的前提下，尽可能降低锌粉的消耗量，以及降低钴渣中锌元素的含量和延长除钴压滤机清洗时间的间隔。针对这些目标，提出了如图8-30所示的操作参数优化控制框架。该优化控制框架主要包括砷盐除钴过程钴离子浓度预测模型、废酸添加量和底流返回流量优化、ORP设定值与砷盐添加量优化\n A. 砷盐除钴过程钴离子浓度预测模型  由于砷盐除钴过程流程长，过程惯性大，钴离子浓度的人工检测存在大滞后，影响了过程的优化运行，因此，建立基于除钴反应机理模型与数据残差补偿模型的钴离子浓度预测模型\n B. 废酸添加量与底流返回流量优化  废酸添加量主要影响反应器中溶液的BT值，BT太高或太低都将降低置换除钴的效率。BT太低会导致锌粉消耗过高，BT太高会造成钴渣中锌元素的含量过高，并导致除钴压滤机的压滤状况不理想。而底流返回量会影响除钴反应器中的反应催化面积大小，进而影响除钴效率。因此，需通过废酸添加量和底流返回量合理的优化设定，为添加锌粉和砷盐置换除钴创造良好的反应条件。\n C. 除钴过程砷盐添加量和ORP设定值优化  降低锌粉的单耗(即吨锌锌粉消耗)是净化除钴过程的重要目标。由于砷盐添加量、锌粉存在强耦合关系，单独优化砷盐添加量或锌粉添加量都难以达到锌粉的添加量最少，更无法保证钴离子浓度达标，所以必须将砷盐与锌粉一起进行优化。由于株冶锌粉通过ORP控制器添加，因此ORP的优化等价于锌粉添加量的优化，因此，需对砷盐添加量与ORP设定值进行优化，以降低砷盐除钴过程的锌粉消耗。\n  实现方案   (1)除铜子工序\n  A. 除铜过程生产目标优化\n生产目标优化主要为了满足湿法炼锌除钴过程对铜离子浓度的不确定性需求、提高出口铜离子浓度稳定性，调节出口铜离子浓度控制目标。其主要由两个单元构成:除铜过程生产指标范围调整和除铜生产目标全局优化。\n其中，在除铜过程生产指标规划调整部分，分析铜离子作为活化剂时与钴离子浓度之间的关系，根据除铜过程实时变量(流量、底流含固量、温度、PH值等)和铜离子浓度化验值，对原有的除铜过程生产指标范围进行调节，使出口铜离子浓度在满足本工段生产要求的前提下，满足除钴反应的生产需求。以调解后的生产指标作为软性约束条件，分析不同下降速率条件下，各反应器中铜离子浓度调节速率对除铜过程生产稳定性的影响，设定各反应器的出口铜离子浓度满意值，为除铜过程生产控制提供合理的控制目标。\n  B. 除铜过程锌粉添加量优化设定\n基于锌粉有效性预测的锌粉优化设定方法，根据生产目标优化部分给定的控制目标，基于除铜竞争-连续反应体系机理模型，在锌粉有效性预测值的调节下，优化设定锌粉添加量。基于锌粉有效性预测的除铜过程锌粉优化设定主要由两部分构成：一部分为锌粉有效性计算与预测；另一部分为除铜过程竞争-连续反应体系机理模型确定与锌粉优化计算。\n锌粉有效性计算与预测为锌粉优化设定提供校正依据。由于锌粉有效性不是从除铜过程直接采集的过程参数，需要根据铜离子浓度化验值和各过程参数进行计算。锌粉有效性具有较大的时滞性，无法直接用于锌粉优化设定值的在线校正，因此，需要通过基于趋势分布特征的除铜锌粉有效性预测算法实时预测锌粉有效性。除铜锌粉有效性计算单元输出的锌粉有效性实际值，不仅作为案例存储于数据库中以供预测算法使用，同时将用于预测值残差计算以在线校正预测算法。\n除铜过程基础锌粉设定量需要建立除铜过程竞争-连续反应体系机理模型。首先根据过程机理建立模型框架，然后根据采集的历史数据，辨识模型参数，建立机理模型。机理模型在线使用时，在线样本进行辨识，获得样本所属工况，并选择对应的工况机理参数输入至机理模型中，根据确定的机理模型以及锌粉有效性预测值，以最小化锌粉消耗量、满足除钴工序对铜离子浓度要求为目标，对除铜过程进行优化，实时计算锌粉添加量。\n  C. 除铜过程锌粉实时校正\n受到铜离子浓度化验频率的限制，锌粉优化设定单元在铜离子浓度平稳状态下能提供合格锌粉添加量，但在铜离子浓度波动较大时，难以保证出口铜离子子的稳定性与合格率。因此，需要采用基于ORP的锌粉校正方法对其设定的锌粉进行调节。该部分主要由基于ORP的除铜过程模糊评估与锌粉校正规则提取两部分构成。\n首先，对ORP时间序列进行趋势提取，并分别对ORP值及其趋势进行模糊化，经过模糊规则评估单元与评估值反模糊化单元，获得除铜过程工况评估值。在评估过程中，模糊化所需的隶属度函数和模糊规则已经离线训练完毕。为保证在矿源更改的情况下，过程评估值的合理性，隶属度函数确定部分保持半离线状态。当接受到模型重训信号时，除铜电化学模型根据新的除铜过程样本重训练除铜电化学模型，获得最新的隶属度函数参数。同时，如果出口铜离子浓度目标优化值与原有的目标值差距较大时，需根据新的出口目标浓度值对隶属度函数进行相应参数计算。\n其次，根据评估值和其他过程参数，基于SVM分类器当前除铜过程所处的可控域；在该可控域内选择输入变量对应的锌粉校正规则，提供除铜过程锌粉校正量。其中，锌粉校正规则已根据历史数据离线提取。同时，为了保证长期运行条件下规则的有效性，需要根据模型校正信号，采用最新的工况数据，更新规则库，并在规则提取过程中，为可控域在线辨识提供新的可控域分类器。\n  D. 其他辅助部分\n除铜过程控制各部分含有相应的机理模型与数据模型(可控域分类器、可控域规则提取模型等)，这些模型在长期运行时需要更具工况变更进行校正或者重训练。\n除铜过程模型校正判别单元，在分析过程评估值、ORP值以及锌粉有效性长时间的变化状况，判别各模型是否需要进行校正或者重训练。\n除铜过程锌粉整合单元，根据除铜过程控制的当前状况(控制系统正常运行状态、模型重训状态等)，整合基础锌粉设定量与锌粉调节量，为除铜过程控制提供最终锌粉添加量。\n    (2) 除钴子工序\n  A. 砷盐除钴过程钴离子浓度预测模型\n由于砷盐除钴过程流程长，过程惯性大，钴离子浓度的人工检测存在大滞后，影响了过程的优化运行，因此，建立基于除钴反应机理模型与数据残差补偿模型的钴离子浓度预测模型，为砷盐除钴过程的废酸、底流、ORP(锌粉)和砷盐等操作参数的优化提供指导作用。拟建立基于砷盐除钴化学反应机理的钴离子浓度预测主模型和基于模糊特征LSSVM的残差补偿模型组成的钴离子浓度混合预测模型。\n  B. 废酸添加量与底流返回流量优化\n废酸添加量主要影响反应器中溶液的BT值，BT太高或太低都将降低置换除钴的效率。BT太低会导致锌粉消耗过高，BT太高会造成钴渣中锌元素的含量过高，并导致除钴压滤机的压滤状况不理想。而底流返回量会影响除钴反应器中的反应催化面积大小，进而影响除钴效率。\n因此，需通过废酸添加量和底流返回量合理的优化设定，为添加锌粉和砷盐置换除钴创造良好的反应条件。实际生产中浓度机底流可通过反应器中含固量的分析进行反馈调节，其优化较为简单，很容易计算得到满意的底流返回流量，因此下文只讨论废酸添加量的优化。\n研究得出影响1号反应器溶液评价指标BT的主要因素有：\n 1）添加的砷盐溶液：砷盐溶液为强碱性溶液，且砷盐参与的反应消耗氢离子，都会引起溶液BT上升； 2）返回的浓密机底流：浓密机底流中含有大量碱式硫酸锌(即BT很高)，需要添加废酸降低其BT； 3）添加的锌粉：添加锌粉置换除钴不可避免的出现锌粉和溶液中H+反应，造成反应器中局部溶液BT迅速上升。通过综合这三个方面需求的废酸添加量，基于物料衡算，对废酸添加量进行优化设定。    C. 除钴过程砷盐添加量和ORP设定值优化\n降低锌粉的单耗(即吨锌锌粉消耗)是净化除钴过程的重要目标。由于砷盐添加量、锌粉存在强耦合关系，单独优化砷盐添加量或锌粉添加量都难以达到锌粉的添加量最少，更无法保证钴离子浓度达标，所以必须将砷盐与锌粉一起进行优化。由于株冶锌粉通过ORP控制器添加，因此ORP的优化等价于锌粉添加量的优化，故对砷盐添加量与ORP设定值进行优化，以降低砷盐除钴过程的锌粉消耗。\n砷盐添加量优化主要是对工艺物料平衡模型中的砷盐调整系数a进行优化。本方案拟基于海量的历史数据，基于操作模式优化方法，从数据中挖掘较优的操作模式，实现过程ORP和砷盐添加量的优化。\n操作模式优化主要分为操作模式库构建、操作模式匹配、操作模式等级综合评估、操作模式重用、操作模式库的在线更新和维护五部分。\n  a.构建操作模式库：\n净化过程的操作模式以数据库的形式存储在计算机中，每一个操作模式由条件参数、资源消耗参数、操作参数、操作模式产生的时间组成。根据砷盐除钴机理、实际生产数据分析得到影响最显著的条件参数为除铜后液流量、溶液中的铜、钴和镍离子浓度、溶液的温度；资源消耗为添加的砷盐与锌粉添加量之和，但是由于单位时间内砷盐的成本不足锌粉的五十分之一，因此资源消耗仅考虑(四个反应器的)锌粉的总消耗；操作模式产生的时间为生产过程中第一次使用该操作方法时的时间，如果在生产过程中产生了几乎完全相同的操作模式，则将操作模式的时间更新为最新的时间；操作参数为砷盐调整系数、四个反应器的ORP设定值。根据实际生产中积累的大量工业运行数据，经过数据时序关系对应后将工况总结成操作模式的形式，提炼出初始操作模式，完成初始操作模式库的构造。\n  b.操作模式匹配：\n对入口条件参数进行模糊等级划分，进而获取各个工况条件的模糊描述，然后根据相似度来衡量当前工况条件参数模糊向量与已有操作模式工况条件模糊向量的相似程度，匹配出符合要求的操作模式。在计算相似度时，基于专家经验权重计算待求的操作模式的工况向量以及已有操作模式的工况向量之间的相似度。为提高匹配的效率，先采用模糊C-均值聚类方法将操作模式分成若干类，然后寻找到最相似的类中心，再将该类中相似度大于某一个阈值的操作模式全部匹配出来，如果检索出的操作模式个数小于预设定值，则将阈值减小，直到搜索出足够多的匹配操作模式。\n  c.操作模式重用：\n一般情况下，操作模式库中不存在与待求操作模式工况条件完全匹配的操作模式，因此，匹配出的操作模式的解不能直接作为待求操作模式的解，必须对相似操作模式的解(操作参数)进行重用。砷盐除钴过程强噪音、强酸性和高腐蚀性的恶劣环境，造成系统参数发生缓慢变化，导致相同入口条件参数下的最优操作参数发生了漂移，时间越久远的操作模式借鉴意义越小，故应该赋予越小的权重；此外，越优的操作模式应该赋予越大的权重，以节约更多的资源或成本。\n  d.操作模式等级评估：\n在砷盐除钴过程中，难以准确的定量描述操作模式的等级－优、良、中和差，例如某操作模式属于优秀等级操作模式，但是又接近于良好操作模式，具有较大的模糊性；而且在一段时间内，某操作模式为良好操作模式，但是经过一段时间后，可能出现一个或多个比该操作模式更好的操作模式，则该操作模式隶属于中等操作模式的隶属度可能会更大，即具有不确定性。因此，操作模式的等级不能简单的划分为优秀、良好、中等或差几种等级，而是要用某一操作模式隶属于某一等级的支持和反对的程度来客观描述；而且对某一操作模式的等级评价不能固定不变，应该根据最新操作模式库的情况更新。操作模式评估具有模糊性和不确定性，因此引入觉模糊数的思想对操作模式进行评价。将操作模式评定为优秀、良好、中等、差四个等级。当有多个工艺指标和资源消耗指标时，先需要分别计算工艺指标的综合评价函数和资源消耗指标的综合评价函数。然后再计算操作模式隶属于优、良和中三个等级的直觉模糊数\n  e.操作模式库的在线更新和维护：\n操作模式库中的优、良操作模式越多，则基于操作模式的操作参数优化方法求解得到的操作参数更优，因此，必须保存优、良的操作模式。对于新的操作模式，首先评估新操作模式的等级，当新操作模式为优、良等级时，则存入操作模式库。为控制操作模式库的规模，当存入新操作模式的同时，删除与该操作模式入口条件参数相似度大于设定阈值的非优良操作模式或距离当前时间大于一年的非优秀操作模式或时间超过2年的操作模式。通过对新操作模式的选择性存储和对操作模式库的选择性精简，在控制操作模式库规模的同时，也保证了操作模式库的典型性和实用性。\n      电解 目的及意义 电解作为锌湿法冶炼中最重要的工序之一，它是指硫酸锌溶液中的锌离子在直流电作用下放电析出的电化学过程，是湿法炼锌中最主要的耗能过程，其电耗占整个冶炼过程能耗的75-80%左右。我国作为世界锌冶炼生产的第一大国，如何减少锌电解生产中电能消耗、降低用电费用是一个值得深入研究和探讨的问题。\n针对锌电解过程的高能耗问题，首先基于锌电解过程的反应机理，分析电流密度、电解液温度、硫酸浓度以及锌离子浓度等工艺参数对电流效率及电解能耗的影响，建立锌电解过程反应动力学模型，并利用历史工况数据对模型中的参数进行修正；\n在此基础上，针对分时电价的特点，研究面向能耗和电费最优的锌电解过程工艺参数优化方法，确定最优硫酸浓度、锌离子浓度、电流密度以及电解液温度等参数；\n然后，针对锌电解过程长流程、大时滞等特点造成控制难的问题，根据工艺参数的优化结果，确定不同时段的最优电流密度、电解液酸锌离子浓度与温度，研究锌电解过程新液流量、冷却风机智能控制技术，以保障电解液酸锌离子浓度和温度跟踪最优设定值。最后，通过现场数据分析和实际工程应用研究，验证所提方法的准确性和有效性。\n因素分析   (1) 电解是湿法炼锌中最大的耗能工序，优化控制是实现湿法炼锌过程节能降耗的重要手段\n有色金属工业是我国的高能耗行业，其能源消耗占全国的5%以上，锌是四种主要有色金属产品之一，我国锌产量约占世界总产量的26.13%，其中80%以上是通过湿法工艺生产。我国湿法炼锌工艺平均能耗高于工业发达国家，能源费用占到了生产成本的20~30%，特别是电力成本占生产成本的比重比远高于世界平均水平，严重影响了我国锌冶炼企业的国际竞争力，加剧了我国能源紧张的局面。\n但是要降低锌电解过程的能耗，仅凭生产经验，难以准确反应各工艺参数对能耗的综合影响，使生产过程控制处于一种相对盲目的状况，造成锌电解的能耗偏高。虽然通过不断的技术革新和改造，电解锌的单位直流电耗有所下降，\n但是由于矿源多、反应复杂、影响能耗的工艺参数多，各参数之间耦合严重、非线性强，能耗模型建立困难，而且由于强酸强电流的恶劣生产环境，影响能耗的关键工艺参数难以在线检测，难以实现优化控制，导致电解过程能耗总体偏高；\n同时，自动化装备水平和过程控制技术相对落后，缺乏先进控制和优化技术的支持，仅凭经验进行操作，很难考虑能耗指标以及各工艺参数之间的影响，使得能源消耗的控制处于一种“盲目”的状态，远远没有发挥节能降耗的潜力。\n锌电解过程中，电解液的酸/锌离子浓度(酸锌比)以及电流密度(单位面积阴极板通过的电流)等工艺参数是影响电流效率及能耗的主要因素。为了降低能耗，需实现对这些工艺参数的优化控制。因此，研究锌电解过程的工艺机理，建立生产过程模型并实现其优化控制，对锌电解乃至整个湿法炼锌生产的节能降耗具有十分重要的意义。\n  (2) 在电费分时计价政策下，为降低电费需在不同峰谷用电时段大幅调整电解负荷；但锌电解反应机理复杂、长流程、滞后大等特点给电解过程的控制带来了极大挑战。\n为了平衡电网、缓解用电高峰时段电力紧张的矛盾，我国电力部门采用了电费分时计价政策。即将一天24小时分成多个时段，各时段电价差异很大，高峰时段电价通常可以达到低谷时段的4-5倍。为了降低用电费用，锌电解过程在不同时段采用不同的电流密度生产，实现高峰用电时段低电力负荷生产、低谷用电时段高电力负荷生产。实际生产中，调整幅度达到200%以上。当调整电力负荷时，为避免因“反溶”或槽电压上升引起能耗增大，需及时调整电解液酸/锌离子浓度和入口流量，以保证在新的电流密度下，电解过程的能耗最低。\n  (3) 锌电解特点\n锌电解是一个气-液-固三相反应的过程，在电解过程中，锌离子在阴极板上得到电子会发生析出反应生成单质锌，氢离子在阴极板上也会得到电子生成氢气；同时，由于电解液的强酸性，阴极板上析出的锌单质会与溶液中的硫酸发生反应，且电解过程中存在着杂质离子的析出等反应。随着反应的进行，电解槽中的酸离子浓度会逐渐增大，锌离子浓度逐渐增大，另一方面，电解槽中不断有新液的流入和废液的流出，导致酸锌离子浓度在电解槽中不同位置处的分布不一样，因此，锌电解过程中是一个反应机理复杂、多场多反应并存的过程。\n除了反应机理复杂、多场畸变的问题，锌电解过程还具有两个重要的特点：\n  a.流程长、滞后大\n锌电解过程由一个混合液槽、一个废液槽和近200个电解槽组成，工作流程长；电解液由新液(主要成份是硫酸锌)和电解废液(主要成份是硫酸锌和硫酸)制备而成，上一道工序送来的新液与废液槽中的废液按一定比例，在混合液槽中经过30-40分钟充分混合后，再送入电解槽，滞后时间大。\n  b.关键参数无法在线检测\n电解槽中溶液的酸/锌离子浓度是影响电解的主要参数，但只能每隔一小时通过人工取样化验获得，检测滞后严重。这些问题给锌电解过程的控制带来了极大的挑战，不仅会引起工艺参数波动、能耗增加，甚至可能导致工况大幅震荡，造成生产不稳定。\n    正是由于上述原因，使得锌电解过程建模与优化控制困难，造成锌电解过程能耗增大，并加剧了产量、质量的波动，影响生产的正常运行。因此，亟需研究锌电解过程的工艺机理及动力学模型、锌电解过程工艺参数优化以及锌电解过程智能优化控制等理论与方法，为实现大极板长周期锌电解过程节能降耗、稳定生产提供保障。\n优化需求 针对锌电解过程电解能耗高问题，本项目在分析锌电解过程工艺机理的基础上，通过收集大量的现场生产数据，建立锌电解过程的数学模型。优化设定各时段的电流密度，以实现分时效益的最大化。在此前提下，优化设定各时段电解液的酸锌含量，并对温度进行适当调节，以使锌电解过程能耗最小。通过控制新液与废液的配比以及冷却塔风机的运行情况，使集液槽中的电解液满足优化设定的条件。因此，主要解决如下关键问题：\n  多场多反应条件下，工艺条件对电效及能耗的影响机理\n在锌电解过程中，存在着锌析出、氢气析出、析出锌溶解以及杂质离子析出等多个氧化还原反应；且随着反应的进行和溶液的流动，锌离子和氢离子等在电解槽中不断流动，在气、液、固三态之间相互转换，造成电解槽中酸/锌离子浓度的变化，其反应机理复杂，影响电流效率和能耗的工艺参数多，且参数之间关系不明确，使得锌电解过程能耗模型建立困难。为此，明确锌电解过程中各工艺参数对不同反应的影响，确定工艺条件对电流效率及电解能耗的影响机理是需要解决的关键问题。\n  分时电价下，锌电解过程工艺参数的优化\n在我国电力部门采用了电费分时计价政策的背景下，即将一天24小时分成多个时段，各时段电价差异很大。为了降低用电费用，锌电解过程在不同时段采用不同的电流密度生产，实现高峰用电时段低电力负荷生产、低谷用电时段高电力负荷生产，导致实际生产过程中，电力负荷的调整幅度大。当电力负荷调整时，为避免因“反溶”或槽电压上升引起能耗增大，需及时调整电解液酸/锌离子浓度和入口流量，以保证在调整后的电流密度下，电解过程的能耗最低。因此，在分时电价的政策下，在保证能耗最小、效益最大的前提下，如何确定各生产时段内的最优电流密度、酸锌离子浓度以及电解液温度等工艺参数是需要解决的一个关键问题。\n  锌电解过程关键参数和设备的优化控制策略\n锌电解过程是由多个电解槽组成，工作流程长，每个工序处理期间都需较长时间，滞后时间大；且酸/锌离子浓度等影响电解的主要参数只能每隔一小时通过人工取样化验获得，检测滞后严重。因此，研究锌电解过程中，如何设计锌电解过程的优化控制策略，实现关键工艺参数的优化控制，避免引起工艺参数的波动和能耗的增加，或者工况的大幅波动所造成的生产不稳定，是需要解决的一个关键问题。\n  实现方式   (1) 建立锌电解过程电效及电耗的数学模型\n湿法炼锌电解过程由于矿源多、工艺复杂，影响其能耗的工艺参数多，各参数之间耦合严重、非线性强，能耗模型建立困难。影响其能耗的因素主要包括电解液中的硫酸含量、电解液中的锌离子浓度和锌电解时的电流密度三类，同时还包括其它次要因素和工况的影响。\n为此，在机理分析的基础上，依据电化学原理和电子转移守恒定理，建立锌电解槽电压和电流效率的机理模型。由于机理建模时的假设和简化，机理模型必须经过修正后才能在应用，因此，利用在现场获得的实际数据间接的对槽电压和电流效率的机理模型进行修正，模型修正思想主要是利用在现场获得的数据和实验模型获得的数据的差，并利用参数修正算法对模型的系数进行修正，最终得到满足现场的电流效率模型和槽电压模型。\n机理模型是根据电子转移守恒建立的，能反映对象的本质特征，基于电化学机理建立的数学模型尽管可实现整个区域内的能耗预测，在工况发生波动时具有一定的灵敏度和鲁棒性，但是由于过程异常复杂，没有考虑到生产过程的特性，实际应用中往往显得精度不高。\n基于机器学习的预测方法只依据输入输出数据就能建立黑箱模型，在基于小样本的复杂生产过程建模方面具有较大优势。\n通过对以上模型的优缺点进行分析，可以通过将基于机器学习的电效、槽电压预测模型和机理模型相结合的方法建立锌电解能耗关于其影响因素的预测模型，达到充分利用各种建模方法的优点的目的，由于机理预测模型的存在，可以确保模型对复杂过程的全局拟合能力，同时可有效避免基于机器学习预测模型的过拟合与泛化能力不够的问题;而基于机器学习预测模型可提高预测能力和计算精度；引入协调器，将机理预测模型和基于机器学习预测模型结合起来。因此，具有良好的模拟锌电解过程的能力，可以在大范围内较准确地预测湿法炼锌电解过程的锌电解能耗。\n  (2) 锌电解过程关键参数与设备状况的在线监视\n包括数据的实时数值和曲线显示，故障诊断和报警显示。实时数据经过采集处理后，以天为单位，形成数据文件，以供查询和显示参数曲线调用。在电解过程运行监视中，除了能实时显示了整个工艺流程的大部分关键参数，还能按照温度、流量、液位、电流的类别实时显示。此外，还能以天或周为单位，对数据库中的历史数据和实时数据以曲线形式进行查询，通过曲线查询，可以非常清楚的掌握各个参数的变化趋势和变化情况。故障诊断能够对各参数的高低限越界情况，电解过程新液和集液流量的中断或者溢出情况，电解电流和各种电机的短路或者开路情况，以及各个系统的串液情况进行智能判断，并且能及时以方便醒目的方式给出报警操作提示。\n  (3) 锌电解过程工艺参数的优化指导\n锌电解过程生产过程中，在保证全天锌产量的前提下，希望每天的电能消耗和用电费用最低。因此，选取每日锌电解过程所消耗电能和用电总费用作为优化的目标。\n此外，株洲冶炼集团按计划进行生产，考虑生产能力和为保证锌产品质量，制定了每日产量计划，因此生产过程中包含了产量约束。在生产过程中，提高电解液含锌量及面积电流、降低电解液酸度及温度，有利于降低析出锌含铅量，提高锌产品质量，但这些条件受到电流效率及电能消耗的限制。\n电流密度较低会造成电流效率急剧下降，电流密度较高对电流效率的提高没有明显作用，同时电流密度还受极板所能承受的最大电流强度的限制；\n电解液锌浓度较低会引起析出锌的反溶，较高对电流效率的增加没有明显效果，相反还会引起槽电压的增大和杂质活动的加剧；\n电解液中酸浓度较低会引起槽电压明显升高，较高会引起氢的超电压下降，造成氢离子的析出成为氢气。因此生产过程中还包含电流密度、锌浓度、酸浓度边界范围约束。\n综上所述，在电费分时计价的政策下，在能耗机理分析的基础上，构造了含有某些未知参数的槽电压、电流效率与电流密度、温度与酸锌浓度的机理模型，通过参数辨识，以单位电单耗为目标，综合考虑产量、质量和相关工艺参数的约束，建立能耗优化模型，通过优化算法求解，得出不同时段下的电流密度、优化的温度和酸锌浓度等工艺参数。\n  （4）锌电解过程工艺参数及设备的控制\n锌电解流量的控制就是根据工艺指定的目标要求，确定新液流量,使电解槽的酸锌比稳定在工艺指定的目标范围内。影响新液流量给定因素主要有：废液实际酸锌比、酸锌比控制目标、新液浓度、废液酸锌浓度、电流密度、电流效率等，这些因素错综复杂，难以用模型直接描述。此外这些因素中电解液酸锌比等重要参数不能在线检测，只能每小时离线检测一次，增加了新液流量的给定难度。\n主要利用锌电解过程工艺参数优化的结果，针对不同的生产时段，根据电流强度，给出电解液酸锌浓度的最优值和电解温度经验设定值，来实现锌电解过程能耗的优化控制。\n在流量调节过程中，新液流量是通过调节新液变频器来调节新液泵的转速来实现，废液流量则先要人工调节废液泵的开启台数和阀门开度来予以粗调，待流量稳定接近目标废液流量时，改用控制集液变频器来调节集液泵的转速来予以精调，从而稳定在目标流量。电解过程中，由于混合液酸锌浓度的调节有一定滞后，因此结合电解生产专家经验，使用电解过程中电解液的酸锌浓度的化验值反馈修正电解液酸锌浓度配液模型，基本原则是，若电解过程的化验废液酸浓比低于设定值，则适当降低新液流量；若电解过程的化验废液酸锌比高于设定值，则适当增大新液流量。电解温度的控制是通过控制废液流经冷却塔的台数和流量来实现的，每个冷却塔带有冷却风机。\n  ","description":"","id":46,"section":"metal","tags":["Metal"],"title":"Zn","uri":"http://austinzgx.github.io/metal/zn/"},{"content":"读书摘抄  当T恤有了一个得瑟的灵魂……就成为传说中的文化衫…… 邓丽君奶奶和孟庭苇阿姨跟王菲姐姐的风格是不一样滴   在一口气看完韩老大的最近博文之后，有点小感：借小沈阳的台词“作家不白养呀！”（BTV春晚“保票不白雇呀，有事他真上呀！”）Mr Han也是真有话就敢说，极尽其讽刺挖苦之能揭露时事之弊。评价再借毕老师经典台词用一下：“小伙子，精辟！！！”最后改一下李清照的词用用“怎一个\u0026quot;服\u0026quot;字了得！”呵呵呵\u0026hellip;\u0026hellip;不过真的要是我们都能都像韩寒这样洞察一切，勇敢的说去一切真实而又非常不合理的事情！相信那将必会是另一番景致\u0026hellip;\u0026hellip;..\n  这一定是谣言，幻觉，这一定是幻觉，别有用心，这一定是别有用心。\n  那些令人刺耳的声音，我不听，我不听，偏偏我又容易受影响容易伤心，没有用，微笑的表面不停骗自己，他们的语气，好笑的攻击，自卑的心理，四年来，带着各种面具想让你我孤立，莫名其妙那些话语，莫名其妙那些话语（韩寒借蔡依林《骑士精神》中的部分歌词，实话恰如其分\u0026hellip;\u0026hellip;)\n  我国的国情中，代表是不需要被代表者同意的，所以这次我也代表政府，决定含泪劝劝大家。\n  好比嫖娼只收你小姐的钱，不会再收你床位费，这是合理的。但问题是人家把床承包出去了。\n  车主应该想明白一点，此桥是你修，此路是你造，要想从此过，还得留下买路钱，这是社会主义初期阶段发展中必须的。社会需要和谐，财政需要收入，你就乖乖交钱，否则你小心政府在农民工群体里搞一个投票，说你的小汽车该不该没收充公，之后全票通过，然后说你的车被民意没收了。汽车虽然贵，但好歹你拥有产权，汽油虽然差，但好歹的确是汽油，能让你发动，路虽然破，但好歹落差都在一米以内，收费站虽然多，但好歹两个收费站之间的距离比你的车要长点，通行费虽然高，但好歹交了钱还真的能通行了，所以，车主们就知足吧，别闹了，你弄掉一个费，多出一个税，多累。\n  钱钟书《写在人生边上》\n   猪是否能快乐得像人，我们不知道；但是人会容易满足得像猪，我们是常看见的。 这种快乐把忍受变为享受，是精神对于物质的大胜利。灵魂可以自主——同时也许是自欺。能一贯抱这种态度的人，当然是大哲学家，但是谁知道他不也是个大傻子？   是的，这有点矛盾，矛盾是智慧的代价，这是人生对人生观开的玩笑。\n 趣事一件 2009-03-16 前日我做2路公交，经历了一件趣事，特与大家分享。\n公交之拥挤自然不言而喻，人一挤，当然乘客们就没有办法移动到后车门去下车。当时车上有一个抱着小孩的少妇。要求司机让她从前门下车，这当然合情合理。那位夫人带上小孩就顺利的下了公交。这就为后来的事埋下了戏剧性的伏笔\u0026hellip;\u0026hellip;.\n公交一路颠簸，终于到了下一站，这时，司机打开前门让乘客上车之时，一个小伙子就借势从前门冲了下去，司机却说道：。。。等等，忘了介绍一下我们的主人翁司机师傅，不，应该是司机大姐，当地包头人，操着一口原版包头方言说道，不，骂道：“讨厌，让你从后门下，你也怀孕了~~！”（了解包头的方言的，你可以想象到那个特有的后升调~~）。\n当时，车内一阵哄笑\u0026hellip;\u0026hellip;.\n请大家说说，司机大姐要求乘客遵守秩序，是保护乘客的生命安全。但为什么她不会变通一下，难道只有看到孕妇才会变通\u0026hellip;..？？？难道是那个小伙没有像孕妇那样向她请示，她才破口骂之？\n我的戒烟观 2009-03-24 本人自持烟龄已达三年，特此在这放肆一把！哈哈 我的戒烟观\n林语堂先生曾在一篇名为《我的戒烟》的散文中写道“无端的戒烟断绝我们的灵魂的清福，这是一件负自己而无益于人的不道德行为。”思其言真乃我们烟民的精神支柱，我们的周围始终是吸烟有害健康之类的劝告。有了林大师的这句，再有人要劝你戒烟的话，你可以有靠山的告诉他（多数应该是她）：“我要是戒烟了，那我就不够道德了！！”。（林老先生当然不是这个意思，不要晚上上来找我呀！）\n我想大部分人当初抽烟的目的是很单纯的，只为炫耀只为突出自己，当然抽烟的不会觉得有什么了不起，但不会抽烟的人是被那个圈子的人不屑的.所以慢慢的吸上瘾了\u0026hellip;..\n再说那些戒烟的人，戒烟可以分为真戒和假戒，假戒的人大多是因为证明自己多么的有“坚强的志愿”和“顽强的毅力”。丛然会使他们忍受身体上的痛苦，他们也要违心地去戒烟，不过他们也只能受到身体上的折磨。而另一种真戒烟的人却还要忍受精神上的煎熬，因为他们抽烟不再只是为了得到身体上的舒适，他们要精神上也要得到享受，只不过这种人大多使不会戒烟的，即使他们戒烟也是不会成功的。林语堂的戒烟的失败就是一个最好的例子。\n所以呢，那些只是为了图生理上享受的烟民劝你们早点的戒烟，因为那样只会伤害你的身体。而那些已经到了精神境界的烟民，不要受人耸动，悻然去戒烟，到最后只会是徒劳！就算你戒烟成功，你的灵魂和精神会放过你吗？身体的伤害远没有精神上的伤害严重！是吧！所以不要为了向朋友、家人等证明什么而糊涂地戒烟！\n《长恨歌》小感 王安忆《长恨歌》\n人物\n主人翁：王琦瑶\n其他：吴佩珍、程先生、蒋丽莉、严家师母、瑶瑶（不知道姓什么）、张永红、小林、\n讲述了上海女人王绮瑶从少女到老妪的几十年人生，从风光无限的上海三小姐到晚景凄凉的寡老太太，一切缘于那场选美。从古至今，女人对于自己的美貌都是“难自弃”，然而命运给她们的注脚是“多薄命”。\n都说性格决定命运，一个人看待事物的方式决定了她生活的内容与质地。长恨歌中除了王绮瑶，还有和她一起生活的女孩或者女人，她们或许单纯，或许愚钝，但她们过得实在。她们命运的不同，似乎可以从性格中看出一些端倪。\n一、同学兼好友吴佩珍。吴是那类粗心的女孩子。她本应当为自己的丑自卑的，但因为家境不错，有人疼爱，养成了豁朗单纯的性格，使这自卑变成了谦虚，这谦虚里是很有些实事求是的精神的。由这谦虚出发，她就总无意地放大别人的优点，很忠实地崇拜，随时准备奉献她的热忱。王琦瑶无须提防她有妒忌之心，也无须对她有妒忌之心，相反，她对她怀有一些同情，因为她的丑。这同情使王琦瑶变得慷慨了，自然这慷慨是只对吴佩珍一个人的。吴佩珍的粗心其实只是不在乎，王琦瑶的宽待她是心领的，于是加倍地要待她好，报恩似的。\n这次试镜变成了她们两人的伤心事，都怀有一些失败感的。后来，她们逐渐变得连话也不大讲了，碰面都有些尴尬地匆匆避开。当她们坐在课堂的两头，虽不对视，可彼此都感觉到对方的存在，有一种类似同情的气氛在她们之间滋生出来。\n吴佩珍又说：我本来想把信投在这里的，结果却自己送来了。王琦瑶不说话，看着那邮筒。停了一会儿，两人都哭了。她们也不知在哭些什么，有什么可哭的，只是觉得心里有一种无法挽回的难过。有一种和她们纯洁无忧的闺阁生活有关的东西似乎失不再来了，她们从此都要变得复杂了。\n她和吴佩珍的关系是彼此没有责任的关系，全凭的是友情。与蒋丽莉便不同了，是有些利益的，当然，利益也不是不好的利益。她和吴佩珍的关系是有些类似萍水的关系，至清而无鱼，和蒋丽莉却是莲藕和泥塘。吴佩珍的走，是将王琦瑶这段无字的历史剪下带走的，剩下的全是有字，有些混乱不成章节，是过于认真写，笔墨太重，反不那么流畅自然了。\n二、同学们中间流传着蒋丽莉家的排场，她又从不带人去她们家，就更显得神秘了。这事要放在过去，无论怎样的好奇，王琦瑶都只能有一个做法，就是拒绝，她是不会把自己奉献给别人的热闹里的。可如今她却不那么在意了，再说，谁知道呢？说不定到头来人家的热闹反过来奉献给她的。\n她们不同于一般女同学的要好，同进同出，嘁嘁喳喳，有说不完的心里话，就像王琦瑶和吴佩珍那样的。她们不这样交往是各有原因。在王琦瑶，是不愿给人留下厚此薄彼的印象，内心深处，则是有着对吴佩珍的顾恤，虽是她不愿承认的；而在蒋丽莉，却是为了与众不同，她凡事都要反着大家来，她做人行事的原则最简单，就这一个公式。她们俩在做朋友的趣味又都有些不同于女学生的地方，都有些自以为不俗的，王琦瑶是因为经历，蒋丽莉则来源于小说。\n蒋丽莉对父母兄弟都是仇敌一般，惟独对个王琦瑶，把心里的好兜底捧出来一样的，好像要为她的爱找个靶子似的。这爱不仅是她自己的，还加上小说里看来的，王琦瑶真有些招架不住了。王琦瑶内心又可怜她，觉得她是有的不要，要的没有，对人对己都是无敌的折磨。因此才能由着她胡来，只是见她闹得过分了，不得不说她几句。这时候，她就成了一个不知错在哪里的孩子，满脸的害怕和惶惑。心里又是不忍。\n她想她虽然没有承诺程先生什么，可毕竟侵占了蒋丽莉的机会，她要不知道蒋丽莉的心意还好，而蒋丽莉偏是第一个要让她知道。王琦瑶的感情不是小说里读来的，没有那么多美丽的道理，可讲的是平等互利的原则，有来有往，遵义守信。她心里对蒋丽莉抱愧，行动上便对她好过从前，把她当亲姐妹一般。\n有一天，王琦瑶又不在家，蒋丽莉为了找一本借给王琦瑶的小说，进了她的房间。小说没找到，却在枕边看到了那一些照片，还有照片后面的题词。程先生对王琦瑶许多明显的用心都为她视而不见地忽略了，这些照片却终于拨开迷雾，使她看清了真相。这其实也是长期以来存在心底的疑虑，有了一个突破口，便水落石出。这一真相摧毁了蒋丽莉的爱情，也摧毁了她的友谊。这两种东西都是蒋丽莉掏心掏肺对待的。因是一相情愿，那付出便是加了倍，不料却是这样的结果。\n三、严师母第一眼见王琦瑶，心中便暗暗惊讶，她想，这女人定是有些来历。王琦瑶一举一动，一衣一食，都在告诉她隐情，这隐情是在繁华场上的。她只这一眼就把王琦瑶视作了可亲可近。严家师母在平安里总是鹤立鸡群，看别人都是下人一般，没一个可与她平起平坐。现在，三十九号住进一个王琦瑶，不由她又惊又喜，还使她有同病相怜之感。也不管王琦瑶同意不同意，便做起她的座上客。\n王琦瑶在镜子前流连的时间多了些，镜子里的人是老朋友，也是新认识，能与她说话的。严家师母看见她的变化，暗中加了把劲追赶。王琦瑶显见得比她懂打扮，也是仗着年轻有自信，样样方面都是往里收，留有余地，不像严家师母是向外扩张，非做到十二分不可。一个是含而不露，一个是虚张声势；一个是从容不迫，一个是剑拔弩张。严家师母不使劲还好，越使劲越失分寸，总是过火。王琦瑶当然觉察出严家师母的用力，更上了几分心。像她这样的聪敏，不上心就是合适，再要上心便是格外好了，由不得严家师母不服气。\n《文化苦旅》小感 王道士的确是一个可恨的罪人，我们完全可以把所有的愤怒发到他一个人身上，当时我们也应该想想，王圆箓他只是一个道士也就是一个农民，他有那么强的保护民族文化意识吗？我想不光是他，当时我们国家80%以上都是贫穷的农民，这些人们都和王圆箓一样平庸，他们整天还在为自己和家人的衣食而奔路，他们哪有那个闲工夫去提高自己的爱国精神和保护祖国宝贵的文化遗产的意识。\n真正的罪人应该是软弱无能的清政府！余先生也说到，就算他当时看到这一幕，并奋力将文物从掠夺者手中夺回，可那又能怎么样？清政府永远不会帮助你，帮助国家保护的，到最后还不是落入其他人之手。说的难听的这也是活该，这场历史悲剧是个必然。\n庆幸的是我们可爱的敦煌研究院的专家们他们没有忘记这段屈辱，把悲痛化为力量，潜心研究敦煌文化。他们是伟大的！\n再看看现在一些无耻之徒企图再来这一手，什么韩国申请将端午节纳入他们国家的文化遗产，日本要把风水申报为世界遗产之类消息，不绝于耳！但他们忘了我们已是中国21世纪的人们，不可能再像那时的民众那样无知与盲目，我们会不惜一切保护中华五千年的文化遗产。没有谁能把你抢离我身旁！ 借温总理的一句经典的话奉劝你们“任何卑鄙的伎俩是偷不走我们合法的千年文化的！”任何力量也阻止不了我们伟大祖国的繁荣！\n叶子•阿桑•感悟麦迪  叶子是不会飞翔的翅膀，翅膀是落在天上的叶子。。。\n给你的爱一直很安静。。。\n你听寂寞在唱歌，轻轻的狠狠的。。。\n 阿桑的悲伤一直在我心底萦回，4月是伤感的，清明时节雨纷纷，阿桑的离去，很安静，很安静。。。\n阿桑让我们很矛盾，似乎一直以来她带给我们的只是绝望，悲伤，或许我们回被她沙哑的声音打动，我们认可她的深情，却无法崇拜她，无法像对待别的明星一样追捧她。。。\n麦迪也让我们很矛盾，一直以来我们肯定他的天赋，膜拜他的潇洒，却无法坚信他的作用。。。\n叶子，阿桑就像那片无法成为翅膀的叶子，我们欣赏她的歌声，但我们不得不承认，阿桑永远不会成为天王巨星，或许当她飞往天堂的那一刻，才让我们记起这个曾经唱歌唱到我们绝望的女人，这一刻或许她真正成为了落在天空的翅膀，但我们知道，回忆和伤感只是暂时的，对阿桑的追思不会像张国荣，梅艳芳一样持久。。。\n翅膀，麦迪却是那片落在天上的叶子，两届得分王，35秒13分，22连胜，的确曾经的麦迪像是插着翅膀的神，是那个能让老天也感动得流泪的疯子，但是现在一切都变了，麦迪的翅膀成了断翼，看着他打铁，看着他伤停，看着他赛季报销，责备声四起，我们所膜拜的一号已经不复存在，伴随着麦迪的是软蛋之类的骂名，他变成了孤独的叶子。。。\n阿桑和麦迪都是可悲的，命运对他们都是不公平的。。。他们有过闪光，他们努力却无法到达他们期待的荣誉，对阿桑的回忆似乎成了对麦迪最大的思考，阿桑的悲伤似乎是麦迪最好的安慰。\n歌唱界不需要阿桑吗？当我们失落时是谁的声音在我们心里与我们的心情相融合，是谁让我们的忧伤变得安静。我们承认阿桑不红，却无法忘却她带给我们内心最深处的震撼与感触。\n火箭不需要麦迪么？火箭需要他，特别是一个健康的他。责备麦迪是因为曾经的我们对他产生了极大的期望，我们把他当救世主，我们相信他，我们需要他，我们甚至认为麦迪是奇迹的代名词，我们希望他无所不能，我们期待他劈荆斩棘。我们可以承认麦迪的落魄，却无法让自己在火箭打不开局面时不想起他的名字。\n阿桑和麦迪也是不同的，即使他们曾经到达他们的颠峰，即使他们都是失意的，即使病魔都让他们的命运变得不公平，但是麦迪比阿桑幸运，麦迪还有明天，阿桑的面容却只能在我们的回忆里逐渐褪去，我们也只能在声音中寻找对她的一丝回忆。我期待着明天的麦迪，就如同我怀念已逝的阿桑，都带着那一份敬意，一份对他们辉煌时的崇拜。\n已经50胜的火箭似乎不再需要麦迪，但我仍旧相信他，就算他不会再有颠峰，但我相信他会有希尔的那份坚强，那份毅力，那时的我依旧会在他干拔后为他鼓掌，为他欢呼。\n逝去的阿桑，飘落的叶子，希望让对麦迪的嘘声变得很安静，因为在麦子的心里寂寞一直在唱歌。\nPS：在知道阿桑离去之后，我们才想起了以前那个唱《叶子》唱到让人绝望的回响，那个一直很安静的女人。。。难道当麦迪退役时，我们只给他“曾经俯视篮筐的男人”这样的评价么，希望大家能看到火箭季后赛走远，也希望大家别忘了那个忧郁的一号\n读书计划 前几日，新东方的俞洪敏、王强和徐小平三位老师一行来到我们学校，在校礼堂举办意味深长的励志演讲。其中，俞老师说道他和王强老师上大学的时候的读书故事，也是在呼吁我们大学生要好好读书，给我们的指标是一星期至少两本，也就是大学四年至少要读到400本，愈老师是800多本，王老师读了超过了一千本，而且家中藏书达到6万本（如果我没有听错的话）。现在我们确实不想他们那样喜爱读书，大部分嗜书如命的书估计是武侠或者神幻小说，看过《坏蛋是怎么炼成的》的大学生绝对要比《明朝那些事儿》要多，而且要多得多。我为什么这么说呢？第一，当俞老师问我们有几个人看过《明朝那些事儿》的时候，3千多人只有两三只手举起来。第二、我看到同学手机或p4里的电子书里大部分都是《坏》之类，不会是《明》，那更不会是《马列主义》或者《西方哲学史》之类。第三、我是一名大众型大学生，也就是说我的经历可以基本代表广大同学的经历，而我就是看过《坏》没看过《明》，虽然知道这样不是，而且知道《明》很不错，但是就是没有那份静宁的心去看完他，每次都是看到几页就不想继续\u0026hellip;.\n所以我要把自己的读书计划写出来，也借此激励自己、督促自己!\n王安忆《长恨歌》(完成)\n路遥《平凡的世界》（完成）\n林语堂《京华烟云》（第十周前）\n当年明月《明朝那些事儿》（第十周）\n曹雪芹《红楼梦》（第十一周）\n余秋雨《文化苦旅》林语堂精品散文（第十周——第十一周）\n以后我会继续更新\u0026hellip;..相信自己可以办到！！！\n明朝皇帝与大臣名士_朱元璋时代 太祖朱元璋(1328-1398) “洪武”1368年称帝，在位31年\n徐 达（开国第一武将，后暴病而亡。有蒸鹅之说）\n常遇春（开国第二武将，善射击，后阵亡）\n李文忠（朱元璋外甥，马皇后求饶而幸免）\n冯 胜（死于蓝玉案。其哥冯国用战亡。手下有猛将傅友德）\n李善长（大明首席参谋长，江淮集团首长，赶走刘基，后被赐死）\n邓 愈（大将，与以上六大将帅并称为开国六公）\n蓝 玉（最后的名将，常遇春内弟，蓝玉案同党达一万五千人）\n胡惟庸（丞相，李善长老乡，胡惟庸案被杀者超过一万人。后取消了丞相制度）\n刘 基 (刘伯温，军师，类诸葛亮)\n汤 和（书信一封，劝朱元璋加入叛军）\n朱文正（朱元璋亲侄子，镇守江西洪都，立奇功，后叛变）\n王保保（著名元将，明建国前后主要对手）\n徐寿辉（陈友谅杀之）\n陈友谅（朱元璋最大的劲敌）\n张士诚（第二劲敌）\n郭子兴（朱元璋岳父，收养马皇后）\n马皇后（朱元璋最爱）\n韩林儿和刘福通\n锦衣卫\n明朝皇帝与大臣名士_嘉靖时代 世宗朱厚璁(1507-1566) 年号“嘉靖”1521年即位，在位46年，其父兴献王。\n刘 瑾（明朝著名太监，统治东厂，锦衣卫，权倾一时）\n杨廷和（内阁首辅，敬业但不无私。儿子杨慎天赋异禀）\n杨一清（内阁大臣，与张永一起铲除权奸刘瑾）\n张 永（曾帮助王明阳平定宁王叛乱）\n张 璁（斗到杨一清，与桂萼一起，有一疑问他名字不是和皇帝的冲突吗？！为什么不避讳？）\n郭 勋（名将郭英（郭兴之弟）后代，嚣张跋扈）\n夏 言（正直，不结党营私，专权，斗到张璁、郭勋）\n严 嵩（杨廷和提拔，起初还比较正直。明代第一奸臣）\n嘉靖六才子：\n 杨 博（智取蛮蕃劫匪） 陆 柄（最强锦衣卫，嘉靖童友，行类步鹤） 严世蕃（严嵩之子，独眼，为其父之谋士，善写青词，揣测皇帝之意） 徐 阶（童时一次落井一次掉悬崖大难不死，拜师于聂豹（王学弟子）在夏言、杨廷和等人的推荐1523年进入翰林院，年轻气盛，贬官，参悟“知行合一”，1539年夏言公直提拔再入京） 高 拱（1541年进入翰林院，辅助嘉靖一字裕王【太子去世，另一子景王】斗到徐阶，成为首辅） 张居正（隐忍数年，联合冯保，利用遗诏，整到高拱，成为帝国主宰者，大兴变法，百业复苏。[传与万历生母李太后关系暧昧]）\n胡宗宪（智斗贼倭，汪直和徐海，为民请命。一代好官）\n戚继光（抗倭英雄，戚家军名扬中华。【惧怕老婆】）\n徐文长（徐渭，浙江才子。尤擅画，乃胡宗宪之师爷）\n俞大猷（抗倭将帅）\n海 瑞( 猛人，弹劾皇帝入牢，后成为陈列品，实无用处，是乃一模范标本。成为门神，张贴以避邪去害)\n杨继盛（硬汉，弹劾严嵩，死得壮烈）\n俺 答（鞑靼首领，入侵大同，后直接攻入北京，史称“庚戌之变”）\n张文华（严嵩养子，实打实的小人）  附件：\n 【明代三大才子：解缙、杨慎、徐渭】不含唐伯虎 嘉靖时代人才济济，知名大臣如上成列，而且这个时代在其他文学和医药方面也是独树一帜，成果辉煌。\n李时珍，随父学医，成为御医，但皇帝每天炼丹欲成仙，李时珍在研究完宫廷内藏的医书之后，离开皇宫，成为江湖郎中，名噪一时。后游历各地，学神农尝百草，著书《本草纲目》，是乃中国医学史的经典。在世界也是不二的名著。\n吴承恩《西游记》作者。参与编著《三国演义》。\n徐渭：徐文长是也，齐白石曾说“愿为渭之门前狗” 明代四大名著\n《水浒传》、《三国演义》、《西游记》、《金瓶梅》中的《西游记》、《金瓶梅》就是在嘉靖时代成书的。\n金瓶梅，一般认为是王世贞所写，而主角西门庆一般认为是严世蕃（东楼对西门）。  《明朝那些事儿》读后感 历时一个多月，终于是断断续续地把《明朝那些事儿》读完了，现在才后悔，我应该在暑假花上两三天一口气读完她！读上第二遍已然没有第一遍来的新鲜和有趣。可是当时一看就上瘾了，即使自己再忙再累，那也要每天晚上都会用手机一直看到没电的后才罢休。下面我就谈谈我对明朝的历史的大概印象。资历有限，实属扯淡，如有意见，请勿拍砖！\n写感想之前还是要谈谈这本书，关于《明朝那些事儿》的评价各有褒贬，我想我们要弄清一个源本，那就是当年明月起初创作这“书”的初衷是什么？为什么我要在“书”上打引号，正是因为他根本没有想到会这样喜欢人们的喜爱，他没有任何的盈利企图。这些我们从第一册的开头就可以看到。其实，说再多那都是废话，我们在此妄加评议，不管是好还是坏，我想我们大家都没有资格发言。因为销售量、评述录音、网络资源等等数据已经证明大家在心里对《明》的认可和喜爱。不用我们用什么批判和褒扬，相信当年明月也不在乎！他只是在做自己喜欢的事情而已。\n一提到明朝我们大致可以想到一些人：朱元璋、朱棣、郑和、严嵩、魏忠贤、海瑞、戚继光、崇祯、袁崇焕、李时珍、徐文长、唐伯虎等等.还有一些事物：永乐大典、郑和下西洋、抗倭、东厂、太监、四大名著、本草纲目等等。我们可以通过这些熟悉的字眼想到背后的历史故事。《明》是定位在“历史可以写的更好看点”的一部史书，也是通过这些鲜明的任务、引人的故事以及幽默的现代语言锁住我们的心，让我们也决定看史书也要看好看的！\n很多历史学家认为“明之亡，毁于宦官，再言官”，当年明月在书中曾说“明之亡，先毁于言官，再是宦官”。我很是同意，书中描写言官们是如何斗智斗勇，如何斗奸斗诈，斗到阻碍自己夺权的一切实力，包括皇帝。完全是“长江后浪推前浪，指定把敌人拍在沙滩上”的顽强拼搏和不怕抄家的精神。这里也要分为两类，一类就是为了权力，不为钱财不为富贵，而且他们得到权力确确实实办事，为民谋福。典型代表有王守仁、张居正等。这类官员可以算为好官。还有一类就是权奸，得到权力就为自己怎么豪华怎么阔气，根本不管黎民百姓的死活，典型代表就是严嵩、魏忠贤。联想到现在的贪官们，基本可以同日而语。实乃为我辈汗颜！！！\n另一个我比较感兴趣的就是明朝的思想和其他的时代都不太一样，明朝可以看到民众非常的开明，思想也非常的多元化。究其原因我个人认为，首先，明朝的官方统治思想就是朱学，也是儒家学说的发展与演变。朱元璋老太祖非说人家朱熹是他祖宗，不知道朱熹老人家在天有灵知道摊了这么些个后代子孙，是喜还是悲？！言归正传，另外一种非官方的思想就是王守仁的心学，核心思想“格物致知”。而这种学说的学派发展竟然压制了官方正统的朱学，这就大大的开拓了民众的意识，禁书《金瓶梅》就出自这个时代。从另一方面，到明朝也已经有上千年的历史了，岁月的洗礼和历史的年轮已经让这个太平中有随时会有些动荡的明朝变得很强大很成熟，以致可以海纳百川，可以包容万象。最后我想还可能和倭寇入侵和抗倭援朝也有一定的关系。\n真的感谢当年明月，呕心沥血的为我们大家呈现了这么一部趣味的史书！希望月哥可以创作更多的好作品，以慰藉我们求书似渴的广大读者。谢谢！\n迟来的暑假体会 2009-08-19 这个暑假给我最大的体会是“四十而不惑”中的“惑”也。这个体会实在是在有些晚，直到这一刻才明白。暑假可以说麻木的，迷迷糊糊。可是就是这样的糊涂才换来这一刻的清醒！\n原本就计划不回家，在学校里呆着，可是最终还是很是挣扎的回家了，这就叫背叛，是身体对心理的背叛！自然而然，回到家里还是向往在学校会是如何如何的好，在家实在是太无聊了。想想光想是没用的，还得把暑假过完，找个合理点的借口早些回学校吧！于是，耐着很大的性子看完从图书馆接的几本书，就这里转转，那里悠游，会会同学。但就是觉得不如学校自由爽快！\n实在是到了忍耐的饱和极限！我决定提前回学校，这次风雨无阻，谁也别拦我！呵呵\u0026hellip;就这么滴稀里糊涂的回学校了。\n可学校怎么样呢！你看看我现在有时间在这无聊的写体会，你就该想到其实是一样的无聊呀！确实，下火车的那一刻，心里想着：回来了，还是学校好！\n到了宿舍，问问没回家的同学，暑假怎么样？出我意料又合情合理的答案是，无聊和无味！\n这时候我惶然大悟，我们都是一样的原因！不是用最真的心去支配我们的行为。我们面对太多的“惑”！何谓“惑”?惑，乃心字上面加个或，而这个或就是选择的意思，亦即犹豫。如果我们的心犹豫了，那我们就会迷茫，就会迷失！我们就是面对太多的选择，太多的迷惑，而使自己纯真的心无法平静，无法真实！\n我们真正的摆脱现实，达到庄子，老子等神贤的境界。就像我和同学互换一下，我在学校，他回家。我想我们的体会还是一样的。\n所以我们需要在这个选择太多，诱惑太多的世界里，保持一颗证明自己年轻的心，那才是最美的！简单点就是我们在家还是在学校那都无所谓，关键是我们要什么样的心态去面对什么样的生活！\n可能现在又在想我要是早点明白这些就不会浪费这一个暑假了！\n看，还是迷惑。\n现在也还是不晚！\n","description":"","id":47,"section":"life","tags":["Blog","Book"],"title":"随笔","uri":"http://austinzgx.github.io/life/essay/"},{"content":"安装及基本设置  下载 .Net Core SDK [MS官网][https://www.microsoft.com/net/learn/get-started/windows?utm_expid=.-Fmi9Q05Ry2oXQgdtPElHw.0\u0026amp;utm_referrer=]\n或者{GitHub地址}[https://github.com/dotnet/core] 下载 Visual Studio 2017 编辑器或者下载Visual Studio Core\n3. Vs code 编辑环境配置：   安装**c#**插件 \u0026quot;editor.mouseWheelZoom:\u0026quot; true ctrl+鼠标滚动放字体   cmd命令执行  dotnet new console  创建命令行程序 或者dotnet new mvc 创建ASP .Net Core MVC 项目 dotnet restore 通过NuGet来下载定义在project.json文件中的依赖，然后放到用户目录下的.nuget/packages文件夹中。默认情况下，下载依赖组建的过程是并行进行的。 dotnet build 编译 dotnet run 运行   使用cmd命令code .可以在VS code 中加载当前工作文件  #52ABP视频-.net core + EF core 学生管理系统\n#并行计算\n 摩尔定律 多核CPU\u0026ndash;并行  #ABP 代码生成框架\nMPA版本：.Net Core + JQuery\nSPA版本: .Net Core + Angular\n实体信息：Person + Phone\nhttp://www.aspnetboilerplate.com/\n程序包管理管理器控制台\nPM\u0026gt; update-database\nMPACore.PhoneBook.Application\n中转层MVC\u0026raquo;\u0026gt;Application\u0026raquo;\u0026gt;Core\n#添加引用：\n终端命令：\ndotnet add package Microsoft.EntityFrameworkCore.Design \u0026ndash;version 2.0.1\ndotnet add package Pomelo.EntityFrameworkCore.Mysql \u0026ndash;version 2.0.1\ncsproj:添加\n\r\u0026lt;PackageReference Include=\u0026quot;Microsoft.EntityFrameworkCore.Design\u0026quot; Version=\u0026quot;2.0.2\u0026quot; /\u0026gt;\r\u0026lt;PackageReference Include=\u0026quot;Pomelo.EntityFrameworkCore.Mysql\u0026quot; Version=\u0026quot;2.0.1\u0026quot; /\u0026gt;\r\u0026lt;DotNetCliToolReference Include=\u0026quot;Microsoft.EntityFrameworkCore.Tools.DotNet\u0026quot; version=\u0026quot;2.0.1\u0026quot;/\u0026gt;\r \r#添加已有数据库（model first)\ndotnet ef dbcontext scaffold \u0026ldquo;server=localhost;database=world;user=root;pwd=12346;\u0026rdquo; \u0026ldquo;Pomelo.EntityFrameworkCore.Mysql\u0026rdquo; -o .\\Models -f\nData first\n 必须设置主键，Id会自动识别为主键 dotnet ef migrations add Init dotnet ef database update  Mysql字段设置为中文\nalter table yanshi.project CONVERT TO CHARACTER SET utf8\n  空白Controller\ndotnet aspnet-codegenerator controller -name LineZero -outDir Controllers\n  增删查改Controller\ndotnet aspnet-codegenerator controller -name LineZero -actions -outDir Controllers\n命令增加一个：-actions\n  增删查改+EF Controller\n生成增删查改的action 及对应的视图。\ndotnet aspnet-codegenerator controller -name LineZeroController -m ApplicationUser -dc ApplicationDbContext -outDir Controllers -udl\n-m 指的是model\n-dc 指 DbContext\n-udl 指 useDefaultLayout\n  #使用脚架创建页面时可能出项中文乱码，需要把cshtml文件有ANSI编码格式用记事本转化为UTF8格式\n#HttpPost 特性指定只能为 POST 请求调用此 Edit 方法。 可将 [HttpGet] 属性应用于第一个编辑方法，但不是必需，因为 [HttpGet] 是默认设置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public async Task\u0026lt;IActionResult\u0026gt; Edit(int? id) { if (id == null) { return NotFound(); } var movie = await _context.Movie.SingleOrDefaultAsync(m =\u0026gt; m.ID == id); if (movie == null) { return NotFound(); } return View(movie); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  [HttpPost] [ValidateAntiForgeryToken] public async Task\u0026lt;IActionResult\u0026gt; Edit(int id, [Bind(\u0026#34;ID,Title,ReleaseDate,Genre,Price\u0026#34;)] Movie movie) { if (id != movie.ID) { return NotFound(); } if (ModelState.IsValid) { try { _context.Update(movie); await _context.SaveChangesAsync(); } catch (DbUpdateConcurrencyException) { if (!MovieExists(movie.ID)) { return NotFound(); } else { throw; } } return RedirectToAction(\u0026#34;Index\u0026#34;); } return View(movie); } \u0026lt;form action=\u0026#34;/Movies/Edit/7\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt;   网站部署  添加角色服务器IIS 安装VC++ 2015 安装 DotNetCore.2.0.5-WindowsHosting 添加网站，使用无托管应用池 配置云的安全组 安装数据库迁移  ","description":"","id":48,"section":"code","tags":null,"title":"","uri":"http://austinzgx.github.io/code/dotnetcore/asp-.net-core-mvc-%E5%AD%A6%E4%B9%A0/"},{"content":"Configuring Applications  What is it?  Program、Startup classes JSON files   What is it Useful?  配置程序环境 管理依赖包   How is it used?  Startup 类:  服务(Services): 提供全局的功能函数对象 中间件(middleware components): 处理HTTP请求      Preparing  bower.json  1 2 3 4 5 6 7  { \u0026#34;name\u0026#34;: \u0026#34;asp.net\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;dependencies\u0026#34;: { \u0026#34;bootstrap\u0026#34;: \u0026#34;4.1.1\u0026#34; } }   _ViewImports.cshtml   addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers\rApp.csproj  1 2 3 4 5 6 7 8 9 10 11  \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;netcoreapp2.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;Folder Include=\u0026#34;wwwroot\\\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.All\u0026#34; Version=\u0026#34;2.0.0\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt;   The X ML Configuration Elements in the Default csproj File\nElement | Description\n | :-\nProject |This is the root element, which denotes that this is an MSBuild configuration file. The Sdk attribute is set to Microsoft.NET.Sdk.Web to provide the set of implicit package imports that are required to build the project.\nPropertyGroup| This element groups related configuration properties to add structure to the file.\nTargetFramework| This element specifies the .NET Framework that is targeted by the build process and must be defined within a PropertyGroup| element. The default value is netcoreapp2.0 , which targets .NET Core 2.0. ItemGroup| This element groups related configuration items to add structure to the file. Folder| This element tells MSBuild how to deal with a folder in the project. The element in the listing tells MSBuild to include the wwwroot folder when the application is published. PackageReference| This element is used to specify a dependency on the NuGet package, which is identified through the Include and Version attributes. The Microsoft.AspNetCore. All package is used to provide access to all of the individual packages that provide ASP.NET Core and MVC Framework functionality.  Adding Packages to Project  csproj file: List the packages that the project depends on. dotnet add package System.Net.Http --version 4.3.2  1 2 3 4  \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.All\u0026#34; Version=\u0026#34;2.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;System.Net.Http\u0026#34; Version=\u0026#34;4.3.2\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt;      Adding Tools Packages to Project  \u0026lt;DotNetCliToolReference Include=\u0026quot;Microsoft.EntityFrameworkCore.Tools.DotNet\u0026quot;\rVersion=\u0026quot;2.0.0 \u0026quot; /\u0026gt; dotnet command-line tool    Understanding the Program class Web项目概览 分类：\n Web Pages（WebForms，以页面为单位） MVC （以数据或数据模型） Web API （中间产品，HTTP协议）  三种类型的项目是可以混合使用\n","description":"","id":49,"section":"code","tags":null,"title":"","uri":"http://austinzgx.github.io/code/dotnetcore/asp.net-core-mvc2-in-detail/"},{"content":"知识点 杂  multi-tenancy technology:多租户技术 创建实体类Person:FullAuditedEntity 使用默认的字段 HttpPost 特性指定只能为 POST 请求调用此 Edit 方法，使用[HttpPost]属性，提交请求 可将 [HttpGet] 属性应用于第一个编辑方法，但不是必需，因为 [HttpGet] 是默认设置，用户请求  IENUMERABLE | IQUERYABLE INTERFACES  The IQueryable interface is useful because it allows a collection of objects to be queried efficiently. retrieving a subset of Product objects from a database. using the IQueryable interface allows me to ask the database for just the objects that I require using standard lINQ statements and without needing to know what database server stores the data or how it processes the query. Without the IQueryable interface, I would have to retrieve all of the Product objects from the database and then discard the ones I don’t want, which becomes an expensive operation as the amount of data used by an application increases. It is for this reason that the IQueryable interface is typically used instead of IEnumerable in database repository interfaces and classes. however, care must be taken with the IQueryable interface because each time the collection of objects is enumerated, the query will be evaluated again, which means that a new query will be sent to the database. This can undermine the efficiency gains of using IQueryable. In such situations, you can convert IQueryable to a more predictable form using the ToList or ToArray extension method  常用备忘 资源  开源纯c#工控网关+组态软件\nGithub  插件for VsCode  Vim Yeoman 一套工具集合通过模板的方式，生成Asp.net Core的项目文件，单独生成Controller、View等文件\nnpm install -g yo bower grunt-cli gulp  VSCode安装及基本设置  下载 .Net Core SDK MS官网\n或者GitHub地址 下载 Visual Studio 2017 编辑器或者下载Visual Studio Core Vs code 编辑环境配置： 安装**c#**插件  配置 \u0026quot;editor.mouseWheelZoom:\u0026quot; true ctrl+鼠标滚动放字体   cmd命令执行  dotnet new console  创建命令行程序 dotnet new mvc 创建ASP .Net Core MVC 项目 dotnet restore 通过NuGet来下载定义在project.json文件中的依赖，然后放到用户目录下的 .nuget/packages文件夹中。默认情况下，下载依赖组建的过程是并行进行的。 dotnet build 编译 dotnet run 运行   使用cmd命令code .可以在VS code 中加载当前工作文件  ABP代码生成框架   MPA版本：.Net Core + JQuery\n  SPA版本: .Net Core + Angular\n  ABP\n  *程序包管理管理器控制台 PM\u0026gt; update-database\n添加MySql引用： 终端命令：\n dotnet add package Microsoft.EntityFrameworkCore.Design \u0026ndash;version 2.0.1 dotnet add package Pomelo.EntityFrameworkCore.Mysql \u0026ndash;version 2.0.1  csproj:添加\n1 2 3 4 5  \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Design\u0026#34; Version=\u0026#34;2.0.2\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Pomelo.EntityFrameworkCore.Mysql\u0026#34; Version=\u0026#34;2.0.1\u0026#34; /\u0026gt; \u0026lt;DotNetCliToolReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Tools.DotNet\u0026#34; version=\u0026#34;2.0.1\u0026#34;/\u0026gt; \u0026lt;/ItemGroup\u0026gt;   数据库连接字符串 Mysql\n1 2 3  \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;ConnectionString\u0026#34;: \u0026#34;server=localhost;database=MyDatabase;user=root;pwd=12346\u0026#34; }   SqlServer\n1 2 3 4 5  \u0026#34;Data\u0026#34;: { \u0026#34;SportStoreProducts\u0026#34;: { \u0026#34;ConnectionString\u0026#34;: \u0026#34;Server=(localdb)\\\\MSSQLLocalDB;Database=SportsStore;Trusted_Connection=True;MultipleActiveResultSets=true\u0026#34; } }   ###startup.cs注入\n1  services.AddDbContext\u0026lt;MyDbContext\u0026gt;(d=\u0026gt;d.UseMySql(Configuration.GetConnectionString(\u0026#34;ConnectionString\u0026#34;)));   Model first 1  dotnet ef dbcontext scaffold \u0026#34;server=localhost;database=world;user=root;pwd=12346;\u0026#34; \u0026#34;Pomelo.EntityFrameworkCore.Mysql\u0026#34; -o .\\Models -f   Data first  必须设置主键，Id会自动识别为主键 dotnet ef migrations add XXX dotnet ef database update  标记属性验证 1 2 3 4 5  [Required] //必填 [DisplayName(\u0026#34;XXX\u0026#34;)]//显示名称 [Range(0,5)]//数据访问 [DisplayFormat(NullDisplayText=\u0026#34;NULL\u0026#34;)]//显示格式 [DisplayFormat(ApplyFormatInEditMode=true,DataFormatString=\u0026#34;{0:C}\u0026#34;)]//显示格式   一对多|多对多  人员：\n一个人员对应一个专业，但一个专业可以有多个人。属于一对多关系,设置外键,使用Include多表查询  1 2 3 4  await _context.Staff .AsNoTracking()//加快查找效率  .Include(a =\u0026gt; a.Professional)//依据外键找到对应的表，查找数据  .ToListAsync();   也可利用Join多表查询实现一对多,需要另建ViewModel转化类,数据库可以不关联\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var staff = await _context.Staff.AsNoTracking().ToListAsync(); var staffNew = staff.Join( _context.Professional, a =\u0026gt; a.Type, b =\u0026gt; b.Id, (a, b) =\u0026gt; new ProfessionalEnrollment //ViewModel类  { Id = a.Id, Sex= a.Sex==\u0026#34;0\u0026#34;?\u0026#34;男\u0026#34;:\u0026#34;女\u0026#34;, Name=a.Name, Department=a.Department, TypeName=b.Name //重新给需要转换属性赋值，将viewmodel查询后返回View  } );   一个人可以属于多个申请单，一个申请单中又有多个人，属于多对多关系,需要添加第三张注册表，使用Include多表查询\n1 2 3 4 5  await _context.Apply .AsNoTracking() .Include(a =\u0026gt; a.Staffs) //对应的第三张表  .ThenInclude(a=\u0026gt;a.Staff) //依据第三张表找到对多对中数据  .ToListAsync();   人员表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class Staff { public int Id { get; set; } [DisplayName(\u0026#34;姓名\u0026#34;)] public string Name { get; set; } [DisplayName(\u0026#34;性别\u0026#34;)] public string Sex { get; set; } //对应申请单，可以是多个  public ICollection\u0026lt;ApplyStaff\u0026gt; Applies { get; set; } //对应专业,只有一个 [ForeignKey(\u0026#34;Type\u0026#34;)]//指定外键  public virtual Professional Professional { get; set; } }    科室专业:（一对多）  1 2 3 4 5 6  public class Professional { public int Id { get; set; } public string Name { get; set; } public ICollection\u0026lt;Staff\u0026gt; PerfessionalStaff {get;set;} //对应多个人员  }    申请单：（多对多）  1 2 3 4 5 6 7 8 9 10 11 12 13  public class Apply { public int Id { get; set; } [DisplayName(\u0026#34;课题号\u0026#34;)] public string Num { get; set; } [DisplayName(\u0026#34;课题名称\u0026#34;)] public string Name { get; set; } [DisplayName(\u0026#34;实验人员要求\u0026#34;)] public ICollection\u0026lt;ApplyStaff\u0026gt; Staffs { get; set; }//对应多个人员  }    多对多的注册表  1 2 3 4 5 6 7 8 9  public class ApplyStaff { public int Id { get; set; }// 主键  public int EApplyId { get; set; }//申请单Id  public int StaffId { get; set; }//人员Id  public EApply EApply { get; set; }//申请单 只能唯一  public Staff Staff { get; set; }//人员 只能唯一  }   常用终端命令创建视图控制器  空白Controller  1  dotnet aspnet-codegenerator controller -name XXXX -outDir Controllers    增删查改Controller  1  dotnet aspnet-codegenerator controller -name XXXX -actions -outDir Controllers   命令增加一个：-actions\n 增删查改+ EF Controller + 对应视图  1  dotnet aspnet-codegenerator controller -name LineZeroController -m ApplicationUser -dc ApplicationDbContext -outDir Controllers -udl   -m 指的是model\n-dc 指 DbContext\n-udl 指 useDefaultLayout\n-f 指强制执行\n 备注 使用脚架创建页面时可能出项中文乱码，需要把cshtml文件有ANSI编码格式用记事本转化为UTF8格式,使用鼠标操作新建带有基架项目则没有问题，这是微软的一个Bug  网站部署  添加角色服务器IIS 安装VC++ 2015 安装 DotNetCore.2.0.5-WindowsHosting 添加网站，使用无托管应用池 配置云的安全组，创建默认的一些端口 安装数据库迁移 启动网站服务  学习 应用程序配置  比过去 Asp.Net配置简洁，但是来源比较丰富  环境变量读取 命令行参数 JSON|XML文件读取 内存数据（字典） 自定义配置来源（数据库、文件）   是否不使用Startup来配置应用程序  可以这样做，但是不推荐。入口点代码较长，不利于管理。    html常用 Index详情、编辑、删除 1 2 3  \u0026lt;a class=\u0026#34;layui-btn layui-btn-primary layui-btn-xs\u0026#34; asp-action=\u0026#34;Details\u0026#34; asp-route-id=\u0026#34;@item.Id\u0026#34;\u0026gt;详情\u0026lt;/a\u0026gt; | \u0026lt;a class=\u0026#34;layui-btn layui-btn-xs\u0026#34; asp-action=\u0026#34;Edit\u0026#34; asp-route-id=\u0026#34;@item.Id\u0026#34;\u0026gt;编辑\u0026lt;/a\u0026gt; | \u0026lt;a class=\u0026#34;layui-btn layui-btn-danger layui-btn-xs\u0026#34; asp-action=\u0026#34;Delete\u0026#34; asp-route-id=\u0026#34;@item.Id\u0026#34;\u0026gt;删除\u0026lt;/a\u0026gt;   Layui轮播 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;script src=\u0026#34;~/lib/layui/layui.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; @*-引用layui.js脚本*@ \u0026lt;script\u0026gt; layui.use(\u0026#39;carousel\u0026#39;, function () { var carousel = layui.carousel; //建造实例  carousel.render({ elem: document.getElementById(\u0026#34;idname\u0026#34;) //通过id获得元素  , width: \u0026#39;100%\u0026#39; //设置容器宽度  , arrow: \u0026#39;hover\u0026#39;//始终箭头显示方式  , height: \u0026#39;500px\u0026#39; //,anim: \u0026#39;updown\u0026#39; //切换动画方式  }); }); \u0026lt;/script\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;div class=\u0026#34;layui-carousel\u0026#34; id=\u0026#34;test1\u0026#34; style=\u0026#34;margin-top:10px\u0026#34;\u0026gt; \u0026lt;div carousel-item\u0026gt; \u0026lt;div class=\u0026#34;layui-this\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;img-responsive\u0026#34; src=\u0026#34;~/images/Info0.jpg\u0026#34; /\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img class=\u0026#34;img-responsive\u0026#34; src=\u0026#34;~/images/Info2.jpg\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img class=\u0026#34;img-responsive\u0026#34; src=\u0026#34;~/images/Info3.jpg\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img class=\u0026#34;img-responsive\u0026#34; src=\u0026#34;~/images/Info4.jpg\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;layui-carousel-ind\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li class=\u0026#34;layui-this\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button class=\u0026#34;layui-icon layui-carousel-arrow\u0026#34; lay-type=\u0026#34;sub\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;layui-icon layui-carousel-arrow\u0026#34; lay-type=\u0026#34;add\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/div   C#语法 可空\\三元\\空合并   可空类型修饰符(?)：\n引用类型可以使用空引用表示一个不存在的值，而值类型通常不能表示为空。\n例如：string str=null; 是正确的，int i=null; 编译器就会报错。\n为了使值类型也可为空，就可以使用可空类型，即用可空类型修饰符\u0026quot;？\u0026ldquo;来表示，表现形式为\u0026quot;T？\u0026rdquo;\n例如：int? 表示可空的整形，DateTime? 表示可为空的时间。\nT? 其实是System.Nullable(泛型结构）的缩写形式，也就意味着当你用到T？时编译器编译 时会把T？编译成System.Nullable的形式。\n例如：int?,编译后便是System.Nullable的形式。\n  三元（运算符）表达式（?:)：\n例如：x?y:z 表示如果表达式x为true，则返回y；如果x为false，则返回z，是省略if{}else{}的简单形式。\n  空合并运算符(??)：\n用于定义可空类型和引用类型的默认值。如果此运算符的左操作数不为null，则此运算符将返回左操作数，否则返回右操作数。\n例如：a??b 当a为null时则返回b，a不为null时则返回a本身。\n空合并运算符为右结合运算符，即操作时从右向左进行组合的。如，“a??b??c”的形式按“a??(b??c)”计算。\n  截图 英文  Metallurgy 冶金  发布网站   恩菲研发\nhttp://172.26.17.180:9099/\n  博士后管理\nhttp://172.26.17.180:9098/\n  阿里云\n http://47.104.204.111 xtddw Administrator ggcjdss7/ 223073    ","description":"","id":50,"section":"code","tags":null,"title":"Asp .Net Core","uri":"http://austinzgx.github.io/code/dotnetcore/aspnetcore/"},{"content":"Java 基础 1 2 3 4 5 6  A aa = new A() // new A(); 在堆中动态分配一块区域，被当做了A对象 // aa本身的内存是在栈中分配的 // 堆中内存的地址赋给了aa // aa指向了堆中的内存，aa代表了堆中的内存 // aa.i 代表：aa这个静态指针变量所指向的动态内存中的A对象的i成员   Java 不会自动初始化局部变量，对于类的属性首先执行初始化语句，再执行构造函数。一旦自定义类构造函数，就不会创建无参默认构造函数。\ndocker mysql php client\n docker run \u0026ndash;name myadmin -d \u0026ndash;link mysql:db -p 8080:80 phpmyadmin/phpmyadmin\n Fegin  Feign makes writing java http clients easier\n   Fegin 组成\n  Fegin 日志级别\n  Fegin 配置\n  Ribbon Config VS Fegin Config\n  Fegin Code Config VS Fegin Attribute Config\n优先级：全局代码\u0026lt;全局属性\u0026lt;细粒度代码\u0026lt;细粒度属性\n  RestTemplate VS Fegin\n 尽量使用Fegin，合理选择    架构总结\n  容错  雪崩效应 Cascading Failure 级联失效 级联故障\n   解决方案\n 超时 限流 仓壁模式 断路器模式  断路器三态转换\n      alibaba-sentinel\nGithub\n  消息队列MQ  异步处理 ｜ 流量削峰填谷 ｜解耦微服务 RocketMQ （Alibaba） ｜ Kafka 分布式事务流程\n    Spring Cloud Stream immoc\n  架构\n  编程模型\n    Destination Binder 目标绑定器\n [与消息中间件通信的组件]    Destination Bindings 目标绑定\n [Binding是连接应用程序跟消息中间件的桥梁，用于消息的消费和生产，由binder创建]      Auth   RBAC: Role-based access control\n  用户——角色——权限\n  JWT: Json web token\nToken = Base64(Header).Base64(Payload).Base64(Signature) = aaa.bbb.ccc\nSignature = Header指定的签名算法\n  ","description":"","id":51,"section":"code","tags":null,"title":"java","uri":"http://austinzgx.github.io/code/java/base/"},{"content":"镍铁报奖 0.8*0.13/2.0 = 5% 渣\n","description":"","id":52,"section":"metal","tags":null,"title":"Ni","uri":"http://austinzgx.github.io/metal/ni/"},{"content":"软件  Listary vim total commander Emacs org-mode AHK  码字的时候，光标的移动是通过ctrl+h,j,k,l来实现，只有在文字输入的时候有效，不影响其他程序的快捷键的使用。  ;Vim Key Binding#if ( A_Cursor = \u0026quot;IBeam\u0026quot; or A_CaretX \u0026gt;= 100 )\r{　^j::send {down}　^h::send {left}　^k::send {up}　^l::send {right}　^0::send {home}　^!k::send {pgup}　^o::send {end}{enter}　^!o::send {home}{enter}{up}　!x::send {del}　^!X::send +{end}{del 2}　!d::send +^{left}{del}　; ^!d::send {home}{shift down}{end}{shift up}{del 2}　return\r}\r#if\r Mplayer WW 视频播放器 link Foobar2000 音乐播放器 Ditto 剪贴版加强 Atom Google出品编辑器 hexo 博客 Everything 搜索 Firefox 浏览器（奔跑的奶牛）  书签同步 XMarks   多台电脑共用一套鼠标键盘+直接拖拽分享文件ShareMouse  Markdown  链接 markdown语法说明 整段引用\u0026gt; 代码段引用  1 2 3 4 5  public static void GetSum() { int a,b,sum; sum=a+b; }    表格    First Header Second Header     Content Cell Content Cell   Content Cell Content Cell   1 2   - -   1 2     Latex公式   $$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}. $$\n  flowchart  浏览器插件  鼠标手势 CLEAN crxMouse Gestures vim模式操作  Vimium github增强树结构 octotree 惠惠购物助手 自定义显示样式 stylish 网站 插件管理 Tampermonkey (油猴) 搜索脚本 会员破解  shell  Ctrl-R查找历史命令 Ctrl-W删除最后一个单词 Ctrl-U删除一行 Alt-. 把上一次命令的最后一个参数打出来 Alt-* 列出你可以输入的命令 cd - 回到上一次工作目录 awk、sed、grep、xargs、find、sort  link  FindHao v2ex Hosts修改翻墙  ","description":"","id":53,"section":"it","tags":null,"title":"other","uri":"http://austinzgx.github.io/it/other/"},{"content":"工艺流程  设备连接图\n  主要生产企业    序号 企业名称 设计规模(kT/a) 投产日期 备　注     1 豫光金铅I 50 2002.7 SKS+ RSKS   2 池州科威 30 2002.8 SKS+BF   3 水 口 山 100 2005.8 SKS+侧吹   4 豫光金铅II 80 2005.3 SKS+ RSKS   5 灵宝新凌 80 2006.9 SKS+侧吹   6 济源金利 I 80 2007.10 SKS+侧吹   7 河南万洋 80 2008.3 SKS+侧吹   8 湖南宇腾 80 2008 SKS+侧吹   9 陕西汉中 80 2008 SKS+侧吹\t在建   10 江西金德 80 2008 SKS+侧吹   11 内蒙兴安 80 2009 SKS+侧吹   12 豫光金铅III 80 2009 SKS+RSKS\t新建   13 内蒙瑞峰 80 2010 SKS+ RSKS   14 郴州金贵 80 2010 SKS+侧吹   15 辽宁海城 80 2010 SKS+侧吹   16 灵宝志成 80 2010 SKS+侧吹   17 江西抚州 80 2010 SKS+侧吹\t在建   18 济源金利II 200 2010 SKS+侧吹\t新建   19 湖南桂阳银星 100 2011 SKS+侧吹   20 广西苍梧 60 2011 SKS+侧吹\t在建   21 安阳岷山 100 2011 SKS+RSKS\t新建   22 山东恒邦 100 2013 SKS+RSKS\t新建   23 湖南华信 100 2013 SKS+侧吹\t新建   24 青海豫源 100 2013.10 SKS+侧吹（万洋）   25 云南振兴 100 2014 SKS+RSKS\t新建   26 云南蒙自矿冶 80 2014 SKS+RSKS\t新建   27 内蒙赤峰山金 100 2014 SKS+RSKS\t新建   28 焦作东方 80 2010 SKS+RSKS   29 豫北金铅I 100 2011.9 SKS+侧吹（万洋）\t   30 豫北金铅II 100 2012.9 SKS+侧吹（万洋）\t   31 济源万洋II 100 2011.3 SKS+侧吹（万洋）\t   32 福建尤溪 100 2014.6 SKS+侧吹\t在建　   33 安徽铜陵 100 2014.6 SKS+侧吹\t在建　   34 长明公司 100 2014.10 SKS+侧吹（万洋）\t新建　   35 灵宝市志成铅业 100 2013.1 SKS+侧吹（金利）\t新建　   36 栾川石宝矿冶 80 2014.12 SKS+侧吹（金利）\t新建　   37 云南红铅 60 2014.6 SKS+侧吹（万洋）\t新建　    2016年国家科技进步二等奖  底吹熔炼—熔融还原—富氧挥发连续炼铅新技术及产业化应用 完成单位：中国恩菲工程技术有限公司、河南金利金铅有限公司、山东恒邦冶炼股份有限公司、济源市万洋冶炼(集团)有限公司、安阳市岷山有色金属有限责任公司、中南大学  项背景与研发思路 我国是金属铅生产和消费大国，铅产量占世界总产量40% 以上。铅、铅合金及其化合物广泛应用于蓄电池、船舶制造、射线防护等行业。\n铅冶炼的技术难点在于，铅物料具有高多元性、高挥发性、高渗透性和高毒性。国内和引进的铅冶炼技术存在环境污染重、能耗高、原料适应性差、过程不连续、生产成本高等诸多问题，曾几何时，因铅的污染，国人谈铅色变。\n开发环保节能、低成本、原料适应性强、过程连续的炼铅技术是世界冶金界面临的共同难题。\n2007年和2011年，国家两度将铅冶炼技术创新列为重大技术开发专项，由中国恩菲牵头，组织产学研联合攻关。\n在第一代底吹技术基础上，本项目着手在熔融还原和连续炼铅基础理论、关键技术及装备方面进行攻关，突破了高铅渣熔融还原基础理论，攻克了连续炼铅核心技术难题，发明了“底吹熔炼-熔融还原-富氧挥发”三连炉连续炼铅新技术，通过技术创新、装备创新、工程创新，建立了新技术生产线，逐步取代或淘汰了其他炼铅技术，实现了我国铅冶炼技术的全面升级。\n创新点及相关技术内容 本项目技术创新点主要集中在4个方面。\n  创新点1，首创发明了“底吹熔炼-熔融还原-富氧挥发”三连炉连续炼铅新技术\n针对国内外炼铅技术存在能耗高，原料适应性差、环境污染严重，过程不连续、安全隐患多等问题，本项目通过建立底吹炼铅过程元素分配模型，明确了多组元多相平衡规律，为复杂物料处理提供了理论支撑；\n首创发明熔融还原技术取代高污染高能耗的鼓风炉；开发富氧挥发炉替代传统烟化炉；\n研究突破了底吹熔炼-熔融还原-富氧挥发三个过程和三个装置之间物质流和能量流相互匹配的技术瓶颈，取消了电热前床，发明了三连炉短流程连续炼铅新技术；\n开发了冶炼过程控制平台，熔炼还原挥发3个过程有机连接，自动控制。\n新技术吨粗铅综合能耗由第一代底吹技术的380kg标煤降至180kg标煤，降低了52%；\n生产操作岗位Pb尘 \u0026lt;0.03 mg/m3，SO2 \u0026lt;5mg/m3 ，低于世界各国标准；\n铅回收率\u0026gt;98.5%，比第一代技术提高1.5个百分点；金银回收率\u0026gt;98%，提高2%;\n新技术大幅降低了炼铅生产成本，有效解决了铅冶炼环境污染，消除了铅生产安全隐患。\n  创新点2，首创发明了含铅物料熔融还原新技术。\n针对鼓风炉还原污染重、能耗高、劳动强度大，其他还原技术同样存在能耗高、生产成本高等问题，本项目通过对熔融状态下还原过程多相平衡、炉内多场模拟耦合作用规律分析，揭示了熔融高铅渣直接还原机理。\n首创发明了侧吹熔融还原新技术，并于2009年9月投入商业运行；\n首创发明了粉煤底吹熔融还原新技术，并于2011年11月投入商业运行。\n和鼓风炉还原技术相比，熔融还原新技术有效利用了液态高铅渣的热焓，采用廉价的还原剂替代了昂贵的冶金焦；采用富氧熔融还原替代了空气气固还原；还原强度大大提高，燃料消耗量大幅降低，烟气排放量成倍减少。\n熔融还原技术一举攻克了铅清洁高效低成本还原技术难题，淘汰了历史悠久的鼓风炉。从对比表中可以看出，和鼓风炉还原相比，能耗降低58%，减排SO266%，减排CO250%。\n  创新点3，首创开发了铅冶炼高锌渣富氧连续挥发新技术及装备。\n针对传统烟化炉采用空气熔炼，能耗高，炉寿短，间断作业等问题，本项目根据创新点2揭示的熔融还原技术原理，创新开发了富氧侧吹挥发新技术及装备。新装备创新了炉体结构，实现了连续作业；开发新型喷枪，大幅提高了富氧浓度和吹炼强度，节能减排效果显著。\n和烟化炉相比，富氧连续挥发技术能耗降低20%，同时提高了铅、锌回收率，进一步节省了铅冶炼生产成本。\n  创新点4，首创开发了世界上单系列产能最大的年产20万吨粗铅的现代炼铅装备。\n针对国内外铅冶炼生产装置普遍存在产能规模小、生产率低等问题，本项目通过建立氧气底吹炉内多场耦合模型，明确了炉体应力场及熔体温度场、速度场耦合作用行为规律，继而通过工程创新，突破了设备大型化的技术瓶颈，开发了世界上单系列产能最大的20万吨底吹炼铅装备并于2011年4月实现工业应用。 与单系列10万吨炼铅装置相比，耐火材料消耗减少40%，生产率成倍提高，促进了产业集中度，进一步提高了环保、社会及经济效益。\n  本技术与国内外同类技术的对比。\n本技术实现了低碳、清洁生产及资源高效循环利用。从对比表中可以看出，本技术在综合能耗、综合回收率、生产成本、建设投资等各项技术经济指标均优于国内外同类技术。\n我国铅锌冶炼龙头企业株洲冶炼厂和韶关冶炼厂、曲靖冶炼厂曾分别从国外引进了Kivcet、ISP、ISA等炼铅技术，生产中由于技术、经济、环保等原因，现决定改用本技术进行绿色升级改造。\n我国最大的铅冶炼企业豫光金铅采用的炼铅工艺流程长，过程不连续，单系列产能低，现决定采用本技术进行升级改造。\n事实胜于雄辩。铅冶炼企业的市场选择充分证明了本技术比国内外同类技术更先进。\n  应用推广和经济社会效益  本项目核心技术一经发明，迅速得到市场高度认可。在实体经济投资意愿普遍低迷的大环境下，短短5年内，国有和民营企业采用本项目核心技术共建设和升级改造了30条铅冶炼生产线，其产能占全国矿铅总产能比例达80%以上。另外还各有5条生产线在建和待建。 欧洲最大的铅锌企业Nyrstar公司旗下著名的澳大利亚皮里港铅厂采用本技术成功完成了搭配处理锌浸出渣的工业验证试验。 北美最大的铅锌企业墨西哥MMP公司铅冶炼厂决定采用本技术进行升级改造。 乌兹别克斯坦AMMC公司决定采用本技术建设铅厂。 美国最大的炼铅企业杜兰公司总裁一行专程到我国考察本技术，考虑采用本技术进行升级改造。 项目主要完成单位中的4家铅冶炼企业近3年应用本技术累计生产粗铅190万吨、金20吨、白银4700吨，新增销售额416亿元，新增利润6亿元。 本技术成功解决了复杂铅原料和锌浸出渣、提金尾渣、废电子铅玻璃、废铅蓄电池、炼铜铅锌烟灰、高炉炼铁铅锌烟尘等二次铅资源高效、经济回收，同时有效解决了这些含铅物料堆放带来的二次污染问题，实现了铅循环经济、清洁生产。 应用本技术，我国铅冶炼行业全面实现了技术升级。与第一代底吹技术相比，吨粗铅综合能耗由380kg标煤降至180kg标煤，能耗降低52%，减排CO2 52%,减排SO256%。近三年共节省标煤146万吨、减排CO2 336万吨、减排SO2 3.23万吨。为我国冶金行业的节能减排做出了应有的贡献。 本\t术的发明，开启了我国重有色冶金技术走向世界新纪元，引领了世界铅冶金技术发展。  侧吹浸没燃烧熔池熔炼技术(SSC) 熔池熔炼技术一般包括以下三种：\n 底吹熔炼技术 （SKS） 顶吹熔炼技术（ISA/Ausmelt)\n 侧吹熔炼技术\n  侧吹浸没燃烧熔池熔炼技术（Side-Submerged Combustion Smelting Process，SSC技术）是由中国恩菲工程技术有限公司联合合作伙伴开发的具有自主知识产权的一种强化熔池熔炼技术。该技术最初应用于处理液态高铅渣，并于2009年工业化应用成功，同年荣获中国有色金属工业科技一等奖。\n2010年开始，该技术推广到再生铅回收领域，随着在生产过程中的不断完善和改进，SSC技术已经发展为较成熟的一种先进熔池熔炼技术，当前正逐步推进其在锌、铅、锑、锡、铜等金属的氧化矿、红土矿和二次物料处理领域的应用。\n工艺原理 以多通道侧吹喷枪以高速向熔池内喷入富氧空气和燃料（天然气、发生炉煤气、焦炉煤气、粉煤）以激烈搅动熔体和直接燃烧向熔体补热为特征。\n炉料加入熔池后，物料随熔体的搅动快速散布于熔体之中，与周围熔体发生快速传热传质，进行炉料的加热、熔化、分解等过程。同时，侧吹喷枪喷入燃料又为物料提供热源。因此，侧吹浸没熔池熔炼是一个较理想的热技术系统。\n侧吹炉 关键技术   喷枪与燃料\n侧吹喷枪为多通道、多层套管浸没高速喷枪，根据火焰传播原理，当喷枪燃料传播速度大于火焰传播速度会形成脱火现象，当喷枪燃料传播速度小于火焰传播速度会形成回火现象，无论是脱火、回火都会对喷枪、炉衬寿命带来不利影响，喷枪流速至关重要。控制喷枪流速关键是控制喷枪燃料供应压力。\n  喷枪布置方式\n侧吹浸没燃烧熔池熔炼炉喷枪布置采用对吹方式，可有效减缓喷枪对对面侧墙的冲刷，选择合理喷枪流速和工作压力，喷枪寿命可达半年以上。侧吹浸没燃烧熔池熔炼炉免去了频繁的更换风口或喷枪操作，自动化操作水平得以提高，减轻工人劳动强度。\n  炉墙结构及炉缸\n侧吹浸没燃烧熔池熔炼炉是一种强化熔炼设备，冶炼过程中，温度可达1100-1550℃。使用单一的耐火砖抵抗不了高温流体的冲刷与腐蚀。对侧墙耐火材料必须采取冷却措施，这对高冶炼强度的现代冶炼炉尤为重要。耐火材料及其冷却成为能否采用高富氧浓度、高投料量、和高温度操作的关键。\n熔池内与熔渣接触的耐火材料受到熔渣的持续侵蚀，直到耐火材料由于冷却而使其表面结成一层固体渣壳为止。此后，这一层渣壳就起到了保护耐火砖和铜水套的作用。实际生产中，最重要的是被冷却耐火砖受熔体侵蚀后的残余厚度，在炉子运行后期，该砖层的厚度还有100mm，形成稳定挂渣，并一直稳定在此，不再腐蚀。\n  炉体框架结构\n炉子的钢结构采用先进成熟的“约束构架”，避免了刚性约束结构无法自由膨胀的缺点。采用约束构架对炉体整体稳定性至关重要，同时对炉体冷却效果也有着影响。侧吹浸没燃烧熔池熔炼炉采用整体“约束构架”结构，保持炉体钢板整体膨胀均匀，可有效防止熔池熔炼时的炉体位移与晃动。\n  炉体安全运行监控系统\n在炉底、铜水套表面，以及炉墙砖内部平均分布设置有若干温度测点。铜水套进出水管均设有流量检测和温度检测，对炉体进行实时检测，检测信号均进DCS控制系统。\n  余热锅炉\n余热锅炉根据处理不同的物料，按不同运行压力及出口温度进行设计。蒸汽需要余热发电时，则配套余热锅炉以主产蒸汽为主，锅炉设有垂直段和水平辐射段，锅炉出口控制在280-360℃；烟气量小不作发电之用，余热锅炉可只设计垂直段以节约投资，烟气出口控制在600℃，后接喷淋冷却器及布袋收尘器。\n  技术特点   富氧浓度高、热利用率高\n侧吹浸没燃烧熔池熔炼工艺采用富氧熔炼，燃料及助燃气体喷入熔池内，在熔池内燃烧，搅拌强度大，传质传热快，热利用率高，单位容积热强度大。熔炼炉产生的高温烟气通过余热锅炉回收余热，产生的蒸汽可进行发电和送到其它蒸汽用点，余热得到充分利用。\n该炉与其它采用铜水套直接挂渣的侧吹还原炉相比，具有保温效果好、炉子热损失低的优点.\n  作业率高\n侧吹浸没燃烧熔池熔炼炉炉墙为二层结构形式。从内到外为耐火砖、铜水套。耐火材料起隔热作用，减少炉子的热损失。而外层铜水套在炉墙上形成了一个冷却强度很大的冷却层，使得炉墙耐火材料始终在低温下工作。铜水套和内衬砖的结构有利于冷却和挂渣，大大延长了炉子寿命。炉底为耐火砖，抗渣和金属侵蚀能力强，炉子整体大修周期两年以上。\n  安全性好\n炉墙采用二层结构形式，内层为耐火砖砌体，外层为铜水套镶嵌耐火砖，镶嵌的耐火砖有效保护了铜水套，从而确保了炉体安全，炉体不易发生火焰泄露着火。\n  喷枪寿命长\n喷枪结构和布置的优化，提高了熔池搅动效率和反应速率，提高了气体的燃烧效率。喷枪使用寿命达6个月以上。免去了频繁风口人工封堵操作及喷枪更换操作，提高了作业率，实现了生产自动化和改善生产劳动环境。\n  原料适应性广，炉料备料系统简单\n侧吹浸没燃烧熔池熔炼炉采用铜水套内衬耐火砖结构，燃料和富氧空气直接喷入熔池内，能够适应对各种物料的处理，而且备料系统简单，各种物料可以直接入炉\n  有价金属综合回收率高、冶炼弃渣无害化\n该工艺独特的炉体结构，使的炉内各熔池相分离效率高。金属相位于喷枪下层，基本处于静止层，对金属熔体和液态渣两相澄清效果非常好，可通过金属层的高度来调节分离效果。生产厂指标表明，侧吹浸没燃烧熔池熔炼炉排出弃渣含铅低于1.5%，属于一般固体废物，可直接作为建筑材料。\n  再生铅处理工艺  主要技术经济指标     № 名称 单位 计算值      加料熔化过程 　    1 铅膏处理量 t/a 70000   2 铅栅处理量 t/a 30000   3 侧吹炉面积 m2 15   4 FeO/SiO2 % 1.39   5 CaO/SiO2 % 0.50   6 富氧空气 Nm3/h 4961   7 富氧浓度 % 50   8 粉煤量 t/h 1.90   9 碎煤量 t/h 0.83   10 煤率 % 16.03   11 粉煤率 % 11.28   12 块煤率 % 4.75   13 烧渣率 % 3.91   14 石灰石率 % 2.08   15 熔炼烟尘率 % 15.00   16 总烟尘率 % 18.53   17 熔炼渣含Pb % 48.00   18 炉渣量 t/batch 39.26   19 粗铅量 t/batch 107.65   20 混合渣含Pb % 22.23    还原过程　 　    1 氧化渣量 t/batch 39.26   2 FeO/SiO2 % 1.32   3 CaO/SiO2 % 0.47   4 富氧空气 Nm3/h 3600   5 富氧浓度 % 31.29   6 粉煤量 t/h 1.11   7 碎煤量 t/h 0.42   8 煤率 % 5.83   9 粉煤率 % 4.24   10 碎煤率 % 1.59   11 烟尘率 % 10.00   12 炉渣含Pb % 2.00   13 粗铅量 t/batch 14.28   14 还原炉渣量 t/batch 18.25    氧气底吹熔炼-底吹熔融电热还原炼铅工艺低碳技术创新和产业化实施方案 专项行业背景   我国铅冶炼技术正在向节能环保方向转变\n上世纪，我国炼铅工业存在整体工艺装备水平落后、生产集中度低、清洁生产急待加强等问题。根据有关的统计资料，中国铅冶炼企业均采用传统的烧结—鼓风炉工艺。大型铅冶炼厂烧结过程采用的设备为烧结机，而数量众多的中小型铅厂采用的是更为简陋的烧结锅烧结。由于烧结过程产出的烟气含S02仅2～3%，难以制酸而直接排入大气。同时烧结过程由于烧结工艺的需要，大量返粉（含铅物料）的破碎造成了铅尘的飞扬，引起了操作岗位及周边环境铅尘严重超过国家卫生标准，导致职业病铅中毒頻頻发生。在有色冶金工业中铅冶炼的污染一直难以解决，它不但危及着从事铅冶炼的操作工人的健康，也对环境造成了严重的危害。多年来，在原国家计委、国家科技部等有关部门的大力支持下，2002年“氧气底吹熔炼-鼓风炉还原炼铅法”产业化试验获得成功，为彻底解决这一问题提供了技术支撑。\n氧气底吹熔炼—鼓风炉还原炼铅法是中国有色工程设计研究总院和水口山有色金属公司联合开发的具有国际先进水平的炼铅技术，该工艺获得了国家科技进步二等奖和中国有色金属工业科技进步一等奖。应用该技术已有13个铅冶炼厂建成投产，还有15个冶炼厂处在施工建设阶段，另有6个厂家在设计中，这34个厂全部投产后，我国铅冶炼的污染状况将会根本改善。\n  氧气底吹熔炼—鼓风炉还原炼铅工艺技术的特点\n分析传统炼铅工艺，污染问题集中在烧结，氧气底吹熔炼—鼓风炉还原炼铅工艺采用氧气底吹熔炼取代烧结过程，解决了环保问题。由于富铅渣含硫（≤0.5%）远低于烧结块(含硫≥1.5%),鼓风炉还原富铅渣块,不仅烟尘率低且烟气S02含量远低于烧结块熔炼,因此,烟气仅通过除尘后就达标直接排放。\n氧气底吹熔炼—鼓风炉还原炼铅工艺技术利用氧气底吹炉氧化，替代烧结工艺，有效解决了烧结过程中S02烟气和铅尘严重污染环境的问题。从采用该技术的工厂运行的情况看，该工艺具有许多优点：投资省，综合能耗低，环保好，金属回收率高，生产成本比传统工艺低，并低于国外新工艺。用其改造传统铅冶炼产业，能充分利用原有设施，投资更省，效益更佳，因此推广应用及其迅速。\n  氧气底吹熔炼—鼓风炉还原炼铅工艺技术的缺点\n氧气底吹熔炼—鼓风炉还原炼铅工艺技术立足于改善传统炼铅工艺的环境治理，氧气底吹熔炼脱硫率高，烟气SO2浓度高，适于双转双吸制酸，尾气达到国家排放标准，同时取消了烧结工艺及返料破碎筛分系统，显著减少了污染源，改善了环境。\n但底吹炉产出的高铅渣需要用铸渣机冷却铸块，再送入鼓风炉中用焦炭还原。这样，一方面损失了高铅渣的物理热(约占鼓风炉能耗的15%)，另外鼓风炉送风要白白燃烧掉部分焦炭，致使鼓风炉焦率达13%～17%。2004年全国平均鼓风炉产吨铅焦耗达437kg，近期焦炭价格突升，使鼓风炉熔炼成本有所增加。且铸渣机和鼓风炉备料系统及炉顶，均存在粉尘的逸散源，需要完备的卫生除尘系统，为此需要进一步持续技术开发工作。\n2007年液态高铅渣直接还原技术开发被确定为国家“十二五”重大产业技术开发项目，国家拨付专项资金予以支持。\n  专项总体思路及主要内容  替代传统鼓风炉还原\n鼓风炉操作已经有一百多年的历史，工艺畅通，技术可靠，操作简单。鼓风炉炉内有很好的温度梯度，烟气直接预热炉料，出炉烟气温度低，烟尘率低，热利用率好。\n但鼓风炉实际生产中还存在以下一些问题：  (1)提升炉门加料时，烟气外溢严重； (2)炉结严重，作业率降低； (3)捅风眼作业，工人劳动强度大； (4)工艺流程长，备料及上料系统较为复杂。    底吹电热还原炉是替代传统鼓风炉的理想工艺选择，原因如下：\n* (1)利用了高铅渣的熔融潜热，避免了二次熔化带来的燃料消耗，同时可实现无焦冶炼，低碳效果显著，节能效果显著；\n* (2)炉体密封性好，加料口无烟气外逸，操作环境好；\n* (3)无捅风眼作业，工人劳动强度低；\n* (4)渣含铅低，冶炼回收率高；\n* (5)环保效益好，SO2排放量明显减少；\n* (6)炉寿长，作业率高；\n* (7)经济效益好，生产成本明显降低；\n* (8)有价金属(Ag、Au、Cu、Sb、Bi)回收率高；\n* (9)缩短工艺流程，减少污染源；\n* (10)取消了铸渣机，减小占地面积，节省设备及土地投资。\n  新工艺流程及特点\n氧气底吹炉产出的高铅渣，熔融状态下通过溜槽加入到底吹电热还原炉中，配以石灰石为熔剂造渣，粉煤为还原剂，不需昂贵的冶金焦，产出粗铅和还原终渣。高温烟气通过余热锅炉回收余热，表面冷却器降温，布袋收尘器收尘后，是否经尾气处理，视煤质含硫而定。\n石墨电极装置提供还原反应所需热量，粉煤仅用于氧化铅还原，减少燃料消耗，同时采用工业氧熔炼，达到减少烟气量及减小烟尘率的目的，从而减小后续烟气处理系统以及提高铅直收率。\n  底吹电热还原炉结构特点\n底吹电热还原炉是由中国恩菲工程技术有限公司自主开发的创新设备，具有如下特点：\n  (1)底吹电热还原炉分为炉体、石墨电极装置和粉煤喷枪三大部分。\n  (2)炉体包括传动装置、炉壳、耐火炉衬、固定端托轮及滚圈、滑动端托轮及滚圈、进渣口装置、冷料口装置、出渣口装置、出烟口装置、转角控制装置、主副油枪等部件。\n  (3)炉体为筒形卧式结构，环形耐火材料砌筑形式有利于提高炉寿；炉壳采用轧制钢板卷制拼焊而成，端盖采用碟形封头结构。\n  (4)托轮采用滚动轴承结构，降低了电机的功率。\n  (5)还原炉底部砖体加厚并形成缓坡，这样有利于还原过程中粗铅的沉降和凝聚，提高了还原效率。\n  (6)电极孔密封装置的设计兼顾了炉体对密封、绝缘和绝磁的三项要求。\n  专项的研发和产业化目标  (1)成功应用液态铅氧化渣直接还原技术及装置，达到降低工艺生产能耗、减少生产环节和节省建设投资，更进一步改善铅冶炼生产环境等目的； (2)新工艺要达到的主要技术指标是：粗铅单位产品综合能耗由氧气底吹熔炼-鼓风炉还原的380kgbm/t粗铅降至280kgbm/t粗铅； (3)粗铅冶炼回收率98.5%； (4)整体技术与装备水平达到国际领先水平，具备完全自主知识产权； (5)取得1～3项核心专利技术。  专项产业化示范工程 新工艺应用于河南安阳岷山有色金属有限责任公司富氧底吹强化熔炼节能技改项目。该项目经河南省安阳市发改委批复立项，生产规模为10万t/a电铅。\n项目生产指标要求：铅冶炼综合能耗为420kgbm/t电铅，铅冶炼回收率为97.5%，总硫利用率为96.5%，循环水利用率为96%，电铅直流电耗\u0026lt;110kWh/t电铅。\n环境评价报告通过河南省环境保护局审批，文件号：豫环审[2008]227号，项目污染物排放总量控制要求：SO2150t。目前该项目正在建设中，预计2010年10月份投产。\n节能减排效果及预期经济效益 氧气底吹熔炼-底吹电热还原炼铅法将粗铅综合能耗降至280kgbm/t-Pb，较传统烧结工艺综合能耗(630kgbm/t-Pb)降低约56%；较氧气底吹熔炼-鼓风炉还原炼铅工艺综合能耗(380kgbm/t-Pb)降低约26%。按照10万t/a粗铅生产规模计算，较烧结工艺每年可减少80500t二氧化碳排放，较氧气底吹熔炼-鼓风炉还原炼铅工艺每年可减少23000t二氧化碳排放。采用余热锅炉回收余热，如扣除余热发电，新工艺粗铅综合能耗进一步降低为240kgbm/t-Pb，是迄今为止能耗最低的炼铅工艺。同时，按照10万t/a粗铅规模计算，较烧结工艺每年可节约3.5万t标准煤，较氧气底吹熔炼-鼓风炉还原炼铅工艺每年可节约1万t标准煤，标煤每吨按1000元计，折合经济效益分别为3500万元、1000万元。\n产业化推广目标及社会效益 新工艺可广泛应用于国内铅冶炼新建和技改项目，包括已采用氧气底吹熔炼—鼓风炉还原炼铅法铅冶炼厂进一步的技术革新和采用传统工艺铅冶炼厂的技术改造，项目市场潜力大。另外，依靠中国恩菲工程技术有限公司的技术和价格优势，可以广泛开拓国外铅冶炼技术市场。\n新工艺不使用昂贵的冶金焦，可实现无焦冶炼，粗铅单位生产成本大幅度下降，经济效益显著。\n新工艺达到了节能减排、低碳创新、资源高效利用的目标，符合国家产业政策，具有充分的技术经济和社会效益，对我国铅冶炼行业可持续发展具有重要意义。\n项目依托单位情况 安阳岷山有色金属有限责任公司始建于1992年，是一家集矿山开发、冶炼、综合回收、产品销售开发为一体综合经营有色金属的民营企业，是国家发改委循环经济、清洁生产试点企业，河南省产业结构调整重点支持企业，年产值8亿元。\n投资估算 本项目投资估算不包括烟化炉系统、铅电解精炼系统及综合回收系统等.\n   项目 建筑工程 设备 安装费用 其他 总投资估算     投资(万元) 5000 12000 2000 3000 22000   占投资比例 22.73% 54.55% 9.09% 13.63% 100%    济源金利侧吹熔融还原炉炼铅工艺试生产报告 济源市金利有限责任公司和中国恩菲工程技术有限公司合作开发的侧吹熔融还原炉已完成前期准备工作，经过两次试验改造后，在第三次试车成功后，已平稳运行了153天，并取得了良好的技术经济指标，本文对试生产情况进行了总结。\n工艺 济源市金利有限责任公司铅冶炼工艺流程见图1。\n侧吹熔融还原炉于2009年9月1日，正式投料试生产，截止2010年1月31日24:00，平稳运行了153天，入炉的高铅渣量55080吨、石灰石1469吨、煤气4039200m3、氧气1836000 m3、无烟煤粒2387吨。\n金利炉冶炼回收率 试生产的153天，投入的高铅渣平均品位45%，含铅量24786吨；产粗铅23373.33吨；粗铅品位96.5%，含铅量22555.26吨；产出31665.13吨熔炼渣，渣含铅平均1.8%，含铅量569.97吨；产出烟尘3216.91吨，平均品位47%，含铅量1511.95吨。铅平衡表见表1。\n表1 侧吹熔融还原炉铅平衡表\n   投 入  产 出            高铅渣  粗铅  熔炼渣  烟尘  合计    数量/t 铅品位% 数量/t 铅品位% 数量/t 铅品位% 数量/t 铅品位%     55080 45.00 23373.33 96.50 31665.13 1.80 3216.91 47.00     金属量/t 百分比% 金属量/t 百分比% 金属量/t 百分比% 金属量/t 百分比% 金属量/t 百分比%   24786 100.00 22555.26 91.00 569.97 2.30 1511.95 6.10 24635.78 99.40     1、损失损的铅量有148.82t，占总量的0.6%，为铅挥发损失以及管理损失和误差。 2、根据以上统计，侧吹熔融还原炉铅回收率为97.10%，还原炉直收率为91.00%。  回收率和直收率 试生产期间渣含铅见表2。\n表2 侧吹熔融还原炉渣含铅统计\n   时间 高铅渣品位 还原炉渣含铅     9月1日—9月30日 44.25 1.92   10月1日—10月31日 45.73 1.63   11月1日—11月30日 45.21 1.80   12月1日—12月31日 44.82 2.05   1月1日—1月31日 44.99 1.60   平均值 45 1.80     侧吹熔融还原炉平均烟尘率为5.84%，原有与底吹炉配套的鼓风炉烟尘率为6%左右，和侧吹熔融还原炉相近； 侧吹熔融还原炉渣含铅1.8%，鼓风炉渣含铅平均在2.9%； 侧吹熔融还原炉熔剂率为2.67%，远低于原有鼓风炉的15.32%（2009年平均值）； 三项指标较鼓风炉都有所提高，即回收率、直收率和熔剂率都比鼓风炉先进，目前国内的高铅渣鼓风炉回收率和直收率一般为95%和88%，熔剂率不低于10%。  能耗  煤耗\n试验的153天中，侧吹熔融还原炉共消耗无烟煤粒2387.0吨，焦炉煤气4039200m3，焦炉煤气的发热量平均为16750kJ/m3,折标系数为0.5714 kgce /m3，无烟煤的发热量按25100kJ/kg，折标系数为0.9000 kgce/kg，则消耗的无烟煤粒和煤气折合标煤4456.3吨，得出吨铅平均煤耗为197.57kgce/t—Pb,较鼓风炉的吨铅焦耗380kg，折合标准煤369.13 kgce/t—Pb的指标有大幅度的降低。 电耗\n153天中侧吹熔融还原炉耗电为567465.5kWh，折合吨铅耗电为25.16 kWh，较鼓风炉的吨铅耗电65.12kWh有大幅度的降低。 氧耗\n153天中侧吹熔融还原炉耗氧为1836000 m3，折合吨铅耗氧为81.40 m3，较鼓风炉的75.54 m3略有增加。\n电的折标系数按0.1229 kgce/ kWh，氧气的折标系数按0.400 kgce/ m3，综合计算，侧吹熔融还原炉吨铅能耗为233.22 kgce/t—Pb，远低于原有鼓风炉的402.92 kgce/t—Pb。  经济效益 侧吹熔融还原炉和原有鼓风炉成本对比情况见表3。侧吹熔融还原炉吨铅成本较鼓风炉明显下降。\n表3 侧吹熔融还原炉和鼓风炉粗铅加工成本对比表\n   编号 子编号 项目 侧吹熔融还原炉   鼓风炉          吨铅消耗 单位价格 吨铅成本 吨铅消耗 单位价格 吨铅成本   1 辅助材料           1.1 石灰石 0.065 22 1.43 0.167 22 3.67    1.2 铁矿石    0.120 220 26.40    1.3 耐火材料 0.008 100 0.80 0.006 100 0.60   2 燃料           2.1 焦炭    380 1.65 627    2.2 无烟煤粒 105.83 0.85 89.96       2.3 焦炉煤气 179.08 0.60 107.45      3 水电动力           3.1 电力 25.16 0.56 14.09 65.12 0.56 36.47    3.2 水 5.2 1.3 6.76 5.2 1.3 6.76    3.3 氧气 81.40 0.53 40.7 75.54 0.53 40.04   4 工资福利    39.55   45.48   5 折旧维修           5.1 折旧费   61.25   17.25    5.2 维修费   110.22   33.48   合计     482.19   837.15    环保效益 侧吹熔融还原炉吨铅消耗焦炉煤气179.08 m3，煤气CO2产生量为63.76g/m3, SO2含量为300mg/m3；无烟煤粒105.83kg，无烟煤CO2产生量为2.57kg/kg无烟煤SO2产生量为8g/kg，合计吨铅产出CO2283.40kg，SO274.28g；鼓风炉吨铅焦耗380kg，焦炭吨铅焦耗为380kg，焦炭CO2产生量为2.97kg/kg，SO2产生量为1.6g/kg，吨铅产出CO21128.60kg，SO2608.0g吨。侧吹熔融还原炉CO2 和SO2排放量均较原有鼓风炉明显减少。\n综合回收 生产实践证明，侧吹熔融还原炉渣含Cu为0.3-0.5%,渣含Sb为0.03-0.05%,渣含Bi小于0.1%，Cu、Sb、Bi回收率较原有鼓风炉提高10-20%。\n工艺特点 生产实践表明，侧吹熔融还原炉具有如下特点：\n ⑴侧吹熔融还原炉是侧吹熔池熔炼在铅冶炼领域的应用和发展，具有很高的实践推广价值。 ⑵设备全部国产化，拥有自主知识产权。 ⑶自动化程度高，整个过程实现DCS在线监控。 ⑷炉体密封性好，加料口无外溢烟气，操作环境好。 ⑸无打风口作业，工人劳动强度低。 ⑹冶炼回收率高，达97%以上，渣含铅1.5% - 2.0%，较鼓风炉好。 ⑺节能效果好，充分利用了高铅渣的熔融潜热，较鼓风炉明显节能。 ⑻环保效益好，CO2 和SO2排放量均较鼓风炉明显减少。 ⑼经济效果好，成本较鼓风炉明显降低。 ⑽渣量少，炉渣含锌高，有利于烟化炉的生产。 ⑾铜、锑、铋等伴生有价金属回收率高。  结束语 试生产实践证明，侧吹熔融还原炉各项经济技术指标均优于鼓风炉，具有回收率高、直收率高、熔剂率低、能耗低、成本低、操作简单、自动化程度高、环保效果好的特点。试生产期间，停炉时间较多，今后的生产会更加顺利，侧吹熔融还原炉的各项经济技术指标将更好。\n安阳岷山底吹熔炼-液态高铅渣底吹电热还原炼铅工艺产业化开发示范工程报告 项目背景  我国铅冶炼技术正在向节能环保方向转变\n上世纪，我国炼铅工业存在整体工艺装备水平落后、生产集中度低、清洁生产急待加强等问题。根据有关的统计资料，中国铅冶炼企业均采用传统的烧结—鼓风炉工艺。大型铅冶炼厂烧结过程采用的设备为烧结机，而数量众多的中小型铅厂采用的是更为简陋的烧结锅烧结。由于烧结过程产出的烟气含S02仅2～3%，难以制酸而直接排入大气。同时烧结过程由于烧结工艺的需要，大量返粉（含铅物料）的破碎造成了铅尘的飞扬，引起了操作岗位及周边环境铅尘严重超过国家卫生标准，导致职业病铅中毒頻頻发生。在有色冶金工业中铅冶炼的污染一直难以解决，它不但危及着从事铅冶炼的操作工人的健康，也对环境造成了严重的危害。多年来，在原国家计委、国家科技部等有关部门的大力支持下，2002年“氧气底吹熔炼-鼓风炉还原炼铅法”产业化试验获得成功，为彻底解决这一问题提供了技术支撑。\n氧气底吹熔炼—鼓风炉还原炼铅法是中国有色工程设计研究总院和水口山有色金属公司联合开发的具有国际先进水平的炼铅技术，该工艺获得了国家科技进步二等奖和中国有色金属工业科技进步一等奖。应用该技术已有11个铅冶炼厂建成投产，还有17个冶炼厂处在施工建设阶段，另有6个厂家在设计中，这34个厂全部投产后，我国铅冶炼的污染状况将会根本改善。 氧气底吹熔炼—鼓风炉还原炼铅工艺技术的特点\n分析传统炼铅工艺，污染问题集中在烧结，氧气底吹熔炼—鼓风炉还原炼铅工艺采用氧气底吹熔炼取代烧结过程，解决了环保问题。由于富铅渣含硫（≤0.5%）远低于烧结块(含硫≥1.5%),鼓风炉还原富铅渣块,不仅烟尘率低且烟气S02含量远低于烧结块熔炼,因此,烟气仅通过除尘后就达标直接排放。\n氧气底吹熔炼—鼓风炉还原炼铅工艺技术利用氧气底吹炉氧化，替代烧结工艺，有效解决了烧结过程中S02烟气和铅尘严重污染环境的问题。从采用该技术的工厂运行的情况看，该工艺具有许多优点：投资省，综合能耗低，环保好，金属回收率高，生产成本比传统工艺低，并低于国外新工艺。用其改造传统铅冶炼产业，能充分利用原有设施，投资更省，效益更佳，因此推广应用及其迅速。 氧气底吹熔炼—鼓风炉还原炼铅工艺技术的缺点\n氧气底吹熔炼—鼓风炉还原炼铅工艺技术立足于改善传统炼铅工艺的环境治理，氧气底吹熔炼脱硫率高，烟气SO2浓度高，适于双转双吸制酸，尾气达到国家排放标准，同时取消了烧结工艺及返料破碎筛分系统，显著减少了污染源，改善了环境。\n但底吹炉产出的高铅渣需要用铸渣机冷却铸块，再送入鼓风炉中用焦炭还原。这样，一方面损失了高铅渣的物理热(约占鼓风炉能耗的15%)，另外鼓风炉送风要白白燃烧掉部分焦炭，致使鼓风炉焦率达13%～17%。2004年全国平均鼓风炉产吨铅焦耗达437kg，近期焦炭价格突升，使鼓风炉熔炼成本有所增加。且铸渣机和鼓风炉备料系统及炉顶，均存在粉尘的逸散源，需要完备的卫生除尘系统，为此需要进一步持续技术开发工作。\n2007年液态高铅渣直接还原技术开发被确定为国家“十二五”重大产业技术开发项目，国家拨付专项资金予以支持。 与其他炼铅工艺的对比\n氧气底吹熔炼-底吹电热还原炼铅法在经济技术指标上达到或超过目前世界先进炼铅技术，实现综合指标的国际领先水平，与世界几种先进炼铅技术比较见下表。     项目 氧气底吹熔炼-底吹电热还原炼铅 氧气底吹熔炼-鼓风炉还原炼铅 KIVCET法 QSL法 顶吹熔炼法     规模 8-20万t/a粗铅 6-12万t/a粗铅 8-10万t/a粗铅 5-10万t/a粗铅 3-10万t/a粗铅   原料 铅精矿及铅二次物料 铅精矿及铅二次物料 铅精矿及铅二次物料 铅精矿及铅二次物料 铅精矿及铅二次物料   备料 简单，只需制粒 简单，只需制粒 精矿必需深度干燥 简单，只需制 粒\t简单，只需制粒   烟气浓度(S02) 8-10% 8-10% 15-20% 8-10% 6%   氧气 300-400m3/t-Pb 250-350m3/t-Pb 500-600m3/t-Pb 300-400m3/t-Pb 0-100m3/t-Pb   铅回收率 98.5% 97%-98% 98%(设计值) 97%-98%(设计值) 97%-98%   氧枪寿命 \u0026gt;6周 \u0026gt;6周  2-4周 3-4d   能耗 0.28t标煤/t粗铅 0.38t标煤/t粗铅 0.4t标煤/t粗铅 0.3t标煤/t粗铅 0.4t标煤/t粗铅   投资 1.9亿元-2.4亿元 2.0亿元-2.5亿元 6-7亿元 3.5-4.0亿元 3.0-3.5亿元   环境条件 良好、消除了SO2和铅尘污染 良好、消除了SO2和铅尘污染 良好、消除了SO2和铅尘污染 良好、消除了SO2和铅尘污染 良好、消除了SO2和铅尘污染    附注：Kivcet和QSL法铅回收率是有关工厂的设计指标，但实际生产渣含Pb5～7%，如按实际渣含铅数据计算，熔炼回收率与设计值差异较大。\n研发和产业化内容   替代传统鼓风炉还原\n鼓风炉操作已经有一百多年的历史，工艺畅通，技术可靠，操作简单。鼓风炉炉内有很好的温度梯度，烟气直接预热炉料，出炉烟气温度低，烟尘率低，热利用率好。\n但鼓风炉实际生产中还存在以下一些问题：\n (1)提升炉门加料时，烟气外溢严重； (2)炉结严重，作业率降低； (3)捅风眼作业，工人劳动强度大； (4)工艺流程长，备料及上料系统较为复杂。  底吹电热还原炉是替代传统鼓风炉的理想工艺选择，原因如下：\n (1)利用了高铅渣的熔融潜热，避免了二次熔化带来的燃料消耗，同时可实现无焦冶炼，低碳效果显著，节能效果显著； (2)炉体密封性好，加料口无烟气外逸，操作环境好； (3)无捅风眼作业，工人劳动强度低； (4)渣含铅低，冶炼回收率高； (5)环保效益好，SO2排放量明显减少； (6)炉寿长，作业率高； (7)经济效益好，生产成本明显降低； (8)有价金属(Ag、Au、Cu、Sb、Bi)回收率高； (9)缩短工艺流程，减少污染源； (10)取消了铸渣机，减小占地面积，节省设备及土地投资。    新工艺流程及特点\n氧气底吹炉产出的高铅渣，熔融状态下通过溜槽加入到底吹电热还原炉中，配以石灰石为熔剂造渣，粉煤为还原剂，不需昂贵的冶金焦，产出粗铅和还原终渣。高温烟气通过余热锅炉回收余热，表面冷却器降温，布袋收尘器收尘后，是否经尾气处理，视煤质含硫而定。\n石墨电极装置提供还原反应所需热量，粉煤仅用于氧化铅还原，减少燃料消耗，同时采用工业氧熔炼，达到减少烟气量及减小烟尘率的目的，从而减小后续烟气处理系统以及提高铅直收率。\n  底吹电热还原炉结构特点\n底吹电热还原炉是由中国恩菲工程技术有限公司自主开发的创新设备，具有如下特点：\n(1)底吹电热还原炉分为炉体、石墨电极装置和粉煤喷枪三大部分。\n(2)炉体包括传动装置、炉壳、耐火炉衬、固定端托轮及滚圈、滑动端托轮及滚圈、进渣口装置、冷料口装置、出渣口装置、出烟口装置、转角控制装置、主副油枪等部件。\n(3)炉体为筒形卧式结构，环形耐火材料砌筑形式有利于提高炉寿；炉壳采用轧制钢板卷制拼焊而成，端盖采用碟形封头结构。\n(4)托轮采用滚动轴承结构，降低了电机的功率。\n(5)还原炉底部砖体加厚并形成缓坡，这样有利于还原过程中粗铅的沉降和凝聚，提高了还原效率。\n(6)电极孔密封装置的设计兼顾了炉体对密封、绝缘和绝磁的三项要求。\n  研发和产业化目标  (1)成功应用液态铅氧化渣直接还原技术及装置，达到降低工艺生产能耗、减少生产环节和节省建设投资，更进一步改善铅冶炼生产环境等目的； (2)新工艺要达到的主要技术指标是：粗铅单位产品综合能耗由氧气底吹熔炼-鼓风炉还原的380kgbm/t粗铅降至280kgbm/t粗铅； (3)粗铅冶炼回收率98.5%； (4)整体技术与装备水平达到国际领先水平，具备完全自主知识产权； (5)取得1～3项核心专利技术。  产业化示范工程 新工艺应用于河南安阳岷山有色金属有限责任公司富氧底吹强化熔炼节能技改项目。该项目经河南省安阳市发改委批复立项，生产规模为10万t/a电铅。\n项目生产指标要求：铅冶炼综合能耗为420kgbm/t电铅，铅冶炼回收率为97.5%，总硫利用率为96.5%，循环水利用率为96%，电铅直流电耗\u0026lt;110kWh/t电铅。\n环境评价报告通过河南省环境保护局审批，文件号：豫环审[2008]227号，项目污染物排放总量控制要求：SO2150t。目前该项目正在建设中，预计2010年10月份投产。\n节能减排效果 氧气底吹熔炼-底吹电热还原炼铅法将粗铅综合能耗降至280kgbm/t-Pb，较传统烧结工艺综合能耗(630kgbm/t-Pb)降低约56%；较氧气底吹熔炼-鼓风炉还原炼铅工艺综合能耗(380kgbm/t-Pb)降低约26%。按照10万t/a粗铅生产规模计算，较烧结工艺每年可减少80500t二氧化碳排放，较氧气底吹熔炼-鼓风炉还原炼铅工艺每年可减少23000t二氧化碳排放。采用余热锅炉回收余热，如扣除余热发电，新工艺粗铅综合能耗进一步降低为240kgbm/t-Pb，是迄今为止能耗最低的炼铅工艺。\n产业化推广目标和对行业低碳的贡献 新工艺可广泛应用于国内铅冶炼新建和技改项目，包括已采用氧气底吹熔炼—鼓风炉还原炼铅法铅冶炼厂进一步的技术革新和采用传统工艺铅冶炼厂的技术改造，项目市场潜力大。另外，依靠中国恩菲工程技术有限公司的技术和价格优势，可以广泛开拓国外铅冶炼技术市场。\n新工艺不使用昂贵的冶金焦，可实现无焦冶炼，粗铅单位生产成本大幅度下降，经济效益显著。\n新工艺达到了节能减排、低碳创新、资源高效利用的目标，符合国家产业政策，具有充分的技术经济和社会效益，对我国铅冶炼行业可持续发展具有重要意义。\n项目依托单位情况 安阳岷山有色金属有限责任公司始建于1992年，是一家集矿山开发、冶炼、综合回收、产品销售开发为一体综合经营有色金属的民营企业，是国家发改委循环经济、清洁生产试点企业，河南省产业结构调整重点支持企业，年产值8亿元。\n河南安阳岷山有色金属有限责任公司富氧底吹强化熔炼节能技改项目指标表\n     粗铅综合能耗 排放二氧化碳 排放二氧化硫     行业现状 2009年国内平均水平 460kgbm/t-Pb 1058kg/t-Pb     2009年国内先进水平 380kgbm/t-Pb 874kg/t-Pb     2008年国外先进水平 300kgbm/t-Pb 690kg/t-Pb    项目目标  240kgbm/t-Pb 552kg/t-Pb    预期效果  280kgbm/t-Pb 644kg/t-Pb    行业准入条件 粗铅综合能耗：≤400kgbm/t-Pb       ","description":"","id":54,"section":"metal","tags":null,"title":"Pb","uri":"http://austinzgx.github.io/metal/pb/"},{"content":"注释 IDE integrated Development Environment 集成开发环境\nC#编程 Microsoft Visual Studio\nMAC/IOS Xcode\npython Emacs VIM \u0026hellip;\n对象有类型，变量无类型。\n整数 int integer\n浮点数 float\ntype(object) 检测类型\n模块 Module\n库 library\nmath 是标准库，不用安装，可以直接使用\nimport math\nmath.pi\ndir(math) 查看math模块内容\ndir(module)是一个非常有用的指令，可以通过它查看任何模块中所包含的工具。\nhelp()是好帮手。\nUTF-8\n互联网催生了UTF-8。\nUnicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF）——UTF的含义。\nUTF-8是在互联网上使用最广的一种Unicode的实现方式。虽然它仅仅是Unicode的实现方式之一，但它真正一统江湖了\nUTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部份修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或发送文字的应用中，优先采用的编码。\n有UTF-8，言外之意还应该有UTF-n，n是一个别的数字。\n的确如此，还有UTF-16等等，但UTF-8有很多优点，被广泛接受。\n所以，以后，我们在Python的程序开发中，都要使用UTF-8编码。\n注：参考文献：字符编码笔记：ASCII，Unicode和UTF-8\n看完了一些关于编码的基本知识，再来看Python中的编码问题。\n列表：一个打了激素的数组\n[]\n.append() 添加元素\n.expend([])\n[]+[] 不规范，类型要求一致\n.insert()\n.remove()\ndel\n.pop()\n分片 slice\nScrapy  pip install scrapy (python3 中使用pip3 install scrapy) pip install pypiwin32  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import scrapy class StackOverflowSpider(scrapy.Spider): name=\u0026#34;stackoverflow\u0026#34; start_urls=[\u0026#34;http://stackoverflow.com/question?sort=votes\u0026#34;] def parse(self,response): for href in response.css(\u0026#39;.question-summary h3 a::attr(href)\u0026#39;): full_url = response.urljoin(herf.extract()) yield scrapy.Request(full_url,callback=self.parse_question) def parse_question(self,response): yield{ \u0026#39;title\u0026#39;:response.css(\u0026#39;h1 a::text\u0026#39;).extract()[0], \u0026#39;votes\u0026#39;:response.css(\u0026#34;.question .vote-count-post::text\u0026#34;).extract()[0], \u0026#39;body\u0026#39;:response.css(\u0026#34;.question .post-text\u0026#34;).extract()[0], \u0026#39;tags\u0026#39;:response.css(\u0026#34;.question .post-tag::text\u0026#34;).extract(), \u0026#39;link\u0026#39;:response.url, }   $ scrapy startporject somefile\n$ scrapy runspider somefile.py -o xx.csv\n 在somefile.py文件中找到已定义的爬虫，然后通过抓取引擎运行爬虫 具体抓取过程   使用start_urls作为初始url生成Request，并默认把parse作为它的回调函数 在parse中采用css选择器获得目标URL,并注册parse_question作为目标URL的回调函数。  背后的处理  请求被异步的调度、处理 有一些参数可以控制过程，比如每个域名/ip的并发请求数、请求之间的下载延迟（或者自动调节）  高级特性  内置的数据抽取器 css/xpath/re (scrapy shell)交互式控制台用于调试数据抽取方法 内置对结果输出的支持，可以保存为JSON csv xml等 自动处理编码 支持自定义扩展 丰富的内置扩展，可用于处理   cookies and session HTTP features like compression, authentication, caching user-agent spoofing robots.text crawl depth restriction  远程调试Scrpay 更多的支持，比如可爬去xml csv 可自动下载图片等等  安装步骤  安装python2.7 安装pip 包管理工具 安装lxml 安装OpenSSL 安装Scrapy  使用步骤  Creating a project  $ scrapy startporject xxx 目录结构  XXX/  scrapy.cfg XXX/  _init_.py items.py pipelines.py settings.py spiders/  _init_.py\n\u0026hellip;           Defining out Item (*) Writing a Spider   $ scrapy genspider somefile url\n 例如 $ scrapy genspider dmoz_spider dmoz.org    编辑 dmoz_spider.py\n1 2 3 4 5 6 7 8 9 10 11 12  # -*- coding: utf-8 -*- import scrapy class DmozSpiderSpider(scrapy.Spider): name = \u0026#34;dmoz_spider\u0026#34; allowed_domains = [\u0026#34;dmoz.org\u0026#34;] start_urls = [\u0026#39;http://dmoztools.net/Computers/Programming/Languages/C-sharp/Resources/\u0026#39;] def parse(self, response): filename= response.url.split(\u0026#39;/\u0026#39;)[-2] + \u0026#34;.html\u0026#34; with open(filename,\u0026#39;wb\u0026#39;) as fp: fp.write(response.body)      Writing \u0026amp; configure an Item Pipeline(*) Execute crawl  运行 scrapy crawl dmoz_spider 得到 Resources.html    scrapy 命令行工具  help 查看帮助  scrapy help   version 查看版本信息  scrapy version   startporject 新建一个工程  scrapy startporject xxx   genspider 创建spider  scrapy genspider aaa bbb.com 产生name=\u0026ldquo;aaa\u0026quot;的spider 爬取得网站为 bbb.com 在工程中产生一个spider; 可以产生多个spider,不同的spider要求name不同   list 查看工程中spider列表  scrapy list   view 查看页面源码在浏览器中显示的样子  scrapy view url   parse 在工程中使用固定的parse函数解析某个页面  scrapy parse url   shell 一个非常有用的命令，可用于调试数据、检测xpath、查看页面源码，等等  scrapy shell url 不需要一个具体的工程   runspider 运行自包含的爬虫  scrapy runspider xxx.py    数据类型  int bool str float  获得类型信息：  type() isinstance() 返回结果比较直接，建议使用  判断字符 s为字符串\n1 2 3 4 5 6 7  s.isalnum() #都是数字或者字母 s.isalpha() #都是字母 s.isdigit() #都是数字 s.islower() #都是小写 s.isupper() #都是大写 s.istitle() #所有单词都是首字母大写 s.isspace() #所有字符都是空白字符   操作符  幂运算 ** 正负号 -x +x 算数操作符 * / // + - 比较操作符 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= == != 逻辑运算符 not and or  例子 1 2 3 4 5 6 7 8 9 10 11 12 13  # -*- coding:utf-8 -*- temp=input(\u0026#39;请输入一个年份：\u0026#39;) while not temp.isdigit(): temp = input(\u0026#34;抱歉，输入有误，请输入一个整数：\u0026#34;) year = int(temp) if year/400 ==int(year/400): print(temp+\u0026#39;是闰年！\u0026#39;) else: if(year/4 == int(year/4)) and (year/100 !=int(year/100)): print(temp+\u0026#39;是闰年！\u0026#39;) else: print(temp+\u0026#39;不是闰年！\u0026#39;)   ","description":"","id":55,"section":"code","tags":null,"title":"python入门","uri":"http://austinzgx.github.io/code/python/python/"},{"content":"windows  Listary total commander AHK Everything 搜索  common  vim|neovim Emacs org-mode Potlayer WW 视频播放器 Foobar2000 音乐播放器 Ditto 剪贴版加强 hexo 博客 mkdocs 文档 Firefox/Chrome 浏览器（奔跑的奶牛）  书签同步 XMarks   鼠标手势 CLEAN crxMouse Gestures vim模式操作  Vimium github增强树结构 octotree 惠惠购物助手 自定义显示样式 stylish 网站 插件管理 Tampermonkey (油猴) 搜索脚本    ","description":"","id":56,"section":"it","tags":null,"title":"soft","uri":"http://austinzgx.github.io/it/soft/"},{"content":" luliyu 10 liukai 5 liaolianhui 1 chenxuegang 2 mamingsheng 2 peizhongye 2 wujincai 2 chengxiangqiang 2 [ ] jiuma 10 xiaoyi 10 jia 8 guo 20 [ ] dajiu 50 jie 8  ","description":"","id":57,"section":"life","tags":null,"title":"帐本","uri":"http://austinzgx.github.io/life/%E5%B8%90%E6%9C%AC/"},{"content":"业务思考 1.抓住有色冶炼流程型制造的特点\n不同于机器加工业等离散型制造，生产工艺流程有序稳定、协同连续运行是流程制造业的追求方向。同时有色金属冶炼行业金属种类繁多,原料复杂多样；冶金工艺复杂、工况条件恶劣；装备种类多，生产规模不一；安环敏感源多、管控压力大。\n2.明确有色智能冶炼工厂的目标\n三个关键字概况“绿色、安全、高效”，由于有色行业的冶炼与加工分离，导致有色冶炼基本不需要依据市场订单来组织生产，这点上与同属流程型制造钢铁行业存在较大不同，即不存在“柔性生产”或“客制化生产”，有色冶炼企业只需在保证环保和安全的前提下，提高生产效率就意味着生产效益。 此外强制智能化不是目的，是实现绿色安全高效的生产的手段。\n3.打造绿色安全高效的冶炼工厂途径\n在保证工艺的先进性的基础条件上，可以从硬件与软件两个方面着手。\n硬件方面体现在新型一次检测仪表、先进装备以及智能成套装备上。恩菲应加强加速在智能软测量及成套装备上的研发与市场推广。\n软件方面体现在企业的三个方面:过程控制、生产管理及经验决策上。恩菲应发挥自身冶金专长技术的优势，抓住过程控制软件（工业控制软件）的开发与推广上，联合第三方成熟优质的互联网企业打造集成的数字化平台。\n4.总体架构与业务功能\n按照工信部的要求以及未来发展趋势，工业互联网是必然之趋势，但各种技术架构层出不穷，对比传统互联网的发展也是同样，基本是3年一个更新，从开始的企业服务总线ESD的SOA到现在火热的微服务，近来阿里又演化微服务的大中台理念。故此没有一个银弹的设计架构可以统括一切。只是在业务功能上分为了应用、服务及设施层，以及从层级结构上分为“端、边、云”。事实上，具体的架构设计及产品选型需要根据应用场景及业务规模来细化落地。比如说，工业互联网与传统互联网的很大不同点就是并发请求数量规模与稳定性，导致在代理服务器乃至数据库的选择都会存在较大差异。\n5.智能制造的核心与恩菲冶炼的优势\n关于工业4.0的定义和对世界各国战略的解读已有很多,也有许多专家学者和政府机构提出了一系列的实施路径和方案,我们看到政府相继提出了机器换人、智慧工厂、大数据、互联网+和工匠精神等一系列改革举措。然而,有不少人都表达过这样一种感受:我们越深入分析各个国家的政策,越是去尝试不同的转型路径,反而愈发地感觉迷茫和浮躁。我认为之所以会有这样的感受,是因为大家把智能制造当成了个技术问题来看待,因此在分析其他国家行动的时候也只是停留在表面的方法和技术上,却忽略了这些行动背后的思维和逻辑。于是当德国有“工业4.0”,我们就有了“中国制造2025”；美国提出“工业互联网”,我们也提出了“互联网+”；日本精益制造做得好,我们就要大力提倡工匠精神。事实上,智能制造并不仅仅是一个技术体系或文化,更重要的是背后对智慧的理解、解决问题的逻辑和重新定义制造的思维。\n智能制造的核心\n制造系统的核心要素可以用5个M来表达，即材料（material）、装备（machine）、工艺（methods）、测量（measurement）和维护（maintenance），过去的三次工业革命都是围绕这5个要素进行的技术升级。然而，无论是设备的精度和自动化水平提升,或是使用统计科学进行质量管理,或是状态监测带来的设备可用率改善,又或是精益制造体系带来的工艺和生产效率的进步等,这些活动依然是围绕着人的经验开展的,人依然是驾驭这5个要素的核心。生产系统在技术上无论如何进步,运行逻辑始终是:发生冋题→人根据经验分析问题→人根据经验调整5个要素→解决问题→人积累经验。\n而智能制造系统区别于传统制造系统最重要的要素在于第六个M,即建模(modeling),并且正是通过这第六个M来驱动其他5个要素,从而解决和避免制造系统的问题。因此智能制造系统运行的逻辑是:发生问题→模型(或在人的帮助下)分析问题→模型调整5个要素→解决问题→模型积累经验,并分析问题的根源→模型调整5个要素→避免问题。因此,一个制造系统是否能够被称为智能,主要判断其是否具备以下两个特征:\n(1)是否能够学习人的经验,从而替代人来分析问题和形成决策。\n(2)能否从新的问题中积累经验，从而避免问题的再次发生。\n我们不难看出,无论是机器换人、物联网,或是互联网+,解决的只是5M要素的调整方式和途径,只是在执行端更加高效和自动化,并没有解决智能化的核心问题。\n所以说,智能制造所要解决的核心问题是,如何对制造系统中的5M要素的活动进行建模,并通过模型(第六个M)驱动5M要素。智能制造所要解决的核心问题是知识的产生与传承过程。\n摘自《From Bigdata to Intelligent Manufacturing》 Jay Lee\n恩菲的优势\n恩菲作为工程技术公司，在信息化业务方面不具备优势，我们优势是也是在上述第六个M当中，基于工艺的优势，利用信息化的手段和外部力量打造各中有色金属冶炼流程中的Model。建模的类型可以分为以下三类：\n冶金数学机理模型(恩菲已经具备自主开发的APC系统，可直接应用)\n基于冶金反应原理，根据工艺流程创建冶金数学模型，通过热力学数据库进行热力学三大计算，建立冶炼过程的机理模型。\n仿真模拟机理模型（目前仅限于研究，未见在线应用）\n借助CAE仿真模拟工具，对炉窑及关键装备进行流体力学、化学反应、温度场等多项综合模拟，建设冶金过程的数字孪生模型。\nAI人工智能模型（突破方向，恩菲应结合业务场景重点研发）\n结合冶炼工艺专家经验及现场操作经验，深度挖掘生产大数据库中的信息价值，利用机器学习及大数据分析等AI技术，建立冶金过程的经验模型。\n6.恩菲智能冶炼业务的合作及发展方向\n在投入可控的条件下，符合恩菲规划的大框架下寻求合作，组建恩菲IT技术团段与管理制度，自主研发核心产品，摸索云服务的商业模式，逐步打造具体恩菲特色的有色冶炼云服务集成商和核心功能提供商。\n（1）统一标准接口服务系统开发\n企业数据源繁杂多样，接口协议五花八门，依靠传统的SOA技术架构，无法高效采集存储，无法充分满足各应用间的数据交互需求，亟需合作开发一套承接数据与应用的统一标准接口服务平台，集成基础通用业务组件（PaaS层），为专业应用提供便捷高效服务。\n（2）可靠安全的云资源合作方\n企业选择私有/公有云资源建设方案是大势所趋，稳定安全的云资源是基础条件。寻求成套系统解决方案提供商。\n（3）人工智能技术应用\n利用机器学习、深度学习等技术，针对有色冶炼中难点场景提供人工智能解决途径\n无法经济直接测量感知难题，如利用视觉识别技术，实现吹炼终点在线预判、选矿泡沫智能识别等。\n 赋能传统装备转化为智能装备，如利用声音识别技术，实现破碎机、高温风机等关键设备异常预维护。\n 生产过程优化，建立冶炼过程机器学习模型，实现智能配料，优化工作操作参数，提高生产作业效率。\n供应链协同预测，利用大数据分析技术，减少库存量，扩大采购原料适应性。\n（4）IT团队及管理制度.\n聘请高水平架构师，构建恩菲IT技术团队，建立并完善软件开发流程，覆盖需求-设计-开发-测试-部署-运维各个环节，形成安全的代码管理与代码审核及测试部署管理制度。\n恩菲业绩  1.《有色金属行业智能制造建设指南》编制工作\n近日，工业和信息化部、国家发展改革委、自然资源部等三部门联合公告了中国恩菲参与编制的《有色金属行业智能工厂（矿山）建设指南（试行）》（以下简称“《指南》”）。\n有色金属行业是典型的流程工业，具有种类繁多、原料来源繁杂、工艺复杂流程长、工况环境苛刻等特点。与钢铁、石化、化工等行业相比，难以形成适用于所有工矿企业的标准化、共性化数字平台。这大大增加了有色企业数字化、智慧化转型的难度，成为制约行业转型升级的关键痛点。为加快有色金属企业智能制造建设进程，推动行业高质量发展，工业和信息化部于2019年4月委托中国有色金属工业协会启动了《指南》的研究编制工作。《指南》包括《有色金属行业智能矿山建设指南（试行）》《有色金属行业智能冶炼工厂建设指南（试行）》《有色金属行业智能加工工厂建设指南（试行）》三个部分，对相关方面的建设目标、建设路径、建设内容及基础支撑进行了明确。  　在中国有色金属工业协会的统一组织下，中国恩菲作为我国有色金属行业资深工程服务企业，牵头编制了《有色金属行业智能冶炼工厂建设指南》，参编了《有色金属行业智能矿山建设指南（试行）》。编制过程中，中国恩菲依托丰富的有色行业工程实施经验和深厚的技术积淀，深刻领会指南编制意义与目的，秉持行业国家队的使命担当，全面分析总结有色金属冶炼行业特点与智能化发展现状，立足行业实际需求和技术发展前瞻方向，明确指南面向有色冶炼生产企业，以实现新一代信息技术与工业控制技术的深度融合为着力点，高点定位、全局统筹，联合贵阳铝镁设计研究院有限公司、江西铜业集团有限公司、株洲冶炼集团股份有限公司、云南驰宏锌锗股份有限公司、金川集团股份有限公司、云南锡业集团（控股）有限责任公司、长沙矿冶研究院有限责任公司、北京矿冶科技集团有限公司、中南大学、上海宝信软件股份有限公司、华为技术有限公司等企业、高校组成编写组，全力开展编写工作。为进一步了解企业需求、掌握一手资料，编写组于2019年5月先后对江西铜业集团有限公司贵溪冶炼厂、重庆旗能电解铝厂、云南驰宏锌锗股份有限公司、云南锡业集团（控股）有限责任公司进行了第一次现场实地调研；于2019年7月先后对株洲冶炼集团股份有限公司、华为技术有限公司、西门子成都工厂进行了第二场现场考察调研。\n　《指南》立足有色金属行业智能制造“‘工业2.0’补课、‘工业3.0’普及、‘工业4.0’示范”的建设思路，参考《国家智能制造标准体系建设指南》中智能制造系统架构，明确通过基础设施的数字化改造实现资源要素的汇聚和互联互通，通过智能生产系统建设实现信息融合共享，通过基于服务型制造的智能服务应用推动新业态发展，同时，为激发企业活力，《指南》明确了基于工业大数据的协同创新平台建设要求，支撑企业进行持续的数据应用创新，针对基础设施的数字化改造与建设、基于业务驱动的智能生产系统建设、基于服务型制造的智能服务应用建设和基于工业大数据的协同创新平台建设四个方面提供了指导。\n《指南》将有效推进5G、工业互联网、人工智能等新一代信息通信技术在有色金属行业的集成创新和融合应用，在操作层面为企业开展智能制造提供顶层设计和全面引导。牵头参与《指南》编制工作，既体现了中国恩菲以深厚的技术积累为依托推动行业发展、产业升级的责任担当，更与公司以“数字化、智慧化”转型为契机，为行业提供数字矿山、数字工厂一体化解决方案的发展方向一脉相承。目前，中国恩菲已经开发了以全信息可视化（MIM Transparent）、全流程数字化（MIM Digital）、运营周期数字孪生（MIM Twins）为核心的数字矿山、数字工厂MIM技术体系，构建了矿冶企业全数字信息模型，形成了适用于有色行业的全要素、全数字一体化解决方案，为支撑《指南》落地实施提供有效路径。中国恩菲将持续推动技术升级和平台打造，着力建构行业数字化转型新业态，推动“有色+数字”的国际竞争力提升。\n  五矿有色铜铅锌产业基地锌项目智能工厂建设\n中国恩菲2017年EPC总承包实施的株冶搬迁年产30万吨项目，其中子项目智能工程建设与工程项目同期实施，主要建设内容包括完成全厂的DCS控制系统、过程控制系统、质量管理系统、设备管理系统、能源管理系统、物流管理系统、安健环管理系统、现场网络铺设、主机房建设、安防系统、OA办公等多个MES、ERP子系统与设施的应用，基于先进装备、智能感知的硬件采用，智能设备、工业物联网、大数据分析、移动应用等新一代IT技术的集成应用，逐步完成办公自动化、经营管理信息化、生产制造过程信息化、工艺优化控制、大数据分析与应用、智能辅助决策等各类企业业务场景需求的建设，实现生产过程的精细化管理，工艺控制的可持续改进以及生产经营的智能化辅助决策，使得企业的生产运营达到了以数字资源驱动的人机协同优化运行，提高企业运营效率和产品质量，实现以人为本的运营，实现株冶有色工厂的绿色、安全、高效的持续优化。   通过全厂基础自动化系统建设，使得全厂具备实时感知设备动态信息的能力，对生产过程中所发生的异常情况进行预警报警的能力，为设备监测、运营、管理提供手段。 以大数据平台为核心，通过信息集成，利用大数据分析技术，对生产管理和经营管理中的业务信息进行多维度分析、预测，并及时对生产工艺过程和生产管理过程进行优化调整，为各级管理者提供决策依据，降低管理风险，提升管理效益。 开发应用了湿法炼锌生产过程中的配料、焙烧、浸出、净化及电解主要工序的生产过程优化控制系统，基于冶金反应过程机理模型，辅以大数据分析数据模型，实现了各生产操作参数的优化，达到降低生产过程的资源消耗和提高产品合格率的目标，为生产调度人员的决策提供重要参考依据。    云南驰宏锌锗股份有限公司会泽冶炼分公司锌浸出渣处理环保节能技改项目——熔化炉先进过程控制系统（APC）项目\n2019年云南驰宏锌锗会泽冶炼厂新建熔化炉处理锌浸出渣，中国恩菲在承担工程设计供货的同时，结合项目实际工艺流程与现场需求，恩菲自主研发的有色冶炼先进过程控制系统（Advanced Process Control，简称APC）随项目投产2020年8月同期投入应用，并于2020年1月通过项目验收。\n恩菲自研APC系统是一套部署生产企业边缘侧的工业控制软件，系统基于冶炼工艺的基本原理，依靠冶金热力学数据库，将实时采集的生产数据作为模 型的输入条件及反馈修正的依据。通过冶炼企业的生产工艺控制过程的数学建模，采用先进的在线控制算法，无需人工干预即可在不同的工况条 件下自动实时计算，将不断自修正的模型计算输出结果(即为时序操作指令)下发DCS，由DCS完成实体操作的执行。 实现生产操作调整的有理有据，按需敏捷， 同时自适应消除系统偏差，为冶炼生产作业的稳定连续作业和进一步的工艺优化提供重要技术保障，从而为生产企业带来经济、安全、环保等综 合效益，最终成为集约化管控的重要手段。\n系统采用前后端分离的web开发技术及微服务架构，实现了从C/S架构到B/S架构发展。融合了原料策略、冶金数模、反馈修正、数据通讯、数据分析等多模块应用，适应了企业智能化发展的兼容性与先进性的要求。    烟台国润铜业有限公司节能技改项目——“侧吹炉熔炼+多枪顶吹炉连续吹炼”在线智能优化控制系统\n烟台国润铜业于2016年启动技改工程，采用中国恩菲自主开发的“侧吹熔炼+多枪顶吹吹炼”冶炼技术对老厂进行工程化改造。国润铜业积极响应国家智能制造发展战略，在有色冶炼行业率先探索智能冶炼应用，中国恩菲依托其在工艺技术上的核心优势，为国润铜业开发了全国首套“侧吹熔炼+多枪顶吹吹炼”在线智能优化控制系统，并于2017年成功投入应用。该系统基于“侧吹熔炼+多枪顶吹吹炼”工艺反应机理，基于强大的冶金热力学数据库，建立三大平衡（物料平衡、热量平衡、多相平衡）冶金数学模型，精准输出冶炼控制工艺操作参数，并能根据实际核心化验结果对比，采用先进智能反馈算法对核心工艺控制参数进行动态反馈调整，避免了因原料成分波动、人员操作水平不一等因素对生产系统造成的波动，有效保障主生产系统的稳定、安全运行。    缅甸达贡山镍铁冶炼项目——电炉先进控制系统EF-APC\n中国恩菲自主开发的电炉先进控制系统EF-APC，用于各式埋弧电炉和电弧炉的控制，目前已在包括缅甸达贡山镍铁项目等国内外多个镍铁熔炼电炉、铜冶炼贫化电炉及钒钛磁铁矿电弧炉上成功应用。采用以专家系统为核心的专利技术，相对传统死区控制方法可明显提高控制效果。通过对功率的精确平稳控制，使得炉况长期保持稳定，工艺及能耗指标达到最优，进而实现增产降耗的目的。    研发定位   研发大方向\n方向一：有色冶炼智能工厂边缘计算、物联网、AI技术融合应用研究\n方向二：有色冶炼智能工厂企业内网融合及安全技术研究\n方向三：有色冶炼智能工厂全要素数据采集及治理技术研究\n方向四：有色冶炼工程设计数据模型融合技术及数字化交付系统研究\n方向五：有色冶炼智能工厂数据融合控制技术研究\n方向六：有色冶炼智能工厂多维极致可视化及即时仿真技术研究\n方向七：有色冶炼工厂智能感知与先进装备技术研究\n  产品开发与装备研究方向\n研究任务1：有色冶金先进过程控制系统\n研究任务2：渣样/铜样图像识别终点判断智能装备\n研究任务3：冶金炉窑环境声音识别炉况分析系统\n研究任务4：图像识别智能扒渣机器臂\n研究任务5：渣包车自动调度系统\n研究任务6：无人吊车智能料仓系统\n研究任务7: 有色冶炼冷却循环水智能哨兵系统\n研究任务8: 恩菲冶炼协同设计助手平台\n研究任务9: 恩菲冶炼专业知识库应用开发平台\n  八大任务 分析目前智能工厂技术现状，结合有色冶炼企业实际情况，规划有色智能工厂八大主要任务，并对每项任务的具体课题内容进行梳理。\n一部分核心课题自主研究开发，形成技术成果及应用。一部分协作课题需要与外单位合作，形成合作框架及具体合作方式报告。总之是要对每一个具体课题形成一个完整可行的方案。\n  任务一：智能冶炼系统解决方案及前瞻性技术研究\n任务目标：探求有色冶炼企业生态环境及与外界智能交互关系，研究流程制造运行的本质特征，寻找一条切入的有效途径，集成企业动态运行、管理、服务的自感知、自决策、自执行、自适应的核心技术，搭建智能冶炼系统概念框架，形成系统解决方案（白皮书）；针对智能冶炼系统概念框架中的重点难题，持续跟踪前瞻性技术，不断完善系统解决方案。\n课题1：《有色冶金企业生态环境调查研究》\n课题2：《当前相关行业前瞻性技术调研及可移植性论证》\n课题3：《智能冶炼系统框架解决方案概念研究》\n  任务二：新型功能一次检测仪表及感知组件开发\n任务目标：针对有色冶炼工业过程中，固体散料、高温熔体、烟气、烟尘等介质的位置形态、温度、流量、厚度等参数的测量难题，研究新型检测技术，突破高温热管、图像识别、声音识别等关键技术，开发新型功能一次检测仪表及感知组件。\n课题1：《高温热管技术应用》（与中科院合作开发，已立项）\n课题2：《有色冶炼工业图像识别技术应用研究》\n课题3：《有色冶炼工业声频识别技术应用研究》\n课题4：《固体散料全息特征参数测量技术应用研究》\n课题5：《高温熔体流量/容量测量技术应用研究》\n课题6：《多尘工况下高温烟气测量技术应用研究》\n课题7：《余热锅炉积灰在线监测技术应用研究》\n课题8：《流体管道输送参数射频识别监测技术应用研究》\n课题9：《感知终端射频装置及巡检PDA装置开发应用研究》\n  任务三：自动装置及智能装置开发\n任务目标：针对当前有色冶炼生产企业人工劳动强度大、自动化水平较低的现状，开发机械手臂、氧枪更换、炉口清理、自动开堵口等机械和自动化装置，最大化实现机械化代人、自动化减人；针对有色冶炼智能装置应用率低，研究无人吊车、巡检机器人等具有一定智能的一体化装置。\n课题1：《储配料车间智能吊车开发及应用》\n课题2：《底吹炉智能枪口砖清破装置开发及应用》\n课题3：《底吹炉加料口粘结清理装置开发及应用》\n课题4：《自动开堵口机装备研发及应用》\n课题5：《无人值守捅风眼机装备研发及应用》\n  任务四：先进过程控制(APC,Advanced Process Control)决策软件开发\n任务目标：针对有色冶炼生产过程控制粗放、工艺指标波动较大等实际问题，基于一次检测元件、组件、装备的采集数据，深入研究火法冶炼、湿法冶炼、化工等各过程的控制策略，采用数学算法建立过程控制模型，开发针对该过程的先进过程控制决策软件，实现生产过程的精细化稳定控制。\n课题1：《冶化流程先进过程控制（APC）通用建模平台开发》\n课题2：《多控制系统集中通讯平台开发》\n课题3：《热力学数据库建设》\n课题4：《基于工艺生产数据的AI算法研究》\n课题5：《侧吹+多枪顶吹工艺APC决策软件开发应用》\n课题6：《双底吹工艺APC决策软件开发应用》\n课题7：《冶炼渣浮选工艺APC决策软件开发应用》\n课题8：《铜电解工艺APC决策软件开发应用》\n课题9：《制酸工艺APC决策软件开发应用》\n课题10：《偃师研发基地火法系统M-APC软件开发与示范》\n  任务五：虚拟工厂建模及仿真应用研究\n任务目标：基于工程设计和实际生产系统数据，对有色冶炼生产各工序的进程协同及工艺过程模拟进行深入研究，建立数字化流程生产动态模型；以实际生产数据对虚拟模型进行动态仿真训练，在逻辑层上与实际生产系统平行运行，开展有色冶炼工厂流程仿真“数字双胞胎”实践应用探索，通过系统工程优化生产过程，来提高生产效率、降低成本和实现质量目标。\n课题1：《虚拟智能工厂的开发与应用（中冶新材料项目）》\n课题2：《火法冶炼厂主要设备仿真模型对象的开发》\n课题3：《火法冶炼虚拟工厂的建模与仿真应用》\n课题4：《湿法冶炼厂主要设备仿真模型对象的开发》\n课题5：《湿法冶炼虚拟工厂的建模与仿真应用》\n课题6：《制酸虚拟工厂的建模与仿真应用》\n课题7：《虚拟工厂与物理工厂数据接口开发》\n  任务六：车间智能化集成研究\n任务目标：针对不同车间的具体功能，以一次检测元件、自动装置、智能装置为硬件基础，通过先进过程控制决策软件进行驱动,开展车间级智能化集成研究，如智能精矿仓、智能仓储等。重点解决软硬件集成过程中的系统架构问题，保障集成后系统的可靠性和安全性，并就核心车间率先开展智能化集成实践。\n课题1：《偃师研发基地火法系统集成研究与示范》\n课题2：《偃师研发基地空压机房集成研究与示范》\n课题3：《偃师研发基地制氧系统集成研究与示范》\n课题4：《偃师研发基地冷却循环水系统集成研究与示范》\n课题5：《智能精矿仓集成研究与应用》\n课题6：《智能配料车间集成研究与应用》\n  任务七：智能冶炼及工业互联功能软件开发\n任务目标：以有色冶炼工厂的物质流、能量流、信息流为对象，研究生产活动的数据流动，融合工业以太网和控制以太网技术，开展能源管控、设备维护、巡检管理、安防管理、库存管理、计量管理、质检管理等功能软件开发，为生产运行管理及企业资源优化提供服务。\n课题1：《生产执行系统（iMES）框架及信息流交互研究》\n课题2：《冶炼工厂信息物质流网络建设方案研究》\n课题3：《能源管控系统功能软件开发》\n课题4：《设备维护系统功能软件开发》\n课题5：《巡检管理系统功能软件开发》\n课题6：《安防管理系统功能软件开发》\n课题7：《库存管理系统功能软件开发》\n课题8：《计量管理系统功能软件开发》\n课题9：《质检管理系统功能软件开发》\n  任务八：MIM系统有色冶金云服务平台建设\n任务目标：研究建立MIM系统有色冶炼云服务平台，以企业级CPS边缘计算和雾计算为基础，通过有色冶炼生产企业上传到云端的共享数据，在云端依靠数据挖掘、大数据分析等技术，对冶炼生产数据进行深度分析并形成智库，为有色冶炼行业的生产企业提供数据引用、模型应用、远程诊断等专业化智能服务。\n课题1：《MIM系统有色冶金云框架及信息流交互研究》\n课题2：《MIM系统有色冶金云网络安全研究》\n课题3：《有色冶金云服务平台前端WEB网站建设》\n课题4：《有色冶金云服务平台后端算法研发》\n课题5：《有色冶金云服务平台数据库建设》\n  重点课题 经筛选下一步主要工作研究课题有:\n课题1：《有色冶金企业生态环境调查研究》\n研究当前有色冶金企业的生态环境，结合相关法律法规，重点关注企业与社会外界的主流交互关系，分析企业上游物料（精矿、燃料等）供应链、下游产品（铜阳极板或阴极板、硫酸等）销售链以及生产排放物（废水、污酸、烟气）处理链，理清从采购到生产到销售与企业利益的全流程关系模型。\n课题2：《当前相关行业前瞻性技术调研及可移植性论证》\n学习当前相关行业（自动化、AI、互联网、物联网等）的最新的技术现状与进展，重点研究其中可工业化实践的技术，形成移植应用到有色冶金行业的技术可行性方案。此课题需要分类长期持续跟踪。\n课题3：《智能冶炼系统框架解决方案概念研究》\n研究智能冶炼系统工艺化实践的框架设计，如系统中的网络架设方式、数据库建设与数据交互方式等，再如企业智能化生产、运营、管理方式等。对智能化实施应用过程中涉及到的各个环节及部分进行框架设计，形成系统的解决方案。\n课题4：《有色冶炼工业图像识别技术应用研究》\n课题5：《有色冶炼工业声频识别技术应用研究》\n借助AI中深度学习算法，应用成熟开源框架(TF、Caffe、Gloun),学习图像识别和声频识别的核心机理，研究分析在有色冶炼行业的应用点，（炉体变形监测、颚式破碎机破碎效果声频监测等），就其中一两点作为技术突破口，开发出可适用发行的应用程序软件。\n课题6：《固体散料全息特征参数测量技术应用研究》\n跟踪行业内成熟技术，寻找优质合作生产厂商，合作开发软硬件集成的测量固体散料（精矿、熔剂、烟尘等）的特征参数，包括主要元素成分、水分等，要求迅速、准确，同时能够对矿仓内的物料进行三维扫描，建立三维全息物料信息库，用以支持吊车智能化操作时的定位和判断。\n课题7：《储配料车间智能吊车开发及应用》\n依据固体散料全息特征参数测量技术，根据储配料车间的实际需求，联合厂家合作开发智能吊车,并根据有色冶炼工厂物料储配抓运的特点，硬件编程实现上层库管软件等的要求，实现无人化精准操作。\n课题8：《冶化流程先进过程控制（APC）通用建模平台开发》\n针对有色冶炼生产过程控制粗放、工艺指标波动较大等实际问题，基于一次检测元件、组件、装备的采集数据，深入研究火法冶炼、湿法冶炼、化工等各过程的控制策略，采用数学算法建立过程控制模型，开发针对该过程的先进过程控制决策软件，实现生产过程的精细化稳定控制。\n课题9：《多控制系统集中通讯平台开发》\n目前有色企业的控制系统离散、多元，存在多套系统不同厂家、PLC与DCS混用、部分数据TCP/IP协议通信，研究开发一套集中通讯平台，集中管理采集企业的所有控制系统。为上层软件或系统的通讯减少负担。\n课题10：《热力学数据库建设》\n建设恩菲自己的热力学数据库平台，从化合物手册、Factsage、Metsim等途径收录全面的数据，如密度、熔点、热焓等。为开发研究自主的冶金计算核心算法提供数据支持。\n可外包在校研究生。\n课题11：《侧吹+多枪顶吹工艺APC决策软件开发应用》\n与烟台国润铜业合作研发的现行项目，也是第一个应用实践的项目。目前已基本完成软件的开发工作，需要持续跟踪，洽谈能否将数据内部分享。另外，需开展软件的成果宣传推广工作，有利于占领先机市场。\n课题12：《偃师研发基地火法系统M-APC软件开发与示范》\n利用烟台国润铜业侧吹+多枪顶吹工艺APC决策软件的技术经验，基于偃师研发基地的实际情况，将各APC软件集中扩展到整个火法系统形成E-APC。开发出一套可远程通讯控制的软件，为软件推广建设示范工程。\n聚焦研发 智能冶炼信息模型（MIM®）在冶炼设计阶段，基于三维协同设计平台，可实现三维可视化设计、 更有效的设计协同管理，基于数字化交付平台，可实现工程设计数据及模型、冶炼生产专业知识的融合，动态推送有色冶炼市场行情与业界动态，建立与应用方的安全持续交互和信息服务；在施工建设阶段，通过建立MIM施工模型，实现施工进度、人力、材料、设备、 成本、安全、质量等动态集成管理及施工过程可视化；在生产运营阶段，结合生产管控系统，实现冶炼多系统综合智能管控、关键设备预防性维护、能源管理等功能。\n 一、在公司智能工厂理念统一指导下，积极推广宣贯恩菲智能冶炼理念与产品，占据市场主动。组织各科室力量，逐步形成铜镍铅锌及固废业务领域智能工厂建设或升级的规划方案，形成高阶段设计专篇或章节指导模板。深入实施企业现场进行详细现状调研与需求分析，协助企业完成投入少、见效快、兼容扩展的智能化建设或升级的总体设计与规划，在项目实施中逐步形成行业特色、恩菲特色的有色金属行业智能冶炼工厂的整体解决方案，实现从规划、设计、实施到评价的全方位的智能化升级服务。 二、进一步市场推广应用恩菲自主开发冶炼先进过程控制系统（APC）系统，同时加强系统功能拓宽与理论体系建设，下一步研究工作内容：\n1.扩宽系统应用场景，不局限于主工艺。如底吹炉、加压釜、余热锅炉等；\n2.扩展丰富系统功能，如动力学模型、成矿物相、物相分析推定等实用功能；\n3.完善理论体系，如热值修正、反馈算法等理论；\n4.支撑恩菲矿冶云服务平台应用，提供在线冶金计算、热力学数据查询等服务。 三、进一步推动数字化工程设计，打通专业间、软件间的交互协同流程，逐步研发建设数字化交付系统，支撑智能冶炼业务数据基石。下一步研究工作内容：\n1.工程设计编码规则与标准；\n2.工程设计数据分类治理技术；\n3.数据和模型的融合技术；\n4.数字化交付标准与规范；\n5.数字化交付技术系统开发； 四、加强智能感知与先进装备开发与应用推广。结合有色冶炼工业场景，利用图像识别、语音识别、机器学习等AI技术，研发一体化智能感知的先进成套装备，重点研发方向如下：\n1.渣样/铜样图像识别终点判断智能装备\n2.冶金炉窑环境声音识别炉况分析系统\n3.图像识别智能扒渣机器臂\n4.渣包车自动调度系统\n5.无人吊车智能料仓系统\n6.有色冶炼冷却循环水智能哨兵系统  一、冶炼设计阶段 1.1三维协同设计平台（ENFI）  设计专业协同 设计数据汇聚 设计模型轻量化封装  1.2 数字化交付系统  工程设计数据模型 冶炼生产专业知识引擎 行业动态市场行情  数据分类，数据处理算法，数据的意义由工艺赋予。自主开发，这个必须有恩菲掌握。我们核心买的就是算法，每一种金属每一种工艺一种分类和处理方法。 市场行情，业内动态等消息推送，私有云建设以后，恩菲与其发生交互的途径，可以定期定时发送信息，也是宣传推广的好手段  二、施工建设阶段 2.1 施工建设管理系统：\n进度、人力、材料、设备、 成本、安全、质量\n三、生产运营阶段： 3.1 IT设施层（IaaS）:\n融合网络建设\n5G、TSN、软件定义网络、域控与VPN等\n数据机房建设\n服务器集群（docker +k8s）、网关路由等硬件设施、模块机房、异地灾备\n数据中心建设\n数据分类：\n数字化交付资产数据（模型+数据）\nDCS/FCS工控系统数据\n分析化验系统LIMS数据\n检斤计量系统离散数据\n人员组织数据\n视频、音频数据 （现场边缘侧嵌入式设备/智能网关）\n外部信息数据湖 （供应链、销售链、行情动态等数据）\n业务应用数据湖\t（设备管理、能源管理等SaaS应用数据\n数据技术:\n大数据平台建设 （分布式集群、Hadoop、实时数据库）\n数据治理技术（采集、处理、存储、计算、服务）\n数据规则（人、机、料、法、环的编码规范、使用规程）\n数据安全 （堡垒机）\n3.2 工业互联网架构：\n微服务技术体系\n3.3 智能冶炼核心专长技术及产品\n  智能融合控制系统（薛昊洋）\n智能融合控制系统在综合控制系统的基础上，实现生产各子系统（供配电、生产过程与控制、安 全监控、通信等）之间的相互交叉渗透、信息相互引用、资源相互共享层面上的融合，其优点在于在 硬件设备上实现各个子系统之间交集的共享、最大减少控制设备的品种、统一技术标准和通讯规约， 实现矿山生产管控的信息化和标准化、高可靠性和经济性的目的。 该技术目的是解决底层数据采集问题，建立全矿融合数据网（包括控制信息、电力信息、监控检 测信息和其他通信信息），把目前地下采矿生产配套的辅助系统（通风、排水、供电等）有机地结合 为一个整体，大幅度简化地下网络系统，实现各专业各系统（供配电、控制、网络、视频）之间的相互交叉、相互渗透、信息相互引用、资源相互共享层面上的融合，为智能控制和大数据生产打下基础。通过“多网合一”，实现了信息高速公路硬件和软件最大程度的协调和统一，促使保护和控制功 能融合化和共享化，促进控制设备厂家、品种、型号、规格数量的最小化及使用技术数量方面的最小 化，达成维护习惯方面一致化、维护和预维护大数据化、生产统计数据自动化等效应，从而达到井下 无人或少人开采的目标，最终实现矿山智能化。 目前中国恩菲的该技术已在赞比亚谦比希主西矿体自动化改造项目、赞比亚谦比希东南矿体自动化信息化融合项目、银山矿业采选两化融合工程等项目得到推广与应用。\n  大功率电炉优化控制系统\n缅甸达贡山镍铁RKEF电炉 李刚\n  冶炼先进过程控制系统\n烟台国润侧吹+多枪顶吹连续吹炼 铜冶炼 吴金财\n云南驰宏会泽侧吹熔化炉 锌浸出渣处理 张官祥\n  智能装备（刘占彬）\n物料制备设备的集成化及智能化研究 贾源\n炉前处置、加料和清理设备技术研究及智能化 刘占彬\n物料转运及浇铸成形设备的大型化、集成化及智能化 黄坤程\n炉窑烟气治理环保设备智能化 邱杰敏\n工业固废领域物料连续处理与裂解设备技术研究及智能化 张楷\n镍铁领域高温物料输送设备的集成化及智能化 刘占彬、贾源\n  智能配电技术\n低压智能配电及智能操作技术与装置的研究 刘立峰\n  有色特色应用\n炉体冷却水系统成套装置控制技术研究 薛昊洋\n炉体水套哨兵装置 马宾\n数字化/智能化喷枪装置研制 王书晓、冯双杰\n铜铅锌冶炼固废转化一体化智能集成管控系统-铜铅锌基地多介质资源环境物联网监管系统及示范应用 薛昊洋\n  ","description":"","id":58,"section":"sf","tags":null,"title":"恩菲智能化冶炼业务","uri":"http://austinzgx.github.io/sf/doc/"},{"content":"一、研究目标及研究内容简介 1.1项目背景及来源： 随着物联网、大数据和移动应用等新一轮信息技术的发展，全球化工业革命开始提上日程，工业转型开始进入实质阶段。在中国，智能制造、中国制造2025等战略相继出台，智能工厂作为工业智能化发展的重要实践模式，已经引发行业的广泛关注。\n智能工厂是在数字化工厂的基础上，利用物联网技术、监控技术加强信息管理服务，利用数字化冶炼模型、前后反馈修正、大数据等技术提高生产过程稳定性、减少生产线人工干预，以及合理计划排程。同时，集科技智能手段和智能系统等新兴技术于一体，构建高效、节能、绿色、环保、舒适的人性化工厂。\n我国有色金属工业正由多年快速增长进入中低速增长阶段，有色金属企业处于加强技术改造，促进产业升级的关键时期。随着我国有色金属工业向中高端和绿色业转变，传统有色企业以新技术新装备应用为核心的升级改造将催生大量的市场机遇，中国恩菲要顺势而为发掘市场红利。近年来，多个有色金属企业，包括我公司，在智能（数字化）矿山领域开展的多项工作，个别企业在装备制造领域广泛引进工业4.0理念，取得了一定成绩。我公司是有色行业咨询设计领军企业，除了大力开展数字化矿山研究之外，还要加快推动有色冶炼智能化工厂的研究，加快出成果，占据领先地位。\n1.2研究目标： 以智能制造为切入点和突破口，联合相关有色金属企业，以提升合作企业的智能化运作水平、提升企业生产制造、企业管理、销售服务的智能化水平和运营效率效益，开展有色冶炼智能工厂技术及系统研究，将相关技术落地实施，逐步实现从单工序到全流程，再到全车间，最后到全企业的自动化、智能化、数字化、可视化、模块化和集成化，从而推进我公司有色冶炼智能工厂技术水平跨越式发展，打造公司竞争新优势，联合企业打造有色冶炼智能工厂的示范工程，树立有色智能冶炼厂的标杆。\n1.3研究内容：  有色金属冶炼厂智能化概念研究，以某企业铅冶炼为研究对象，研讨自动化生产线、数字化车间、智能化工厂的范围、深度，确定主要研究内容； 对合作企业全工厂全工序，特别是重点生产操作、装备、工艺控制等方面现有自动化水平调研，针对某企业形成某工序或全厂自动化、智能化需求分析报告； 以中国恩菲核心专长氧气底吹技术的工艺过程智能化为研究重点，考察学习先进的行业技术，对进行工艺控制、生产操作自动化、智能化关键技术研究，并落地实施形成氧气底吹工艺智能化生产线； 根据企业需求及可实施性，选择某车间或工段，进行数字化车间研究，形成相应的控制设备、软件程序，并争取落地实施形成示范工程； 在自动化和智能化的基础上，通过网络信息技术，建立工厂级的数字化中心，将与生产执行、流程作业、生产管理等紧密相关的信息进行数字化，利用MES/ERP技术，建立生产综合信息大数据平台； 在“计划调度、安全环保、能源管理、设备操作、质量管理、IT管控”等六大领域，实现自动化、数字化、可视化、透明化、模型化、集成化等六大特征的智能工厂框架。  二、技术路线、主要创新点 2.1 技术路线 智能工厂是集设备、仪表、工艺、计算机、电信、机器人等多行业的成果于一体，其高集成性和复杂性决定了该项目的研发必须是多专业密切配合，相互反馈，整体开发的长期的过程，需要成立专业团队，有固定人员长期投入，针对具体项目相关人员积极参与。\n1.调研有色企业采用的工艺流程以及目前自动化情况，了解企业需求，对现有的设备仪表进行适应性改造和提升。\n2.开发团队与有色企业充分沟通协商智能工厂的目标，确定进行智能化过程控制升级的分步及各阶段的水平要求、费用估算等，并在实际开发研究过程中就实施细节不断密切沟通协商。\n3.确定具体开发团队人员，制定开发方案，包括人员、计划和进度安排，对于不同部分需要确定负责人，如设备仪表硬件升级改造部分、软件系统开发部分。以负责人制度确保项目的质量和进度。\n4.在项目执行中保持与应用企业的及时沟通和对行业最新成果的密切跟踪。保持项目应用技术和目标的先进性和准确性。\n5.对项目中存在的难点和重点，如过程检测技术（高温熔体测温、熔池液面检测）、物料成分在线检测等技术，组织相关研究人员进行攻关开发或借助外单位科研院所共同开发。\n6.项目完成后首先对各个相对独立的系统进行多方面多手段调试，再对集成联动的整体系统进行联动调试，包含离线测试和上线反馈调试等多种调试。确保系统的稳定性和可靠性后投入实际运用。\n7.实现主要工序的智能控制系统后，依据上述步骤再对其他工序进行相同的自动化、智能化升级，逐步实现主要车间的自动化、智能化，不断对物料、生产、计划、安全、质量、信息等多个参量的联动智能操作和整体升级，最终形成整个有色冶炼工厂的自动化、智能化。\n8.在实现工厂生产系统的自动化、智能化后，通过网络信息技术，为企业建立数字化中心，将与生产执行、流程作业、生产管理等紧密相关的信息进行数字化，建立企业生产综合信息大数据平台。由面向车间执行层的生产信息化MES管理系统和工厂级资源调度计划ERP系统。\n9.在实现上述自动化、智能化、数字化的同时，实现从关键部分到全部有色智能工厂可视化，包括生物视觉上的可视化，设备运行状态的可视化，生产人员状态的可视化，生产过程的可视化。\n10.以上自动化、智能化、数字化、可视化相互之间联系紧密，开发中需要相互构成、相互反馈，形成个模块化工段的工艺智能控制集成化，实现冶炼一体化智能生产线，下游与上游通过工艺智能控制系统对接，各个工段、车间形成工艺控制的协同匹配。从工艺控制上将熔炼、电解、硫酸系统集成，实现生产组织、工艺匹配、作业调度、生产信息共享与交换等更高维度的协同。\n11.持续跟踪企业智能系统的运行状况，与应用企业保持良好紧密的联系，总结分析生产控制经验，通过数据分析挖掘工艺参数内在相关性，形成经验固化到系统中并反哺生产，形成良性循环。不断升级优化智能系统，密切关注各行业的发展成果，因地适宜地应用到有色智能系统中。\n12.项目成功应用后，加大市场宣传力度，以高可靠稳定性和先进性，逐步拓宽并占有有色冶炼市场。把项目工艺生产上获得的经验进行模块化，对每个工段的工艺参数都能形成单独的工艺模块，这些模块包含了质量控制、工艺参数控制、操作控制等方面。把恩菲的数据库发展成为国家监管有色企业的核心必备数据中心，发展成为国内外核心数据的权威引用中心。\n2.2 主要创新点 目前，国内开展智能工厂的研究尚属起步阶段，有色行业更是如此，在研发过程中可形成多项创新型技术成果。\n 在项目进行中逐步发现和攻关多项核心技术成果，目前可预计的成果有过程检测技术，包括高温熔体测温、熔池液面检测等，物料成分在线检测技术；炉体实时称重装备；高温热管技术等。\n2.冶金工艺流程数学模型，这部分是智能工厂的核心，也是软件部分的核心，将不同工艺、不同炉型、不同物料的工艺流程的数学模型进行封装，形成冶金数模开发的通用平台。为后续项目的快速准确建模及应用打下坚实的基础，同时也是将恩菲核心冶炼技术推向世界的要求。\n3.通过市场开拓和项目成果的广泛应用，逐步形成恩菲自我拥有的全国众多冶炼厂的核心生产数据的数据中心，打造国家监管有色企业的核心必备数据中心，向成为国内外核心数据的权威引用中心迈进。\n4.恩菲数据中心经过一定时间积累，形成大数据后，对恩菲或者其他设计公司的设计咨询工作起到相当的提升，大幅度修正设计中的人为设定参数，提高设计参数、指标、技术经济的可靠性和准确性，同时也为应用智能系统的企业提供预测机制，对新购进的原料可以预测出未来一个月需要辅料、备件等数据。  七、技术难点及解决方案  核心攻关技术存在研发难度大、时间短等难点，每个技术需要单独立项，集中研发力量攻关突破，并保证技术成果可靠。对于没有十足信心的技术要做好备用方案的准备。首要保证智能系统的正常运行后再对细节和局部进行优化升级。 系统开发成功后首次应用需要进行调试，存在时间长，不可见因素多等难点，在调试阶段需要做好方案计划，从单体离线到联动上线中每一步的调试都需要投入足够的人力和时间，做到细致可靠稳定，同时需要应用企业密切配合。  八、技术风险分析 针对核心数据库及软件程序存在泄露的风险，建议对中国恩菲冶金数模智能控制专家系统软件及其数据库采用应用企业访问服务器前端，中国恩菲掌控服务器后端的方式。但是需要与企业进行沟通协商，不能采用上述方式的情况下，采用加密狗封装软件系统，做好软件、数据的加密、备份、安全等工作。\n九、国内外技术现状 智能冶炼工厂目前未见成熟应用，各科研院所和企业都在密切关注和研发中，其核心的数模优化控制系统已有多家单位开发，如太极集团为闪速炉开发的在线控制系统已在市场应用、江西迈凯冶金技术有限公司自主开发MetCal在线物料平衡计算目前已市场推广，中南大学研发的SKSSmelt软件已完成未见市场应用。\n十、成果应用前景 项目若在第一家企业成功应用并能稳定运行,将引发全有色行业乃至相关同类型行业的技术革新,不仅可以拓开老旧企业的改造升级市场，同时可应用推广到新建冶炼企业，为中国恩菲的冶炼技术智能和现代的标签，为开拓国际市场添上浓墨重彩的一笔。\n","description":"","id":59,"section":"sf","tags":null,"title":"恩菲智能工厂立项","uri":"http://austinzgx.github.io/sf/%E6%99%BA%E8%83%BD%E5%B7%A5%E5%8E%82%E7%AB%8B%E9%A1%B9/"},{"content":"平台开发明确需求  统一服务接口的数据采集功能（dcs生产主数据，化验分析、检斤计量等离散数据，外部接口数据）目前有华为的ROMA系统，赛迪的Cigma，也可以恩菲基于新一代的opc ua 通讯标准自主开发 统一的权限管理，消息队列服务，系统日志，系统数据安全等基础信息化组件，恩菲利用开源项目自主开发或集成第三方。 数据分类，数据处理算法，数据的意义由工艺赋予。自主开发，这个必须有恩菲掌握。我们核心买的就是算法，每一种金属每一种工艺一种分类和处理方法。 市场行情，业内动态等消息推送，私有云建设以后，恩菲与其发生交互的途径，可以定期定时发送信息，也是宣传推广的好手段  新一代信息技术在有色冶炼场景应用研究 数据采集与治理技术研究\n数据融合控制系统\n模型数据融合与数字化交付\n先进装备与智能感知\n多维可视化及即时仿真技术\n企业多网络融合与安全研究\n四个方面 先进感知\n针对有色冶炼企业生产中部分参数信息难以获取或数据不精准等问题，采用新型检测技术，融合高温热管、图像识别、声音识别等关键技术，提升设备数据、产品标识数据、工厂环境数据等生产现场数据采集能力，实时感知生产过程和关键装备运行数据和状态，实现对生产工况和设备运行的实时监控，为数据采集、故障检测与分析以及自动控制奠定基础。如溶液成分在线分析、管道结疤厚度判断、炉体熔池高度检测、炉窑热场比色识别、电解槽短路识别、阴阳极电流在线检测等。\n智能装备\n针对有色冶炼企业生产中部分劳动作业强度大、作业环境恶劣（高温、多粉尘、强腐蚀等）、人员安全风险大等问题，鼓励企业应用具有通讯接口，具备自我检测、自我诊断、自我调节、互联互通等功能的智能装备（包括工业机器人），降低人员劳动强度，提高生产安全性、质量稳定性和生产效率。实现最大程度地机械化替人、自动化减人，提高生产作业效率，降低作业风险。如智能天车、数字电解槽、自动开堵口机、自动换枪装置、转炉自动捅风眼机、极板自动转运仓储、自动剥板机等。\n先进过程控制\n先进过程控制系统(Advanced Process Control，简称APC)基于冶炼工艺的基本原理，依靠冶金热力学数据库，将实时采集的生产数据作为模型的输入条件及反馈修正的依据。通过冶炼企业的生产工艺控制过程的数学建模，采用先进的在线控制算法，无需人工干预即可在不 同的工况条件下自动实时计算，将不断自修正的模型计算输出，由自动化控制系统执行生产操作指令。实现生产操作调整的有理有据，按需敏捷，为冶炼生产作业的稳定连续作业和工艺优化提供重要技术保障，成为集约化生产的重要手段。\n管控一体化平台\n基于先进装备、智能感知的硬件采用，智能设备、工业物联网、大数据分析、移动应用等新一代IT技术的集成应用，逐步完成办公自动化、经营管理信息化、生产制造过程信息化、工艺优化控制、大数据分析与应用、智能辅助决策等各类企业业务场景需求的建设，实现生产过程的精细化管理，工艺控制的可持续改进以及生产经营的智能化辅助决策，使得企业的生产运营达到了以数字资源驱动的人机协同优化运行，提高企业运营效率和产品质量，实现以人为本的运营。\n开发建议 恩菲开发或集成的建议：按照软件工程技术流程开展工作，适当灵活调整。总体来说公司把两端，开发集成手段需放开。\n 首先根据需求确定产品或服务功能与定位，提交详细设计说明书（开发计划、数据交互、产品选型等），交由公司平台技术团队审批确定开发方案。 第二步，各业务领域灵活掌握，可以集成第三方或组织团队开发，按期提交业务代码或功能demo，公司平台团队给予支持和帮助，同时做好代码管理与审核。 最后，产品完成开发，共同完成测试与线上部署。平台技术团队扩展功能，丰富架构，进行下一步开发规划。  山金方案综述 结合山东黄金冶炼有限公司现状，综合利用现代技术手段，建设和提升自动化系统、智慧生产管控平台、管控平台调度中心以及通讯网络等配套设施。充分利用云服务技术、物联网技术、大数据技术等先进技术手段，进一步融合公司选冶设备、工艺、自动化与信息化，以提高选冶生产设备和工艺过程可靠性，提高过程自动化及操作智能化程度，稳定和优化流程，减员增效，提高技术和经济指标为目的，提高国际竞争力，建设国内领先、国际一流的智慧黄金选冶基地。\n 通过强化智能感知和控制层，对已有基础自动化系统的完善，补齐自动化短板、强化全厂智能化基础，通过实现泛在感知，为资产数字化创造条件。 利用新一代IT技术，打造工业互联网平台，实现对全厂数据的定义、采集、处理、存储、分析和对外服务，完成数据的汇聚，实现信息的互联互通，实现对人员、设备、物料与介质等资产的数字化和生产过程的数字化。 基于资产数字化，部署智慧应用,打造数字工厂,驱动精益制造，实现数据有效积累，以智慧应用和数据推动生产优化，让生产数据持续创造价值，实现数字资产化。 依托基础自动化水平提升、泛在感知和数字资产化，建立智慧生产运营中心。实现工厂全域全流程大规模集中智慧管控，持续降本增效，持续提升山东黄金的竞争力。   宣传建议 1、建议宣传材料ppt成稿后，可以进一步封装删减后开发恩菲智能理念与产品的web宣传网站，类似赛迪，此外可以提供产品体系里的一些应用的在线演示，如冶金计算、能耗指标计算等。有利于利于统一更新维护宣传版本与新方式推广。\n2、建议在工作小组内添加一项技术管理任务，使用现代化软件工程管理工具，形成恩菲软件开发环境的devops（代码管理、质量审核、运行测试、持续集成、持续部署）技术体系。因为大量的开发工作涉及到软件代码管理与测试工作，代码就是知识产权，这块可以参考消费互联网公司。不能所有人都拥有全部代码，所写的代码也必须进过自动化技术评审与测试才能上线。\n","description":"","id":60,"section":"sf","tags":null,"title":"支言片语","uri":"http://austinzgx.github.io/sf/other/"},{"content":"组织机构   department   NS LVC-低压配电 MVC-中压配电 IAC-工业事业部 庞刑健  PA Segment 张彦达  MM 建材/有色 杨航 Auto 汽车 张彦达 F\u0026amp;B 食品饮料 杨立里 Hydro 水电 张彦达   EU FS 售后   HDC DEC SPC HK SC DS GSC QCS PEC FIN HR - 人力资源 Strategy and BD Global Marketing CA adn SD GSMC kevin_Wei  毛春景 高钧州   GMO EIT Legal-法务    级别  尹正 13级\tCEO 庞刑健\t11级\tSVP 张彦达\t10级 OEM=\u0026gt;VP 杨航\\于龙\t9级\tMM 张官祥 8级\t经理  ","description":"","id":61,"section":"oa","tags":null,"title":"施耐德电气","uri":"http://austinzgx.github.io/oa/se_orgnization/"},{"content":"API接口服务用户  平台应用服务使用者 平台应用服务开发者 平台数据需求者 国家或行业监管方  组建模式 以恩菲牵头组织发起，联合天津超算中心或华为等优秀互联网公司作为技术合作方，成立有色冶炼云平台联盟组织。提供行业知识库、搭建基础公用服务，建设平台开发、服务应用等规范，形成有色冶炼工业互联网新生态圈。\n对任何遵循平台技术协议和规范要求的应用服务开发者、使用者开放。\n商业模式 类似苹果公司手机应用市场商业模式，开发者和苹果公司都可从使用方收益。不同点就是该平台存在第四方，数据需求方，而且服务应用使用方会产生价值数据，构成供需关系。因此平台商业模式多了一个层，最大程度上实现合作共赢。\n    收入 支出 备注     联盟组织 国家行业资金补+服务买卖合同20%+数据买卖合同20% 平台建设、运维 资助+抽成   服务应用开发者 服务应用使用者支付 向组织平台提供合同20% 卖应用   服务应用使用者 数据需求者支付 向组织平台提供合同20% 买应用，卖数据   数据需求者  向使用方购买数据费用 买数据    启动 联合设备商，集成设备信息数据库与云端SaaS服务，设备商愿意，业主也接受。探索运行方式的首选。\n","description":"","id":62,"section":"sf","tags":null,"title":"有色冶炼云平台设想","uri":"http://austinzgx.github.io/sf/cloud/"},{"content":"总体 2020年，有色金属行业统筹推进新冠肺炎疫情防控和复工复产工作，持续深化供给侧结构性改革，推进传统产业控产能、促转型，加快高端产业强基础、补短板，推动行业高质量发展，行业运行整体平稳。\n一、产量 平稳增长。据国家统计局数据，十种有色金属产量6168万吨，同比增长5.5%，增幅同比扩大2个百分点。中国有色金属工业协会发布四季度企业信心指数为50.1，连续两季度保持在临界点以上。\n2020年1-12月全国十种有色金属产量分月数据\n   时间 当期值(万吨) 累计值(万吨) 同比增长(%) 累计增长(%)     2020年2月 0 935.4 0 2.2   2020年3月 482.8 1417.2 1.6 2.1   2020年4月 492.7 1912.4 3.8 2.6   2020年5月 498.3 2413 4.1 2.7   2020年6月 508.2 2928.2 3.1 2.9   2020年7月 507.5 3459.7 3.3 3.1   2020年8月 528.6 3988.8 6.9 3.3   2020年9月 532.4 4517.5 7.3 3.5   2020年10月 544.7 5069 9 4.3   2020年11月 549.2 5632 6.1 4.6   2020年12月 574.6 6168 8.6 5.5    二、价格 逐步回暖。据中国有色金属工业协会统计，2020年，大宗有色金属价格经历“V型”走势，4月以来价格持续回暖.\n    产量万t 增长% 全年现货价格元/t 增长%     铜 1003 7.4 48752 2.1   铝 3708 4.9 14193 1.7   铅 644 9.4 14770 -11.3   锌 643 2.7 18496 -9.7    三、进出口 总额同比增加。据行业分析机构统计，2020年，有色金属进出口贸易总额1427亿美元，同比增长7.7%，其中，进口额1167亿美元，同比增长12.1%，出口额260亿美元，同比下降8.3%。\n铝行业 2020年，我国铝行业持续深化供给侧结构性改革，严控电解铝新增产能，严格落实产能置换，行业运行态势良好，效益明显改善。\n  一、产量平稳增长，价格同比回升。据国家统计局数据，2020年，氧化铝、电解铝、铝材产量分别为7313万吨、3708万吨、5779万吨，分别同比增长0.3%、4.9%、8.6%。据行业分析机构统计，12月下旬铝锭社会库存为59万吨，较年内高点回落65%，处于正常水平。据中国有色金属工业协会统计，4月以来，铝价逐步上涨，12月现货均价达到16480元/吨，同比上涨15%，创历史新高；全年现货均价14193元/吨，同比上涨1.7%。\n  二、贸易总额同比增长，铝材出口大幅下降。据海关总署数据，2020年，我国铝产品贸易总额达272亿元，同比增长3.4%，其中，出口贸易额135亿元，同比下降13.6%，进口贸易额137亿元，同比增长28.3%。进口方面，海外铝土矿供给持续提高，全年进口实物量11156万吨，同比增长10.9%；受价格内强外弱等因素影响，氧化铝、未锻轧铝分别进口381万吨、230万吨，同比增长131.3%、689%；受废料进口政策限制影响，进口铝废碎料83万吨，同比下降40.8%。出口方面，受海外疫情蔓延、贸易摩擦、内外价差等影响，出口铝材463万吨，同比下降10%。\n  铜行业 2020年，我国铜行业运行总体平稳，价格震荡上升，贸易总额同比增长，行业效益有所改善。\n  一、产量平稳增长，价格震荡上升。据国家统计局数据，2020年，精炼铜、铜材产量分别为1003万吨、2046万吨，分别同比增长7.4%、0.9%。据中国有色金属工业协会统计，2020年，铜价经历“V型”走势，全年现货均价48752元/吨，同比上涨2.1%。2020年，铜冶炼总回收率98.7%，同比提高0.2个百分点，铜冶炼综合能耗213.6千克标煤/吨，同比下降5.5%。根据行业分析机构统计，12月下旬铜库存下降至15万吨，较年内高点下降73%，处于正常水平。\n  二、贸易总额同比增长，进出口出现分化。据海关总署数据，2020年铜产品进出口贸易总额888亿美元，同比增长9.1%，其中进口额826亿美元，同比增长10.6%，出口额62亿美元，同比下降8.8%。进口方面，受禁止洋垃圾入境政策以及铜矿加工费低、国内硫酸滞销等因素影响，废铜、铜精矿进口实物量94万吨、2177万吨，同比下降36.9%、1%，粗铜、精炼铜进口量103万吨、467万吨，同比增长35.5%、31.5%。出口方面，未锻轧铜及铜材出口量74万吨，同比下降11.5%。\n  ","description":"","id":63,"section":"metal","tags":null,"title":"有色金属2020","uri":"http://austinzgx.github.io/metal/total/"}]